{"ast":null,"code":"import _slicedToArray from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _wrapNativeSuper from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\";\nimport _createForOfIteratorHelper from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toArray from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/toArray.js\";\nimport _toConsumableArray from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nfunction decode_arithmetic(bytes) {\n  var pos = 0;\n  function u16() {\n    return bytes[pos++] << 8 | bytes[pos++];\n  }\n\n  // decode the frequency table\n  var symbol_count = u16();\n  var total = 1;\n  var acc = [0, 1]; // first symbol has frequency 1\n  for (var i = 1; i < symbol_count; i++) {\n    acc.push(total += u16());\n  }\n\n  // skip the sized-payload that the last 3 symbols index into\n  var skip = u16();\n  var pos_payload = pos;\n  pos += skip;\n  var read_width = 0;\n  var read_buffer = 0;\n  function read_bit() {\n    if (read_width == 0) {\n      // this will read beyond end of buffer\n      // but (undefined|0) => zero pad\n      read_buffer = read_buffer << 8 | bytes[pos++];\n      read_width = 8;\n    }\n    return read_buffer >> --read_width & 1;\n  }\n  var N = 31;\n  var FULL = Math.pow(2, N);\n  var HALF = FULL >>> 1;\n  var QRTR = HALF >> 1;\n  var MASK = FULL - 1;\n\n  // fill register\n  var register = 0;\n  for (var _i = 0; _i < N; _i++) register = register << 1 | read_bit();\n  var symbols = [];\n  var low = 0;\n  var range = FULL; // treat like a float\n  while (true) {\n    var value = Math.floor(((register - low + 1) * total - 1) / range);\n    var start = 0;\n    var end = symbol_count;\n    while (end - start > 1) {\n      // binary search\n      var mid = start + end >>> 1;\n      if (value < acc[mid]) {\n        end = mid;\n      } else {\n        start = mid;\n      }\n    }\n    if (start == 0) break; // first symbol is end mark\n    symbols.push(start);\n    var a = low + Math.floor(range * acc[start] / total);\n    var b = low + Math.floor(range * acc[start + 1] / total) - 1;\n    while (((a ^ b) & HALF) == 0) {\n      register = register << 1 & MASK | read_bit();\n      a = a << 1 & MASK;\n      b = b << 1 & MASK | 1;\n    }\n    while (a & ~b & QRTR) {\n      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();\n      a = a << 1 ^ HALF;\n      b = (b ^ HALF) << 1 | HALF | 1;\n    }\n    low = a;\n    range = 1 + b - a;\n  }\n  var offset = symbol_count - 4;\n  return symbols.map(function (x) {\n    // index into payload\n    switch (x - offset) {\n      case 3:\n        return offset + 0x10100 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n      case 2:\n        return offset + 0x100 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n      case 1:\n        return offset + bytes[pos_payload++];\n      default:\n        return x - 1;\n    }\n  });\n}\n\n// returns an iterator which returns the next symbol\nfunction read_payload(v) {\n  var pos = 0;\n  return function () {\n    return v[pos++];\n  };\n}\nfunction read_compressed_payload(s) {\n  return read_payload(decode_arithmetic(unsafe_atob(s)));\n}\n\n// unsafe in the sense:\n// expected well-formed Base64 w/o padding \nfunction unsafe_atob(s) {\n  var lookup = [];\n  _toConsumableArray('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/').forEach(function (c, i) {\n    return lookup[c.charCodeAt(0)] = i;\n  });\n  var n = s.length;\n  var ret = new Uint8Array(6 * n >> 3);\n  for (var i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {\n    carry = carry << 6 | lookup[s.charCodeAt(i)];\n    width += 6;\n    if (width >= 8) {\n      ret[pos++] = carry >> (width -= 8);\n    }\n  }\n  return ret;\n}\n\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\nfunction signed(i) {\n  return i & 1 ? ~i >> 1 : i >> 1;\n}\nfunction read_deltas(n, next) {\n  var v = Array(n);\n  for (var i = 0, x = 0; i < n; i++) v[i] = x += signed(next());\n  return v;\n}\n\n// [123][5] => [0 3] [1 1] [0 0]\nfunction read_sorted(next) {\n  var prev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var ret = [];\n  while (true) {\n    var x = next();\n    var n = next();\n    if (!n) break;\n    prev += x;\n    for (var i = 0; i < n; i++) {\n      ret.push(prev + i);\n    }\n    prev += n + 1;\n  }\n  return ret;\n}\nfunction read_sorted_arrays(next) {\n  return read_array_while(function () {\n    var v = read_sorted(next);\n    if (v.length) return v;\n  });\n}\n\n// returns map of x => ys\nfunction read_mapped(next) {\n  var ret = [];\n  while (true) {\n    var w = next();\n    if (w == 0) break;\n    ret.push(read_linear_table(w, next));\n  }\n  while (true) {\n    var _w = next() - 1;\n    if (_w < 0) break;\n    ret.push(read_replacement_table(_w, next));\n  }\n  return ret.flat();\n}\n\n// read until next is falsy\n// return array of read values\nfunction read_array_while(next) {\n  var v = [];\n  while (true) {\n    var x = next(v.length);\n    if (!x) break;\n    v.push(x);\n  }\n  return v;\n}\n\n// read w columns of length n\n// return as n rows of length w\nfunction read_transposed(n, w, next) {\n  var m = Array(n).fill().map(function () {\n    return [];\n  });\n  for (var i = 0; i < w; i++) {\n    read_deltas(n, next).forEach(function (x, j) {\n      return m[j].push(x);\n    });\n  }\n  return m;\n}\n\n// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]\n// where dx/dy = steps, n = run size, w = length of y\nfunction read_linear_table(w, next) {\n  var dx = 1 + next();\n  var dy = next();\n  var vN = read_array_while(next);\n  var m = read_transposed(vN.length, 1 + w, next);\n  return m.flatMap(function (v, i) {\n    var _v = _toArray(v),\n      x = _v[0],\n      ys = _v.slice(1);\n    return Array(vN[i]).fill().map(function (_, j) {\n      var j_dy = j * dy;\n      return [x + j * dx, ys.map(function (y) {\n        return y + j_dy;\n      })];\n    });\n  });\n}\n\n// return [[x, ys...], ...]\n// where w = length of y\nfunction read_replacement_table(w, next) {\n  var n = 1 + next();\n  var m = read_transposed(n, 1 + w, next);\n  return m.map(function (v) {\n    return [v[0], v.slice(1)];\n  });\n}\n\n// created 2023-02-21T09:18:13.549Z\nvar r$1 = read_compressed_payload('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');\nvar FENCED = new Map([[8217, \"apostrophe\"], [8260, \"fraction slash\"], [12539, \"middle dot\"]]);\nvar NSM_MAX = 4;\nfunction hex_cp(cp) {\n  return cp.toString(16).toUpperCase().padStart(2, '0');\n}\nfunction quote_cp(cp) {\n  return \"{\".concat(hex_cp(cp), \"}\"); // raffy convention: like \"\\u{X}\" w/o the \"\\u\"\n}\n\n/*\r\nexport function explode_cp(s) {\r\n\treturn [...s].map(c => c.codePointAt(0));\r\n}\r\n*/\nfunction explode_cp(s) {\n  // this is about 2x faster\n  var cps = [];\n  for (var pos = 0, len = s.length; pos < len;) {\n    var cp = s.codePointAt(pos);\n    pos += cp < 0x10000 ? 1 : 2;\n    cps.push(cp);\n  }\n  return cps;\n}\nfunction str_from_cps(cps) {\n  var chunk = 4096;\n  var len = cps.length;\n  if (len < chunk) return String.fromCodePoint.apply(String, _toConsumableArray(cps));\n  var buf = [];\n  for (var i = 0; i < len;) {\n    buf.push(String.fromCodePoint.apply(String, _toConsumableArray(cps.slice(i, i += chunk))));\n  }\n  return buf.join('');\n}\nfunction compare_arrays(a, b) {\n  var n = a.length;\n  var c = n - b.length;\n  for (var i = 0; c == 0 && i < n; i++) c = a[i] - b[i];\n  return c;\n}\n\n// created 2023-02-21T09:18:13.549Z\nvar r = read_compressed_payload('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');\n\n// https://unicode.org/reports/tr15/\n\nfunction unpack_cc(packed) {\n  return packed >> 24 & 0xFF;\n}\nfunction unpack_cp(packed) {\n  return packed & 0xFFFFFF;\n}\nvar SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap(function (v, i) {\n  return v.map(function (x) {\n    return [x, i + 1 << 24];\n  });\n})); // pre-shifted\nvar EXCLUSIONS = new Set(read_sorted(r));\nvar DECOMP = new Map();\nvar RECOMP = new Map();\nvar _iterator = _createForOfIteratorHelper(read_mapped(r)),\n  _step;\ntry {\n  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n    var _step$value = _slicedToArray(_step.value, 2),\n      cp = _step$value[0],\n      cps = _step$value[1];\n    if (!EXCLUSIONS.has(cp) && cps.length == 2) {\n      var _cps3 = _slicedToArray(cps, 2),\n        a = _cps3[0],\n        b = _cps3[1];\n      var bucket = RECOMP.get(a);\n      if (!bucket) {\n        bucket = new Map();\n        RECOMP.set(a, bucket);\n      }\n      bucket.set(b, cp);\n    }\n    DECOMP.set(cp, cps.reverse()); // stored reversed\n  }\n\n  // algorithmic hangul\n  // https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)\n} catch (err) {\n  _iterator.e(err);\n} finally {\n  _iterator.f();\n}\nvar S0 = 0xAC00;\nvar L0 = 0x1100;\nvar V0 = 0x1161;\nvar T0 = 0x11A7;\nvar L_COUNT = 19;\nvar V_COUNT = 21;\nvar T_COUNT = 28;\nvar N_COUNT = V_COUNT * T_COUNT;\nvar S_COUNT = L_COUNT * N_COUNT;\nvar S1 = S0 + S_COUNT;\nvar L1 = L0 + L_COUNT;\nvar V1 = V0 + V_COUNT;\nvar T1 = T0 + T_COUNT;\nfunction is_hangul(cp) {\n  return cp >= S0 && cp < S1;\n}\nfunction compose_pair(a, b) {\n  if (a >= L0 && a < L1 && b >= V0 && b < V1) {\n    return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;\n  } else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {\n    return a + (b - T0);\n  } else {\n    var recomp = RECOMP.get(a);\n    if (recomp) {\n      recomp = recomp.get(b);\n      if (recomp) {\n        return recomp;\n      }\n    }\n    return -1;\n  }\n}\nfunction decomposed(cps) {\n  var ret = [];\n  var buf = [];\n  var check_order = false;\n  function add(cp) {\n    var cc = SHIFTED_RANK.get(cp);\n    if (cc) {\n      check_order = true;\n      cp |= cc;\n    }\n    ret.push(cp);\n  }\n  var _iterator2 = _createForOfIteratorHelper(cps),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var cp = _step2.value;\n      while (true) {\n        if (cp < 0x80) {\n          ret.push(cp);\n        } else if (is_hangul(cp)) {\n          var s_index = cp - S0;\n          var l_index = s_index / N_COUNT | 0;\n          var v_index = s_index % N_COUNT / T_COUNT | 0;\n          var t_index = s_index % T_COUNT;\n          add(L0 + l_index);\n          add(V0 + v_index);\n          if (t_index > 0) add(T0 + t_index);\n        } else {\n          var mapped = DECOMP.get(cp);\n          if (mapped) {\n            buf.push.apply(buf, _toConsumableArray(mapped));\n          } else {\n            add(cp);\n          }\n        }\n        if (!buf.length) break;\n        cp = buf.pop();\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  if (check_order && ret.length > 1) {\n    var prev_cc = unpack_cc(ret[0]);\n    for (var i = 1; i < ret.length; i++) {\n      var cc = unpack_cc(ret[i]);\n      if (cc == 0 || prev_cc <= cc) {\n        prev_cc = cc;\n        continue;\n      }\n      var j = i - 1;\n      while (true) {\n        var tmp = ret[j + 1];\n        ret[j + 1] = ret[j];\n        ret[j] = tmp;\n        if (!j) break;\n        prev_cc = unpack_cc(ret[--j]);\n        if (prev_cc <= cc) break;\n      }\n      prev_cc = unpack_cc(ret[i]);\n    }\n  }\n  return ret;\n}\nfunction composed_from_decomposed(v) {\n  var ret = [];\n  var stack = [];\n  var prev_cp = -1;\n  var prev_cc = 0;\n  var _iterator3 = _createForOfIteratorHelper(v),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var packed = _step3.value;\n      var cc = unpack_cc(packed);\n      var cp = unpack_cp(packed);\n      if (prev_cp == -1) {\n        if (cc == 0) {\n          prev_cp = cp;\n        } else {\n          ret.push(cp);\n        }\n      } else if (prev_cc > 0 && prev_cc >= cc) {\n        if (cc == 0) {\n          ret.push.apply(ret, [prev_cp].concat(stack));\n          stack.length = 0;\n          prev_cp = cp;\n        } else {\n          stack.push(cp);\n        }\n        prev_cc = cc;\n      } else {\n        var composed = compose_pair(prev_cp, cp);\n        if (composed >= 0) {\n          prev_cp = composed;\n        } else if (prev_cc == 0 && cc == 0) {\n          ret.push(prev_cp);\n          prev_cp = cp;\n        } else {\n          stack.push(cp);\n          prev_cc = cc;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  if (prev_cp >= 0) {\n    ret.push.apply(ret, [prev_cp].concat(stack));\n  }\n  return ret;\n}\n\n// note: cps can be iterable\nfunction nfd(cps) {\n  return decomposed(cps).map(unpack_cp);\n}\nfunction nfc(cps) {\n  return composed_from_decomposed(decomposed(cps));\n}\n\n//const t0 = performance.now();\n\nvar STOP = 0x2E;\nvar FE0F = 0xFE0F;\nvar STOP_CH = '.';\nvar UNIQUE_PH = 1;\nvar HYPHEN = 0x2D;\nfunction read_set() {\n  return new Set(read_sorted(r$1));\n}\nvar MAPPED = new Map(read_mapped(r$1));\nvar IGNORED = read_set(); // ignored characters are not valid, so just read raw codepoints\n/*\r\n// direct include from payload is smaller that the decompression code\r\nconst FENCED = new Map(read_array_while(() => {\r\n\tlet cp = r();\r\n\tif (cp) return [cp, read_str(r())];\r\n}));\r\n*/\n// 20230217: we still need all CM for proper error formatting\n// but norm only needs NSM subset that are potentially-valid\nvar CM = read_set();\nvar NSM = new Set(read_sorted(r$1).map(function (i) {\n  return this[i];\n}, _toConsumableArray(CM)));\n/*\r\nconst CM_SORTED = read_sorted(r);\r\nconst NSM = new Set(read_sorted(r).map(i => CM_SORTED[i]));\r\nconst CM = new Set(CM_SORTED);\r\n*/\nvar ESCAPE = read_set(); // characters that should not be printed\nvar NFC_CHECK = read_set();\nvar CHUNKS = read_sorted_arrays(r$1);\nfunction read_chunked() {\n  // deduplicated sets + uniques\n  return new Set([read_sorted(r$1).map(function (i) {\n    return CHUNKS[i];\n  }), read_sorted(r$1)].flat(2));\n}\nvar UNRESTRICTED = r$1();\nvar GROUPS = read_array_while(function (i) {\n  // minifier property mangling seems unsafe\n  // so these are manually renamed to single chars\n  var N = read_array_while(r$1).map(function (x) {\n    return x + 0x60;\n  });\n  if (N.length) {\n    var R = i >= UNRESTRICTED; // first arent restricted\n    N[0] -= 32; // capitalize\n    N = str_from_cps(N);\n    if (R) N = \"Restricted[\".concat(N, \"]\");\n    var P = read_chunked(); // primary\n    var Q = read_chunked(); // secondary\n    var V = [].concat(_toConsumableArray(P), _toConsumableArray(Q)).sort(function (a, b) {\n      return a - b;\n    }); // derive: sorted valid\n    //let M = r()-1; // combining mark\n    var M = !r$1(); // not-whitelisted, check for NSM\n    // code currently isn't needed\n    /*if (M < 0) { // whitelisted\r\n    \tM = new Map(read_array_while(() => {\r\n    \t\tlet i = r();\r\n    \t\tif (i) return [V[i-1], read_array_while(() => {\r\n    \t\t\tlet v = read_array_while(r);\r\n    \t\t\tif (v.length) return v.map(x => x-1);\r\n    \t\t})];\r\n    \t}));\r\n    }*/\n    return {\n      N: N,\n      P: P,\n      M: M,\n      R: R,\n      V: new Set(V)\n    };\n  }\n});\nvar WHOLE_VALID = read_set();\nvar WHOLE_MAP = new Map();\n// decode compressed wholes\n[].concat(_toConsumableArray(WHOLE_VALID), _toConsumableArray(read_set())).sort(function (a, b) {\n  return a - b;\n}).map(function (cp, i, v) {\n  var d = r$1();\n  var w = v[i] = d ? v[i - d] : {\n    V: [],\n    M: new Map()\n  };\n  w.V.push(cp); // add to member set\n  if (!WHOLE_VALID.has(cp)) {\n    WHOLE_MAP.set(cp, w); // register with whole map\n  }\n});\n// compute confusable-extent complements\nvar _iterator4 = _createForOfIteratorHelper(new Set(WHOLE_MAP.values())),\n  _step4;\ntry {\n  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n    var _step4$value = _step4.value,\n      V = _step4$value.V,\n      M = _step4$value.M;\n    // connect all groups that have each whole character\n    var recs = [];\n    var _iterator14 = _createForOfIteratorHelper(V),\n      _step14;\n    try {\n      var _loop6 = function _loop6() {\n        var cp = _step14.value;\n        var gs = GROUPS.filter(function (g) {\n          return g.V.has(cp);\n        });\n        var rec = recs.find(function (_ref4) {\n          var G = _ref4.G;\n          return gs.some(function (g) {\n            return G.has(g);\n          });\n        });\n        if (!rec) {\n          rec = {\n            G: new Set(),\n            V: []\n          };\n          recs.push(rec);\n        }\n        rec.V.push(cp);\n        gs.forEach(function (g) {\n          return rec.G.add(g);\n        });\n      };\n      for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n        _loop6();\n      }\n      // per character cache groups which are not a member of the extent\n    } catch (err) {\n      _iterator14.e(err);\n    } finally {\n      _iterator14.f();\n    }\n    var _union = recs.flatMap(function (_ref3) {\n      var G = _ref3.G;\n      return _toConsumableArray(G);\n    });\n    var _loop5 = function _loop5() {\n      var _recs$_i = _recs[_i2],\n        G = _recs$_i.G,\n        V = _recs$_i.V;\n      var complement = new Set(_union.filter(function (g) {\n        return !G.has(g);\n      }));\n      var _iterator15 = _createForOfIteratorHelper(V),\n        _step15;\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var _cp2 = _step15.value;\n          M.set(_cp2, complement);\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n    };\n    for (var _i2 = 0, _recs = recs; _i2 < _recs.length; _i2++) {\n      _loop5();\n    }\n  }\n} catch (err) {\n  _iterator4.e(err);\n} finally {\n  _iterator4.f();\n}\nvar union = new Set(); // exists in 1+ groups\nvar multi = new Set(); // exists in 2+ groups\nvar _iterator5 = _createForOfIteratorHelper(GROUPS),\n  _step5;\ntry {\n  for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n    var g = _step5.value;\n    var _iterator16 = _createForOfIteratorHelper(g.V),\n      _step16;\n    try {\n      for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n        var _cp3 = _step16.value;\n        (union.has(_cp3) ? multi : union).add(_cp3);\n      }\n    } catch (err) {\n      _iterator16.e(err);\n    } finally {\n      _iterator16.f();\n    }\n  }\n  // dual purpose WHOLE_MAP: return placeholder if unique non-confusable\n} catch (err) {\n  _iterator5.e(err);\n} finally {\n  _iterator5.f();\n}\nvar _iterator6 = _createForOfIteratorHelper(union),\n  _step6;\ntry {\n  for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n    var _cp4 = _step6.value;\n    if (!WHOLE_MAP.has(_cp4) && !multi.has(_cp4)) {\n      WHOLE_MAP.set(_cp4, UNIQUE_PH);\n    }\n  }\n} catch (err) {\n  _iterator6.e(err);\n} finally {\n  _iterator6.f();\n}\nvar VALID = new Set([].concat(_toConsumableArray(union), _toConsumableArray(nfd(union)))); // possibly valid\n\n// decode emoji\nvar EMOJI_SORTED = read_sorted(r$1); // temporary\n//const EMOJI_SOLO = new Set(read_sorted(r).map(i => EMOJI_SORTED[i])); // not needed\nvar EMOJI_ROOT = read_emoji_trie([]);\nfunction read_emoji_trie(cps) {\n  var B = read_array_while(function () {\n    var keys = read_sorted(r$1).map(function (i) {\n      return EMOJI_SORTED[i];\n    });\n    if (keys.length) return read_emoji_trie(keys);\n  }).sort(function (a, b) {\n    return b.Q.size - a.Q.size;\n  }); // sort by likelihood\n  var temp = r$1();\n  var V = temp % 3; // valid (0 = false, 1 = true, 2 = weird)\n  temp = temp / 3 | 0;\n  var F = temp & 1; // allow FE0F\n  temp >>= 1;\n  var S = temp & 1; // save\n  var C = temp & 2; // check\n  return {\n    B: B,\n    V: V,\n    F: F,\n    S: S,\n    C: C,\n    Q: new Set(cps)\n  };\n}\n//console.log(performance.now() - t0);\n\n// free tagging system\nvar Emoji = /*#__PURE__*/function (_Array) {\n  _inherits(Emoji, _Array);\n  var _super = _createSuper(Emoji);\n  function Emoji() {\n    _classCallCheck(this, Emoji);\n    return _super.apply(this, arguments);\n  }\n  _createClass(Emoji, [{\n    key: \"is_emoji\",\n    get: function get() {\n      return true;\n    }\n  }]);\n  return Emoji;\n}( /*#__PURE__*/_wrapNativeSuper(Array)); // create a safe to print string \n// invisibles are escaped\n// leading cm uses placeholder\n// quoter(cp) => string, eg. 3000 => \"{3000}\"\n// note: in html, you'd call this function then replace [<>&] with entities\nfunction safe_str_from_cps(cps) {\n  var quoter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : quote_cp;\n  //if (Number.isInteger(cps)) cps = [cps];\n  //if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);\n  var buf = [];\n  if (is_combining_mark(cps[0])) buf.push('◌');\n  var prev = 0;\n  var n = cps.length;\n  for (var i = 0; i < n; i++) {\n    var cp = cps[i];\n    if (should_escape(cp)) {\n      buf.push(str_from_cps(cps.slice(prev, i)));\n      buf.push(quoter(cp));\n      prev = i + 1;\n    }\n  }\n  buf.push(str_from_cps(cps.slice(prev, n)));\n  return buf.join('');\n}\n\n// if escaped: {HEX}\n//       else: \"x\" {HEX}\nfunction quoted_cp(cp) {\n  return (should_escape(cp) ? '' : \"\".concat(bidi_qq(safe_str_from_cps([cp])), \" \")) + quote_cp(cp);\n}\n\n// 20230211: some messages can be mixed-directional and result in spillover\n// use 200E after a quoted string to force the remainder of a string from \n// acquring the direction of the quote\n// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions\nfunction bidi_qq(s) {\n  return \"\\\"\".concat(s, \"\\\"\\u200E\"); // strong LTR\n}\n\nfunction check_label_extension(cps) {\n  if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\n    throw new Error('invalid label extension');\n  }\n}\nfunction check_leading_underscore(cps) {\n  var UNDERSCORE = 0x5F;\n  for (var i = cps.lastIndexOf(UNDERSCORE); i > 0;) {\n    if (cps[--i] !== UNDERSCORE) {\n      throw new Error('underscore allowed only at start');\n    }\n  }\n}\n// check that a fenced cp is not leading, trailing, or touching another fenced cp\nfunction check_fenced(cps) {\n  var cp = cps[0];\n  var prev = FENCED.get(cp);\n  if (prev) throw error_placement(\"leading \".concat(prev));\n  var n = cps.length;\n  var last = -1; // prevents trailing from throwing\n  for (var i = 1; i < n; i++) {\n    cp = cps[i];\n    var match = FENCED.get(cp);\n    if (match) {\n      // since cps[0] isn't fenced, cps[1] cannot throw\n      if (last == i) throw error_placement(\"\".concat(prev, \" + \").concat(match));\n      last = i + 1;\n      prev = match;\n    }\n  }\n  if (last == n) throw error_placement(\"trailing \".concat(prev));\n}\n\n// note: set(s) cannot be exposed because they can be modified\nfunction is_combining_mark(cp) {\n  return CM.has(cp);\n}\nfunction should_escape(cp) {\n  return ESCAPE.has(cp);\n}\nfunction ens_normalize_fragment(frag, decompose) {\n  var nf = decompose ? nfd : nfc;\n  return frag.split(STOP_CH).map(function (label) {\n    return str_from_cps(process(explode_cp(label), nf).flatMap(function (x) {\n      return x.is_emoji ? filter_fe0f(x) : x;\n    }));\n  }).join(STOP_CH);\n}\nfunction ens_normalize(name) {\n  return flatten(ens_split(name));\n}\nfunction ens_beautify(name) {\n  var split = ens_split(name, true);\n  // this is experimental\n  var _iterator7 = _createForOfIteratorHelper(split),\n    _step7;\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var _step7$value = _step7.value,\n        type = _step7$value.type,\n        output = _step7$value.output,\n        error = _step7$value.error;\n      if (error) continue;\n\n      // replace leading/trailing hyphen\n      // 20230121: consider beautifing all or leading/trailing hyphen to unicode variant\n      // not exactly the same in every font, but very similar: \"-\" vs \"‐\"\n      /*\r\n      const UNICODE_HYPHEN = 0x2010;\r\n      // maybe this should replace all for visual consistancy?\r\n      // `node tools/reg-count.js regex ^-\\{2,\\}` => 592\r\n      //for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;\r\n      if (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;\r\n      let end = output.length-1;\r\n      if (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;\r\n      */\n      // 20230123: WHATWG URL uses \"CheckHyphens\" false\n      // https://url.spec.whatwg.org/#idna\n\n      // update ethereum symbol\n      // ξ => Ξ if not greek\n      if (type !== 'Greek') {\n        var prev = 0;\n        while (true) {\n          var next = output.indexOf(0x3BE, prev);\n          if (next < 0) break;\n          output[next] = 0x39E;\n          prev = next + 1;\n        }\n      }\n\n      // 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)\n      // could be fixed with special case for: 2D (.) + 200E (LTR)\n      //output.splice(0, 0, 0x200E);\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n  return flatten(split);\n}\nfunction ens_split(name, preserve_emoji) {\n  var offset = 0;\n  // https://unicode.org/reports/tr46/#Validity_Criteria\n  // 4.) \"The label must not contain a U+002E ( . ) FULL STOP.\"\n  return name.split(STOP_CH).map(function (label) {\n    var input = explode_cp(label);\n    var info = {\n      input: input,\n      offset: offset // codepoint, not substring!\n    };\n\n    offset += input.length + 1; // + stop\n    var norm;\n    try {\n      // 1.) \"The label must be in Unicode Normalization Form NFC\"\n      var tokens = info.tokens = process(input, nfc); // if we parse, we get [norm and mapped]\n      var token_count = tokens.length;\n      var type;\n      if (!token_count) {\n        // the label was effectively empty (could of had ignored characters)\n        // 20230120: change to strict\n        // https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59\n        //norm = [];\n        //type = 'None'; // use this instead of next match, \"ASCII\"\n        throw new Error(\"empty label\");\n      } else {\n        var chars = tokens[0];\n        var emoji = token_count > 1 || chars.is_emoji;\n        if (!emoji && chars.every(function (cp) {\n          return cp < 0x80;\n        })) {\n          // special case for ascii\n          norm = chars;\n          check_leading_underscore(norm);\n          // only needed for ascii\n          // 20230123: matches matches WHATWG, see note 3.3\n          check_label_extension(norm);\n          // cant have fenced\n          // cant have cm\n          // cant have wholes\n          // see derive: \"Fastpath ASCII\"\n          type = 'ASCII';\n        } else {\n          if (emoji) {\n            // there is at least one emoji\n            info.emoji = true;\n            chars = tokens.flatMap(function (x) {\n              return x.is_emoji ? [] : x;\n            }); // all of the nfc tokens concat together\n          }\n\n          norm = tokens.flatMap(function (x) {\n            return !preserve_emoji && x.is_emoji ? filter_fe0f(x) : x;\n          });\n          check_leading_underscore(norm);\n          if (!chars.length) {\n            // theres no text, just emoji\n            type = 'Emoji';\n          } else {\n            // 5. \"The label must not begin with a combining mark, that is: General_Category=Mark.\"\n            if (CM.has(norm[0])) throw error_placement('leading combining mark');\n            for (var i = 1; i < token_count; i++) {\n              // we've already checked the first token\n              var cps = tokens[i];\n              if (!cps.is_emoji && CM.has(cps[0])) {\n                // every text token has emoji neighbors, eg. EtEEEtEt...\n                // bidi_qq() not needed since emoji is LTR and cps is a CM\n                throw error_placement(\"emoji + combining mark: \\\"\".concat(str_from_cps(tokens[i - 1]), \" + \").concat(safe_str_from_cps([cps[0]]), \"\\\"\"));\n              }\n            }\n            check_fenced(norm);\n            var unique = _toConsumableArray(new Set(chars));\n            var _determine_group = determine_group(unique),\n              _determine_group2 = _slicedToArray(_determine_group, 1),\n              g = _determine_group2[0]; // take the first match\n            // see derive: \"Matching Groups have Same CM Style\"\n            // alternative: could form a hybrid type: Latin/Japanese/...\t\n            check_group(g, chars); // need text in order\n            check_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)\n            type = g.N;\n            // 20230121: consider exposing restricted flag\n            // it's simpler to just check for 'Restricted'\n            // or even better: type.endsWith(']')\n            //if (g.R) info.restricted = true;\n          }\n        }\n      }\n\n      info.type = type;\n    } catch (err) {\n      info.error = err; // use full error object\n    }\n\n    info.output = norm;\n    return info;\n  });\n}\nfunction check_whole(group, unique) {\n  var maker;\n  var shared = []; // TODO: can this be avoided?\n  var _iterator8 = _createForOfIteratorHelper(unique),\n    _step8;\n  try {\n    var _loop2 = function _loop2() {\n      var cp = _step8.value;\n      var whole = WHOLE_MAP.get(cp);\n      if (whole === UNIQUE_PH) return {\n        v: void 0\n      }; // unique, non-confusable\n      if (whole) {\n        var set = whole.M.get(cp); // groups which have a character that look-like this character\n        maker = maker ? maker.filter(function (g) {\n          return set.has(g);\n        }) : _toConsumableArray(set);\n        if (!maker.length) return {\n          v: void 0\n        }; // confusable intersection is empty\n      } else {\n        shared.push(cp);\n      }\n    };\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var _ret = _loop2();\n      if (typeof _ret === \"object\") return _ret.v;\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n  if (maker) {\n    // we have 1+ confusable\n    // check if any of the remaning groups\n    // contain the shared characters too\n    var _iterator9 = _createForOfIteratorHelper(maker),\n      _step9;\n    try {\n      var _loop = function _loop() {\n        var g = _step9.value;\n        if (shared.every(function (cp) {\n          return g.V.has(cp);\n        })) {\n          throw new Error(\"whole-script confusable: \".concat(group.N, \"/\").concat(g.N));\n        }\n      };\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        _loop();\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n  }\n}\n\n// assumption: unique.size > 0\n// returns list of matching groups\nfunction determine_group(unique) {\n  var groups = GROUPS;\n  var _iterator10 = _createForOfIteratorHelper(unique),\n    _step10;\n  try {\n    var _loop3 = function _loop3() {\n      var cp = _step10.value;\n      // note: we need to dodge CM that are whitelisted\n      // but that code isn't currently necessary\n      var gs = groups.filter(function (g) {\n        return g.V.has(cp);\n      });\n      if (!gs.length) {\n        if (groups === GROUPS) {\n          // the character was composed of valid parts\n          // but it's NFC form is invalid\n          throw error_disallowed(cp); // this should be rare\n        } else {\n          // there is no group that contains all these characters\n          // throw using the highest priority group that matched\n          // https://www.unicode.org/reports/tr39/#mixed_script_confusables\n          throw error_group_member(groups[0], cp);\n        }\n      }\n      groups = gs;\n      if (gs.length == 1) return \"break\"; // there is only one group left\n    };\n    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n      var _ret2 = _loop3();\n      if (_ret2 === \"break\") break;\n    }\n    // there are at least 1 group(s) with all of these characters\n  } catch (err) {\n    _iterator10.e(err);\n  } finally {\n    _iterator10.f();\n  }\n  return groups;\n}\n\n// throw on first error\nfunction flatten(split) {\n  return split.map(function (_ref) {\n    var input = _ref.input,\n      error = _ref.error,\n      output = _ref.output;\n    if (error) {\n      // don't print label again if just a single label\n      var msg = error.message;\n      // bidi_qq() only necessary if msg is digits\n      throw new Error(split.length == 1 ? msg : \"Invalid label \".concat(bidi_qq(safe_str_from_cps(input)), \": \").concat(msg));\n    }\n    return str_from_cps(output);\n  }).join(STOP_CH);\n}\nfunction error_disallowed(cp) {\n  // TODO: add cp to error?\n  return new Error(\"disallowed character: \".concat(quoted_cp(cp)));\n}\nfunction error_group_member(g, cp) {\n  var quoted = quoted_cp(cp);\n  var gg = GROUPS.find(function (g) {\n    return g.P.has(cp);\n  });\n  if (gg) {\n    quoted = \"\".concat(gg.N, \" \").concat(quoted);\n  }\n  return new Error(\"illegal mixture: \".concat(g.N, \" + \").concat(quoted));\n}\nfunction error_placement(where) {\n  return new Error(\"illegal placement: \".concat(where));\n}\n\n// assumption: cps.length > 0\n// assumption: cps[0] isn't a CM\n// assumption: the previous character isn't an emoji\nfunction check_group(g, cps) {\n  var V = g.V,\n    M = g.M;\n  var _iterator11 = _createForOfIteratorHelper(cps),\n    _step11;\n  try {\n    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n      var _cp = _step11.value;\n      if (!V.has(_cp)) {\n        // for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. \"e{300}{300}\"\n        // at the moment, it's unnecessary to introduce an extra error type\n        // until there exists a whitelisted multi-character\n        //   eg. if (M < 0 && is_combining_mark(cp)) { ... }\n        // there are 3 cases:\n        //   1. illegal cm for wrong group => mixture error\n        //   2. illegal cm for same group => cm error\n        //       requires set of whitelist cm per group: \n        //        eg. new Set([...g.V].flatMap(nfc).filter(cp => CM.has(cp)))\n        //   3. wrong group => mixture error\n        throw error_group_member(g, _cp);\n      }\n    }\n    //if (M >= 0) { // we have a known fixed cm count\n  } catch (err) {\n    _iterator11.e(err);\n  } finally {\n    _iterator11.f();\n  }\n  if (M) {\n    // we need to check for NSM\n    var _decomposed = nfd(cps);\n    for (var i = 1, e = _decomposed.length; i < e; i++) {\n      // see: assumption\n      // 20230210: bugfix: using cps instead of decomposed h/t Carbon225\n      /*\r\n      if (CM.has(decomposed[i])) {\r\n      \tlet j = i + 1;\r\n      \twhile (j < e && CM.has(decomposed[j])) j++;\r\n      \tif (j - i > M) {\r\n      \t\tthrow new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);\r\n      \t}\r\n      \ti = j;\r\n      }\r\n      */\n      // 20230217: switch to NSM counting\n      // https://www.unicode.org/reports/tr39/#Optional_Detection\n      if (NSM.has(_decomposed[i])) {\n        var j = i + 1;\n        for (var cp; j < e && NSM.has(cp = _decomposed[j]); j++) {\n          // a. Forbid sequences of the same nonspacing mark.\n          for (var k = i; k < j; k++) {\n            // O(n^2) but n < 100\n            if (_decomposed[k] == cp) {\n              throw new Error(\"non-spacing marks: repeated \".concat(quoted_cp(cp)));\n            }\n          }\n        }\n        // parse to end so we have full nsm count\n        // b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).\n        if (j - i > NSM_MAX) {\n          // note: this slice starts with a base char or spacing-mark cm\n          throw new Error(\"non-spacing marks: too many \".concat(bidi_qq(safe_str_from_cps(_decomposed.slice(i - 1, j))), \" (\").concat(j - i, \"/\").concat(NSM_MAX, \")\"));\n        }\n        i = j;\n      }\n    }\n  }\n  // *** this code currently isn't needed ***\n  /*\r\n  let cm_whitelist = M instanceof Map;\r\n  for (let i = 0, e = cps.length; i < e; ) {\r\n  \tlet cp = cps[i++];\r\n  \tlet seqs = cm_whitelist && M.get(cp);\r\n  \tif (seqs) { \r\n  \t\t// list of codepoints that can follow\r\n  \t\t// if this exists, this will always be 1+\r\n  \t\tlet j = i;\r\n  \t\twhile (j < e && CM.has(cps[j])) j++;\r\n  \t\tlet cms = cps.slice(i, j);\r\n  \t\tlet match = seqs.find(seq => !compare_arrays(seq, cms));\r\n  \t\tif (!match) throw new Error(`disallowed combining mark sequence: \"${safe_str_from_cps([cp, ...cms])}\"`);\r\n  \t\ti = j;\r\n  \t} else if (!V.has(cp)) {\r\n  \t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n  \t\tlet quoted = quoted_cp(cp);\r\n  \t\tfor (let cp of cps) {\r\n  \t\t\tlet u = UNIQUE.get(cp);\r\n  \t\t\tif (u && u !== g) {\r\n  \t\t\t\t// if both scripts are restricted this error is confusing\r\n  \t\t\t\t// because we don't differentiate RestrictedA from RestrictedB \r\n  \t\t\t\tif (!u.R) quoted = `${quoted} is ${u.N}`;\r\n  \t\t\t\tbreak;\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\tthrow new Error(`disallowed ${g.N} character: ${quoted}`);\r\n  \t\t//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);\r\n  \t\t//throw new Error(`${g.N} does not allow: ${quoted}`);\r\n  \t}\r\n  }\r\n  if (!cm_whitelist) {\r\n  \tlet decomposed = nfd(cps);\r\n  \tfor (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading\r\n  \t\tif (CM.has(decomposed[i])) {\r\n  \t\t\tlet j = i + 1;\r\n  \t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n  \t\t\tif (j - i > M) {\r\n  \t\t\t\tthrow new Error(`too many combining marks: \"${str_from_cps(decomposed.slice(i-1, j))}\" (${j-i}/${M})`);\r\n  \t\t\t}\r\n  \t\t\ti = j;\r\n  \t\t}\r\n  \t}\r\n  }\r\n  */\n}\n\n// given a list of codepoints\n// returns a list of lists, where emoji are a fully-qualified (as Array subclass)\n// eg. explode_cp(\"abc💩d\") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]\nfunction process(input, nf) {\n  var ret = [];\n  var chars = [];\n  input = input.slice().reverse(); // flip so we can pop\n  while (input.length) {\n    var emoji = consume_emoji_reversed(input);\n    if (emoji) {\n      if (chars.length) {\n        ret.push(nf(chars));\n        chars = [];\n      }\n      ret.push(emoji);\n    } else {\n      var cp = input.pop();\n      if (VALID.has(cp)) {\n        chars.push(cp);\n      } else {\n        var cps = MAPPED.get(cp);\n        if (cps) {\n          var _chars;\n          (_chars = chars).push.apply(_chars, _toConsumableArray(cps));\n        } else if (!IGNORED.has(cp)) {\n          throw error_disallowed(cp);\n        }\n      }\n    }\n  }\n  if (chars.length) {\n    ret.push(nf(chars));\n  }\n  return ret;\n}\nfunction filter_fe0f(cps) {\n  return cps.filter(function (cp) {\n    return cp != FE0F;\n  });\n}\n\n// given array of codepoints\n// returns the longest valid emoji sequence (or undefined if no match)\n// *MUTATES* the supplied array\n// allows optional FE0F\n// disallows interleaved ignored characters\n// fills (optional) eaten array with matched codepoints\nfunction consume_emoji_reversed(cps, eaten) {\n  var node = EMOJI_ROOT;\n  var emoji;\n  var saved;\n  var stack = [];\n  var pos = cps.length;\n  if (eaten) eaten.length = 0; // clear input buffer (if needed)\n  var _loop4 = function _loop4() {\n    var cp = cps[--pos];\n    node = node.B.find(function (x) {\n      return x.Q.has(cp);\n    });\n    if (!node) return \"break\";\n    if (node.S) {\n      // remember\n      saved = cp;\n    } else if (node.C) {\n      // check exclusion\n      if (cp === saved) return \"break\";\n    }\n    stack.push(cp);\n    if (node.F) {\n      stack.push(FE0F);\n      if (pos > 0 && cps[pos - 1] == FE0F) pos--; // consume optional FE0F\n    }\n\n    if (node.V) {\n      // this is a valid emoji (so far)\n      emoji = conform_emoji_copy(stack, node);\n      if (eaten) eaten.push.apply(eaten, _toConsumableArray(cps.slice(pos).reverse())); // copy input (if needed)\n      cps.length = pos; // truncate\n    }\n  };\n  while (pos) {\n    var _ret3 = _loop4();\n    if (_ret3 === \"break\") break;\n  }\n  /*\r\n  // *** this code currently isn't needed ***\r\n  if (!emoji) {\r\n  \tlet cp = cps[cps.length-1];\r\n  \tif (EMOJI_SOLO.has(cp)) {\r\n  \t\tif (eaten) eaten.push(cp);\r\n  \t\temoji = Emoji.of(cp);\r\n  \t\tcps.pop();\r\n  \t}\r\n  }\r\n  */\n  return emoji;\n}\n\n// create a copy and fix any unicode quirks\nfunction conform_emoji_copy(cps, node) {\n  var copy = Emoji.from(cps); // copy stack\n  if (node.V == 2) copy.splice(1, 1); // delete FE0F at position 1 (see: make.js)\n  return copy;\n}\n\n// return all supported emoji as fully-qualified emoji \n// ordered by length then lexicographic \nfunction ens_emoji() {\n  // *** this code currently isn't needed ***\n  //let ret = [...EMOJI_SOLO].map(x => [x]);\n  var ret = [];\n  build(EMOJI_ROOT, []);\n  return ret.sort(compare_arrays);\n  function build(node, cps, saved) {\n    if (node.S) {\n      saved = cps[cps.length - 1];\n    } else if (node.C) {\n      if (saved === cps[cps.length - 1]) return;\n    }\n    if (node.F) cps.push(FE0F);\n    if (node.V) ret.push(conform_emoji_copy(cps, node));\n    var _iterator12 = _createForOfIteratorHelper(node.B),\n      _step12;\n    try {\n      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n        var br = _step12.value;\n        var _iterator13 = _createForOfIteratorHelper(br.Q),\n          _step13;\n        try {\n          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n            var cp = _step13.value;\n            build(br, [].concat(_toConsumableArray(cps), [cp]), saved);\n          }\n        } catch (err) {\n          _iterator13.e(err);\n        } finally {\n          _iterator13.f();\n        }\n      }\n    } catch (err) {\n      _iterator12.e(err);\n    } finally {\n      _iterator12.f();\n    }\n  }\n}\n\n// ************************************************************\n// tokenizer \n\nvar TY_VALID = 'valid';\nvar TY_MAPPED = 'mapped';\nvar TY_IGNORED = 'ignored';\nvar TY_DISALLOWED = 'disallowed';\nvar TY_EMOJI = 'emoji';\nvar TY_NFC = 'nfc';\nvar TY_STOP = 'stop';\nfunction ens_tokenize(name) {\n  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref2$nf = _ref2.nf,\n    nf = _ref2$nf === void 0 ? true : _ref2$nf;\n  var input = explode_cp(name).reverse();\n  var eaten = [];\n  var tokens = [];\n  while (input.length) {\n    var emoji = consume_emoji_reversed(input, eaten);\n    if (emoji) {\n      tokens.push({\n        type: TY_EMOJI,\n        emoji: emoji,\n        input: eaten.slice(),\n        cps: filter_fe0f(emoji)\n      });\n    } else {\n      var cp = input.pop();\n      if (cp == STOP) {\n        tokens.push({\n          type: TY_STOP,\n          cp: cp\n        });\n      } else if (VALID.has(cp)) {\n        tokens.push({\n          type: TY_VALID,\n          cps: [cp]\n        });\n      } else if (IGNORED.has(cp)) {\n        tokens.push({\n          type: TY_IGNORED,\n          cp: cp\n        });\n      } else {\n        var cps = MAPPED.get(cp);\n        if (cps) {\n          tokens.push({\n            type: TY_MAPPED,\n            cp: cp,\n            cps: cps.slice()\n          });\n        } else {\n          tokens.push({\n            type: TY_DISALLOWED,\n            cp: cp\n          });\n        }\n      }\n    }\n  }\n  if (nf) {\n    for (var i = 0, start = -1; i < tokens.length; i++) {\n      var token = tokens[i];\n      if (is_valid_or_mapped(token.type)) {\n        if (requires_check(token.cps)) {\n          // normalization might be needed\n          var end = i + 1;\n          for (var pos = end; pos < tokens.length; pos++) {\n            // find adjacent text\n            var _tokens$pos = tokens[pos],\n              type = _tokens$pos.type,\n              _cps = _tokens$pos.cps;\n            if (is_valid_or_mapped(type)) {\n              if (!requires_check(_cps)) break;\n              end = pos + 1;\n            } else if (type !== TY_IGNORED) {\n              // || type !== TY_DISALLOWED) { \n              break;\n            }\n          }\n          if (start < 0) start = i;\n          var slice = tokens.slice(start, end);\n          var cps0 = slice.flatMap(function (x) {\n            return is_valid_or_mapped(x.type) ? x.cps : [];\n          }); // strip junk tokens\n          var _cps2 = nfc(cps0);\n          if (compare_arrays(_cps2, cps0)) {\n            // bundle into an nfc token\n            tokens.splice(start, end - start, {\n              type: TY_NFC,\n              input: cps0,\n              // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps\n              cps: _cps2,\n              tokens0: collapse_valid_tokens(slice),\n              tokens: ens_tokenize(str_from_cps(_cps2), {\n                nf: false\n              })\n            });\n            i = start;\n          } else {\n            i = end - 1; // skip to end of slice\n          }\n\n          start = -1; // reset\n        } else {\n          start = i; // remember last\n        }\n      } else if (token.type !== TY_IGNORED) {\n        // 20221024: is this correct?\n        start = -1; // reset\n      }\n    }\n  }\n\n  return collapse_valid_tokens(tokens);\n}\nfunction is_valid_or_mapped(type) {\n  return type == TY_VALID || type == TY_MAPPED;\n}\nfunction requires_check(cps) {\n  return cps.some(function (cp) {\n    return NFC_CHECK.has(cp);\n  });\n}\nfunction collapse_valid_tokens(tokens) {\n  for (var i = 0; i < tokens.length; i++) {\n    if (tokens[i].type == TY_VALID) {\n      var j = i + 1;\n      while (j < tokens.length && tokens[j].type == TY_VALID) j++;\n      tokens.splice(i, j - i, {\n        type: TY_VALID,\n        cps: tokens.slice(i, j).flatMap(function (x) {\n          return x.cps;\n        })\n      });\n    }\n  }\n  return tokens;\n}\nexport { ens_beautify, ens_emoji, ens_normalize, ens_normalize_fragment, ens_split, ens_tokenize, is_combining_mark, nfc, nfd, safe_str_from_cps, should_escape };","map":{"version":3,"names":["decode_arithmetic","bytes","pos","u16","symbol_count","total","acc","i","push","skip","pos_payload","read_width","read_buffer","read_bit","N","FULL","Math","pow","HALF","QRTR","MASK","register","symbols","low","range","value","floor","start","end","mid","a","b","offset","map","x","read_payload","v","read_compressed_payload","s","unsafe_atob","lookup","_toConsumableArray","forEach","c","charCodeAt","n","length","ret","Uint8Array","width","carry","signed","read_deltas","next","Array","read_sorted","prev","arguments","undefined","read_sorted_arrays","read_array_while","read_mapped","w","read_linear_table","read_replacement_table","flat","read_transposed","m","fill","j","dx","dy","vN","flatMap","_v","_toArray","ys","slice","_","j_dy","y","r$1","FENCED","Map","NSM_MAX","hex_cp","cp","toString","toUpperCase","padStart","quote_cp","concat","explode_cp","cps","len","codePointAt","str_from_cps","chunk","String","fromCodePoint","apply","buf","join","compare_arrays","r","unpack_cc","packed","unpack_cp","SHIFTED_RANK","EXCLUSIONS","Set","DECOMP","RECOMP","_iterator","_createForOfIteratorHelper","_step","done","_step$value","_slicedToArray","has","_cps3","bucket","get","set","reverse","err","e","f","S0","L0","V0","T0","L_COUNT","V_COUNT","T_COUNT","N_COUNT","S_COUNT","S1","L1","V1","T1","is_hangul","compose_pair","recomp","decomposed","check_order","add","cc","_iterator2","_step2","s_index","l_index","v_index","t_index","mapped","pop","prev_cc","tmp","composed_from_decomposed","stack","prev_cp","_iterator3","_step3","composed","nfd","nfc","STOP","FE0F","STOP_CH","UNIQUE_PH","HYPHEN","read_set","MAPPED","IGNORED","CM","NSM","ESCAPE","NFC_CHECK","CHUNKS","read_chunked","UNRESTRICTED","GROUPS","R","P","Q","V","sort","M","WHOLE_VALID","WHOLE_MAP","d","_iterator4","values","_step4","_step4$value","recs","_iterator14","_step14","_loop6","gs","filter","g","rec","find","_ref4","G","some","union","_ref3","_loop5","_recs$_i","_recs","_i2","complement","_iterator15","_step15","multi","_iterator5","_step5","_iterator16","_step16","_iterator6","_step6","VALID","EMOJI_SORTED","EMOJI_ROOT","read_emoji_trie","B","keys","size","temp","F","S","C","Emoji","_Array","_inherits","_super","_createSuper","_classCallCheck","_createClass","key","_wrapNativeSuper","safe_str_from_cps","quoter","is_combining_mark","should_escape","quoted_cp","bidi_qq","check_label_extension","Error","check_leading_underscore","UNDERSCORE","lastIndexOf","check_fenced","error_placement","last","match","ens_normalize_fragment","frag","decompose","nf","split","label","process","is_emoji","filter_fe0f","ens_normalize","name","flatten","ens_split","ens_beautify","_iterator7","_step7","_step7$value","type","output","error","indexOf","preserve_emoji","input","info","norm","tokens","token_count","chars","emoji","every","unique","_determine_group","determine_group","_determine_group2","check_group","check_whole","group","maker","shared","_iterator8","_step8","_loop2","whole","_ret","_iterator9","_step9","_loop","groups","_iterator10","_step10","_loop3","error_disallowed","error_group_member","_ret2","_ref","msg","message","quoted","gg","where","_iterator11","_step11","k","consume_emoji_reversed","_chars","eaten","node","saved","_loop4","conform_emoji_copy","_ret3","copy","from","splice","ens_emoji","build","_iterator12","_step12","br","_iterator13","_step13","TY_VALID","TY_MAPPED","TY_IGNORED","TY_DISALLOWED","TY_EMOJI","TY_NFC","TY_STOP","ens_tokenize","_ref2","_ref2$nf","token","is_valid_or_mapped","requires_check","_tokens$pos","cps0","tokens0","collapse_valid_tokens"],"sources":["C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@adraffy/ens-normalize/dist/index.js"],"sourcesContent":["function decode_arithmetic(bytes) {\r\n\tlet pos = 0;\r\n\tfunction u16() { return (bytes[pos++] << 8) | bytes[pos++]; }\r\n\t\r\n\t// decode the frequency table\r\n\tlet symbol_count = u16();\r\n\tlet total = 1;\r\n\tlet acc = [0, 1]; // first symbol has frequency 1\r\n\tfor (let i = 1; i < symbol_count; i++) {\r\n\t\tacc.push(total += u16());\r\n\t}\r\n\r\n\t// skip the sized-payload that the last 3 symbols index into\r\n\tlet skip = u16();\r\n\tlet pos_payload = pos;\r\n\tpos += skip;\r\n\r\n\tlet read_width = 0;\r\n\tlet read_buffer = 0; \r\n\tfunction read_bit() {\r\n\t\tif (read_width == 0) {\r\n\t\t\t// this will read beyond end of buffer\r\n\t\t\t// but (undefined|0) => zero pad\r\n\t\t\tread_buffer = (read_buffer << 8) | bytes[pos++];\r\n\t\t\tread_width = 8;\r\n\t\t}\r\n\t\treturn (read_buffer >> --read_width) & 1;\r\n\t}\r\n\r\n\tconst N = 31;\r\n\tconst FULL = 2**N;\r\n\tconst HALF = FULL >>> 1;\r\n\tconst QRTR = HALF >> 1;\r\n\tconst MASK = FULL - 1;\r\n\r\n\t// fill register\r\n\tlet register = 0;\r\n\tfor (let i = 0; i < N; i++) register = (register << 1) | read_bit();\r\n\r\n\tlet symbols = [];\r\n\tlet low = 0;\r\n\tlet range = FULL; // treat like a float\r\n\twhile (true) {\r\n\t\tlet value = Math.floor((((register - low + 1) * total) - 1) / range);\r\n\t\tlet start = 0;\r\n\t\tlet end = symbol_count;\r\n\t\twhile (end - start > 1) { // binary search\r\n\t\t\tlet mid = (start + end) >>> 1;\r\n\t\t\tif (value < acc[mid]) {\r\n\t\t\t\tend = mid;\r\n\t\t\t} else {\r\n\t\t\t\tstart = mid;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (start == 0) break; // first symbol is end mark\r\n\t\tsymbols.push(start);\r\n\t\tlet a = low + Math.floor(range * acc[start]   / total);\r\n\t\tlet b = low + Math.floor(range * acc[start+1] / total) - 1;\r\n\t\twhile (((a ^ b) & HALF) == 0) {\r\n\t\t\tregister = (register << 1) & MASK | read_bit();\r\n\t\t\ta = (a << 1) & MASK;\r\n\t\t\tb = (b << 1) & MASK | 1;\r\n\t\t}\r\n\t\twhile (a & ~b & QRTR) {\r\n\t\t\tregister = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();\r\n\t\t\ta = (a << 1) ^ HALF;\r\n\t\t\tb = ((b ^ HALF) << 1) | HALF | 1;\r\n\t\t}\r\n\t\tlow = a;\r\n\t\trange = 1 + b - a;\r\n\t}\r\n\tlet offset = symbol_count - 4;\r\n\treturn symbols.map(x => { // index into payload\r\n\t\tswitch (x - offset) {\r\n\t\t\tcase 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);\r\n\t\t\tcase 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);\r\n\t\t\tcase 1: return offset + bytes[pos_payload++];\r\n\t\t\tdefault: return x - 1;\r\n\t\t}\r\n\t});\r\n}\t\r\n\r\n// returns an iterator which returns the next symbol\r\nfunction read_payload(v) {\r\n\tlet pos = 0;\r\n\treturn () => v[pos++];\r\n}\r\nfunction read_compressed_payload(s) {\r\n\treturn read_payload(decode_arithmetic(unsafe_atob(s)));\r\n}\r\n\r\n// unsafe in the sense:\r\n// expected well-formed Base64 w/o padding \r\nfunction unsafe_atob(s) {\r\n\tlet lookup = [];\r\n\t[...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'].forEach((c, i) => lookup[c.charCodeAt(0)] = i);\r\n\tlet n = s.length;\r\n\tlet ret = new Uint8Array((6 * n) >> 3);\r\n\tfor (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {\r\n\t\tcarry = (carry << 6) | lookup[s.charCodeAt(i)];\r\n\t\twidth += 6;\r\n\t\tif (width >= 8) {\r\n\t\t\tret[pos++] = (carry >> (width -= 8));\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\r\nfunction signed(i) { \r\n\treturn (i & 1) ? (~i >> 1) : (i >> 1);\r\n}\r\n\r\nfunction read_deltas(n, next) {\r\n\tlet v = Array(n);\r\n\tfor (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());\r\n\treturn v;\r\n}\r\n\r\n// [123][5] => [0 3] [1 1] [0 0]\r\nfunction read_sorted(next, prev = 0) {\r\n\tlet ret = [];\r\n\twhile (true) {\r\n\t\tlet x = next();\r\n\t\tlet n = next();\r\n\t\tif (!n) break;\r\n\t\tprev += x;\r\n\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\tret.push(prev + i);\r\n\t\t}\r\n\t\tprev += n + 1;\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction read_sorted_arrays(next) {\r\n\treturn read_array_while(() => { \r\n\t\tlet v = read_sorted(next);\r\n\t\tif (v.length) return v;\r\n\t});\r\n}\r\n\r\n// returns map of x => ys\r\nfunction read_mapped(next) {\r\n\tlet ret = [];\r\n\twhile (true) {\r\n\t\tlet w = next();\r\n\t\tif (w == 0) break;\r\n\t\tret.push(read_linear_table(w, next));\r\n\t}\r\n\twhile (true) {\r\n\t\tlet w = next() - 1;\r\n\t\tif (w < 0) break;\r\n\t\tret.push(read_replacement_table(w, next));\r\n\t}\r\n\treturn ret.flat();\r\n}\r\n\r\n// read until next is falsy\r\n// return array of read values\r\nfunction read_array_while(next) {\r\n\tlet v = [];\r\n\twhile (true) {\r\n\t\tlet x = next(v.length);\r\n\t\tif (!x) break;\r\n\t\tv.push(x);\r\n\t}\r\n\treturn v;\r\n}\r\n\r\n// read w columns of length n\r\n// return as n rows of length w\r\nfunction read_transposed(n, w, next) {\r\n\tlet m = Array(n).fill().map(() => []);\r\n\tfor (let i = 0; i < w; i++) {\r\n\t\tread_deltas(n, next).forEach((x, j) => m[j].push(x));\r\n\t}\r\n\treturn m;\r\n}\r\n \r\n// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]\r\n// where dx/dy = steps, n = run size, w = length of y\r\nfunction read_linear_table(w, next) {\r\n\tlet dx = 1 + next();\r\n\tlet dy = next();\r\n\tlet vN = read_array_while(next);\r\n\tlet m = read_transposed(vN.length, 1+w, next);\r\n\treturn m.flatMap((v, i) => {\r\n\t\tlet [x, ...ys] = v;\r\n\t\treturn Array(vN[i]).fill().map((_, j) => {\r\n\t\t\tlet j_dy = j * dy;\r\n\t\t\treturn [x + j * dx, ys.map(y => y + j_dy)];\r\n\t\t});\r\n\t});\r\n}\r\n\r\n// return [[x, ys...], ...]\r\n// where w = length of y\r\nfunction read_replacement_table(w, next) { \r\n\tlet n = 1 + next();\r\n\tlet m = read_transposed(n, 1+w, next);\r\n\treturn m.map(v => [v[0], v.slice(1)]);\r\n}\n\n// created 2023-02-21T09:18:13.549Z\nvar r$1 = read_compressed_payload('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');\nconst FENCED = new Map([[8217,\"apostrophe\"],[8260,\"fraction slash\"],[12539,\"middle dot\"]]);\nconst NSM_MAX = 4;\n\nfunction hex_cp(cp) {\r\n\treturn cp.toString(16).toUpperCase().padStart(2, '0');\r\n}\r\n\r\nfunction quote_cp(cp) {\r\n\treturn `{${hex_cp(cp)}}`; // raffy convention: like \"\\u{X}\" w/o the \"\\u\"\r\n}\r\n\r\n/*\r\nexport function explode_cp(s) {\r\n\treturn [...s].map(c => c.codePointAt(0));\r\n}\r\n*/\r\nfunction explode_cp(s) { // this is about 2x faster\r\n\tlet cps = [];\r\n\tfor (let pos = 0, len = s.length; pos < len; ) {\r\n\t\tlet cp = s.codePointAt(pos);\r\n\t\tpos += cp < 0x10000 ? 1 : 2;\r\n\t\tcps.push(cp);\r\n\t}\r\n\treturn cps;\r\n}\r\n\r\nfunction str_from_cps(cps) {\r\n\tconst chunk = 4096;\r\n\tlet len = cps.length;\r\n\tif (len < chunk) return String.fromCodePoint(...cps);\r\n\tlet buf = [];\r\n\tfor (let i = 0; i < len; ) {\r\n\t\tbuf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));\r\n\t}\r\n\treturn buf.join('');\r\n}\r\n\r\nfunction compare_arrays(a, b) {\r\n\tlet n = a.length;\r\n\tlet c = n - b.length;\r\n\tfor (let i = 0; c == 0 && i < n; i++) c = a[i] - b[i];\r\n\treturn c;\r\n}\n\n// created 2023-02-21T09:18:13.549Z\nvar r = read_compressed_payload('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');\n\n// https://unicode.org/reports/tr15/\r\n\r\nfunction unpack_cc(packed) {\r\n\treturn (packed >> 24) & 0xFF;\r\n}\r\nfunction unpack_cp(packed) {\r\n\treturn packed & 0xFFFFFF;\r\n}\r\n\r\nconst SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map(x => [x, (i+1) << 24]))); // pre-shifted\r\nconst EXCLUSIONS = new Set(read_sorted(r));\r\nconst DECOMP = new Map();\r\nconst RECOMP = new Map();\r\nfor (let [cp, cps] of read_mapped(r)) {\r\n\tif (!EXCLUSIONS.has(cp) && cps.length == 2) {\r\n\t\tlet [a, b] = cps;\r\n\t\tlet bucket = RECOMP.get(a);\r\n\t\tif (!bucket) {\r\n\t\t\tbucket = new Map();\r\n\t\t\tRECOMP.set(a, bucket);\r\n\t\t}\r\n\t\tbucket.set(b, cp);\r\n\t}\r\n\tDECOMP.set(cp, cps.reverse()); // stored reversed\r\n}\r\n\r\n// algorithmic hangul\r\n// https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)\r\nconst S0 = 0xAC00;\r\nconst L0 = 0x1100;\r\nconst V0 = 0x1161;\r\nconst T0 = 0x11A7;\r\nconst L_COUNT = 19;\r\nconst V_COUNT = 21;\r\nconst T_COUNT = 28;\r\nconst N_COUNT = V_COUNT * T_COUNT;\r\nconst S_COUNT = L_COUNT * N_COUNT;\r\nconst S1 = S0 + S_COUNT;\r\nconst L1 = L0 + L_COUNT;\r\nconst V1 = V0 + V_COUNT;\r\nconst T1 = T0 + T_COUNT;\r\n\r\nfunction is_hangul(cp) {\r\n\treturn cp >= S0 && cp < S1;\r\n}\r\n\r\nfunction compose_pair(a, b) {\r\n\tif (a >= L0 && a < L1 && b >= V0 && b < V1) {\r\n\t\treturn S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;\r\n\t} else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {\r\n\t\treturn a + (b - T0);\r\n\t} else {\r\n\t\tlet recomp = RECOMP.get(a);\r\n\t\tif (recomp) {\r\n\t\t\trecomp = recomp.get(b);\r\n\t\t\tif (recomp) {\r\n\t\t\t\treturn recomp;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n}\r\n\r\nfunction decomposed(cps) {\r\n\tlet ret = [];\r\n\tlet buf = [];\r\n\tlet check_order = false;\r\n\tfunction add(cp) {\r\n\t\tlet cc = SHIFTED_RANK.get(cp);\r\n\t\tif (cc) {\r\n\t\t\tcheck_order = true;\r\n\t\t\tcp |= cc;\r\n\t\t}\r\n\t\tret.push(cp);\r\n\t}\r\n\tfor (let cp of cps) {\r\n\t\twhile (true) {\r\n\t\t\tif (cp < 0x80) {\r\n\t\t\t\tret.push(cp);\r\n\t\t\t} else if (is_hangul(cp)) {\r\n\t\t\t\tlet s_index = cp - S0;\r\n\t\t\t\tlet l_index = s_index / N_COUNT | 0;\r\n\t\t\t\tlet v_index = (s_index % N_COUNT) / T_COUNT | 0;\r\n\t\t\t\tlet t_index = s_index % T_COUNT;\r\n\t\t\t\tadd(L0 + l_index);\r\n\t\t\t\tadd(V0 + v_index);\r\n\t\t\t\tif (t_index > 0) add(T0 + t_index);\r\n\t\t\t} else {\r\n\t\t\t\tlet mapped = DECOMP.get(cp);\r\n\t\t\t\tif (mapped) {\r\n\t\t\t\t\tbuf.push(...mapped);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tadd(cp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!buf.length) break;\r\n\t\t\tcp = buf.pop();\r\n\t\t}\r\n\t}\r\n\tif (check_order && ret.length > 1) {\r\n\t\tlet prev_cc = unpack_cc(ret[0]);\r\n\t\tfor (let i = 1; i < ret.length; i++) {\r\n\t\t\tlet cc = unpack_cc(ret[i]);\r\n\t\t\tif (cc == 0 || prev_cc <= cc) {\r\n\t\t\t\tprev_cc = cc;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tlet j = i-1;\r\n\t\t\twhile (true) {\r\n\t\t\t\tlet tmp = ret[j+1];\r\n\t\t\t\tret[j+1] = ret[j];\r\n\t\t\t\tret[j] = tmp;\r\n\t\t\t\tif (!j) break;\r\n\t\t\t\tprev_cc = unpack_cc(ret[--j]);\r\n\t\t\t\tif (prev_cc <= cc) break;\r\n\t\t\t}\r\n\t\t\tprev_cc = unpack_cc(ret[i]);\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction composed_from_decomposed(v) {\r\n\tlet ret = [];\r\n\tlet stack = [];\r\n\tlet prev_cp = -1;\r\n\tlet prev_cc = 0;\r\n\tfor (let packed of v) {\r\n\t\tlet cc = unpack_cc(packed);\r\n\t\tlet cp = unpack_cp(packed);\r\n\t\tif (prev_cp == -1) {\r\n\t\t\tif (cc == 0) {\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tret.push(cp);\r\n\t\t\t}\r\n\t\t} else if (prev_cc > 0 && prev_cc >= cc) {\r\n\t\t\tif (cc == 0) {\r\n\t\t\t\tret.push(prev_cp, ...stack);\r\n\t\t\t\tstack.length = 0;\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(cp);\r\n\t\t\t}\r\n\t\t\tprev_cc = cc;\r\n\t\t} else {\r\n\t\t\tlet composed = compose_pair(prev_cp, cp);\r\n\t\t\tif (composed >= 0) {\r\n\t\t\t\tprev_cp = composed;\r\n\t\t\t} else if (prev_cc == 0 && cc == 0) {\r\n\t\t\t\tret.push(prev_cp);\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(cp);\r\n\t\t\t\tprev_cc = cc;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (prev_cp >= 0) {\r\n\t\tret.push(prev_cp, ...stack);\t\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n// note: cps can be iterable\r\nfunction nfd(cps) {\r\n\treturn decomposed(cps).map(unpack_cp);\r\n}\r\nfunction nfc(cps) {\r\n\treturn composed_from_decomposed(decomposed(cps));\r\n}\n\n//const t0 = performance.now();\r\n\r\nconst STOP = 0x2E;\r\nconst FE0F = 0xFE0F;\r\nconst STOP_CH = '.';\r\nconst UNIQUE_PH = 1;\r\nconst HYPHEN = 0x2D;\r\n\r\nfunction read_set() {\r\n\treturn new Set(read_sorted(r$1));\r\n}\r\nconst MAPPED = new Map(read_mapped(r$1)); \r\nconst IGNORED = read_set(); // ignored characters are not valid, so just read raw codepoints\r\n/*\r\n// direct include from payload is smaller that the decompression code\r\nconst FENCED = new Map(read_array_while(() => {\r\n\tlet cp = r();\r\n\tif (cp) return [cp, read_str(r())];\r\n}));\r\n*/\r\n// 20230217: we still need all CM for proper error formatting\r\n// but norm only needs NSM subset that are potentially-valid\r\nconst CM = read_set();\r\nconst NSM = new Set(read_sorted(r$1).map(function(i) { return this[i]; }, [...CM]));\r\n/*\r\nconst CM_SORTED = read_sorted(r);\r\nconst NSM = new Set(read_sorted(r).map(i => CM_SORTED[i]));\r\nconst CM = new Set(CM_SORTED);\r\n*/\r\nconst ESCAPE = read_set(); // characters that should not be printed\r\nconst NFC_CHECK = read_set();\r\nconst CHUNKS = read_sorted_arrays(r$1);\r\nfunction read_chunked() {\r\n\t// deduplicated sets + uniques\r\n\treturn new Set([read_sorted(r$1).map(i => CHUNKS[i]), read_sorted(r$1)].flat(2));\r\n}\r\nconst UNRESTRICTED = r$1();\r\nconst GROUPS = read_array_while(i => {\r\n\t// minifier property mangling seems unsafe\r\n\t// so these are manually renamed to single chars\r\n\tlet N = read_array_while(r$1).map(x => x+0x60);\r\n\tif (N.length) {\r\n\t\tlet R = i >= UNRESTRICTED; // first arent restricted\r\n\t\tN[0] -= 32; // capitalize\r\n\t\tN = str_from_cps(N);\r\n\t\tif (R) N=`Restricted[${N}]`;\r\n\t\tlet P = read_chunked(); // primary\r\n\t\tlet Q = read_chunked(); // secondary\r\n\t\tlet V = [...P, ...Q].sort((a, b) => a-b); // derive: sorted valid\r\n\t\t//let M = r()-1; // combining mark\r\n\t\tlet M = !r$1(); // not-whitelisted, check for NSM\r\n\t\t// code currently isn't needed\r\n\t\t/*if (M < 0) { // whitelisted\r\n\t\t\tM = new Map(read_array_while(() => {\r\n\t\t\t\tlet i = r();\r\n\t\t\t\tif (i) return [V[i-1], read_array_while(() => {\r\n\t\t\t\t\tlet v = read_array_while(r);\r\n\t\t\t\t\tif (v.length) return v.map(x => x-1);\r\n\t\t\t\t})];\r\n\t\t\t}));\r\n\t\t}*/\r\n\t\treturn {N, P, M, R, V: new Set(V)};\r\n\t}\r\n});\r\nconst WHOLE_VALID = read_set();\r\nconst WHOLE_MAP = new Map();\r\n// decode compressed wholes\r\n[...WHOLE_VALID, ...read_set()].sort((a, b) => a-b).map((cp, i, v) => {\r\n\tlet d = r$1(); \r\n\tlet w = v[i] = d ? v[i-d] : {V: [], M: new Map()};\r\n\tw.V.push(cp); // add to member set\r\n\tif (!WHOLE_VALID.has(cp)) {\r\n\t\tWHOLE_MAP.set(cp, w);  // register with whole map\r\n\t}\r\n});\r\n// compute confusable-extent complements\r\nfor (let {V, M} of new Set(WHOLE_MAP.values())) {\r\n\t// connect all groups that have each whole character\r\n\tlet recs = [];\r\n\tfor (let cp of V) {\r\n\t\tlet gs = GROUPS.filter(g => g.V.has(cp));\r\n\t\tlet rec = recs.find(({G}) => gs.some(g => G.has(g)));\r\n\t\tif (!rec) {\r\n\t\t\trec = {G: new Set(), V: []};\r\n\t\t\trecs.push(rec);\r\n\t\t}\r\n\t\trec.V.push(cp);\r\n\t\tgs.forEach(g => rec.G.add(g));\r\n\t}\r\n\t// per character cache groups which are not a member of the extent\r\n\tlet union = recs.flatMap(({G}) => [...G]);\r\n\tfor (let {G, V} of recs) {\r\n\t\tlet complement = new Set(union.filter(g => !G.has(g)));\r\n\t\tfor (let cp of V) {\r\n\t\t\tM.set(cp, complement);\r\n\t\t}\r\n\t}\r\n}\r\nlet union = new Set(); // exists in 1+ groups\r\nlet multi = new Set(); // exists in 2+ groups\r\nfor (let g of GROUPS) {\r\n\tfor (let cp of g.V) {\r\n\t\t(union.has(cp) ? multi : union).add(cp);\r\n\t}\r\n}\r\n// dual purpose WHOLE_MAP: return placeholder if unique non-confusable\r\nfor (let cp of union) {\r\n\tif (!WHOLE_MAP.has(cp) && !multi.has(cp)) {\r\n\t\tWHOLE_MAP.set(cp, UNIQUE_PH);\r\n\t}\r\n}\r\nconst VALID = new Set([...union, ...nfd(union)]); // possibly valid\r\n\r\n// decode emoji\r\nconst EMOJI_SORTED = read_sorted(r$1); // temporary\r\n//const EMOJI_SOLO = new Set(read_sorted(r).map(i => EMOJI_SORTED[i])); // not needed\r\nconst EMOJI_ROOT = read_emoji_trie([]);\r\nfunction read_emoji_trie(cps) {\r\n\tlet B = read_array_while(() => {\r\n\t\tlet keys = read_sorted(r$1).map(i => EMOJI_SORTED[i]);\r\n\t\tif (keys.length) return read_emoji_trie(keys);\r\n\t}).sort((a, b) => b.Q.size - a.Q.size); // sort by likelihood\r\n\tlet temp = r$1();\r\n\tlet V = temp % 3; // valid (0 = false, 1 = true, 2 = weird)\r\n\ttemp = (temp / 3)|0;\r\n\tlet F = temp & 1; // allow FE0F\r\n\ttemp >>= 1;\r\n\tlet S = temp & 1; // save\r\n\tlet C = temp & 2; // check\r\n\treturn {B, V, F, S, C, Q: new Set(cps)};\r\n}\r\n//console.log(performance.now() - t0);\r\n\r\n// free tagging system\r\nclass Emoji extends Array {\r\n\tget is_emoji() { return true; }\r\n}\r\n\r\n// create a safe to print string \r\n// invisibles are escaped\r\n// leading cm uses placeholder\r\n// quoter(cp) => string, eg. 3000 => \"{3000}\"\r\n// note: in html, you'd call this function then replace [<>&] with entities\r\nfunction safe_str_from_cps(cps, quoter = quote_cp) {\r\n\t//if (Number.isInteger(cps)) cps = [cps];\r\n\t//if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);\r\n\tlet buf = [];\r\n\tif (is_combining_mark(cps[0])) buf.push('◌');\r\n\tlet prev = 0;\r\n\tlet n = cps.length;\r\n\tfor (let i = 0; i < n; i++) {\r\n\t\tlet cp = cps[i];\r\n\t\tif (should_escape(cp)) {\r\n\t\t\tbuf.push(str_from_cps(cps.slice(prev, i)));\r\n\t\t\tbuf.push(quoter(cp));\r\n\t\t\tprev = i + 1;\r\n\t\t}\r\n\t}\r\n\tbuf.push(str_from_cps(cps.slice(prev, n)));\r\n\treturn buf.join('');\r\n}\r\n\r\n// if escaped: {HEX}\r\n//       else: \"x\" {HEX}\r\nfunction quoted_cp(cp) {\r\n\treturn (should_escape(cp) ? '' : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);\r\n}\r\n\r\n// 20230211: some messages can be mixed-directional and result in spillover\r\n// use 200E after a quoted string to force the remainder of a string from \r\n// acquring the direction of the quote\r\n// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions\r\nfunction bidi_qq(s) {\r\n\treturn `\"${s}\"\\u200E`; // strong LTR\r\n}\r\n\r\nfunction check_label_extension(cps) {\r\n\tif (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\r\n\t\tthrow new Error('invalid label extension');\r\n\t}\r\n}\r\nfunction check_leading_underscore(cps) {\r\n\tconst UNDERSCORE = 0x5F;\r\n\tfor (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {\r\n\t\tif (cps[--i] !== UNDERSCORE) {\r\n\t\t\tthrow new Error('underscore allowed only at start');\r\n\t\t}\r\n\t}\r\n}\r\n// check that a fenced cp is not leading, trailing, or touching another fenced cp\r\nfunction check_fenced(cps) {\r\n\tlet cp = cps[0];\r\n\tlet prev = FENCED.get(cp);\r\n\tif (prev) throw error_placement(`leading ${prev}`);\r\n\tlet n = cps.length;\r\n\tlet last = -1; // prevents trailing from throwing\r\n\tfor (let i = 1; i < n; i++) {\r\n\t\tcp = cps[i];\r\n\t\tlet match = FENCED.get(cp);\r\n\t\tif (match) {\r\n\t\t\t// since cps[0] isn't fenced, cps[1] cannot throw\r\n\t\t\tif (last == i) throw error_placement(`${prev} + ${match}`);\r\n\t\t\tlast = i + 1;\r\n\t\t\tprev = match;\r\n\t\t}\r\n\t}\r\n\tif (last == n) throw error_placement(`trailing ${prev}`);\r\n}\r\n\r\n// note: set(s) cannot be exposed because they can be modified\r\nfunction is_combining_mark(cp) {\r\n\treturn CM.has(cp);\r\n}\r\nfunction should_escape(cp) {\r\n\treturn ESCAPE.has(cp);\r\n}\r\n\r\nfunction ens_normalize_fragment(frag, decompose) {\r\n\tlet nf = decompose ? nfd : nfc;\r\n\treturn frag.split(STOP_CH).map(label => str_from_cps(process(explode_cp(label), nf).flatMap(x => x.is_emoji ? filter_fe0f(x) : x))).join(STOP_CH);\r\n}\r\n\r\nfunction ens_normalize(name) {\r\n\treturn flatten(ens_split(name));\r\n}\r\n\r\nfunction ens_beautify(name) {\r\n\tlet split = ens_split(name, true);\r\n\t// this is experimental\r\n\tfor (let {type, output, error} of split) {\r\n\t\tif (error) continue;\r\n\r\n\t\t// replace leading/trailing hyphen\r\n\t\t// 20230121: consider beautifing all or leading/trailing hyphen to unicode variant\r\n\t\t// not exactly the same in every font, but very similar: \"-\" vs \"‐\"\r\n\t\t/*\r\n\t\tconst UNICODE_HYPHEN = 0x2010;\r\n\t\t// maybe this should replace all for visual consistancy?\r\n\t\t// `node tools/reg-count.js regex ^-\\{2,\\}` => 592\r\n\t\t//for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;\r\n\t\tif (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;\r\n\t\tlet end = output.length-1;\r\n\t\tif (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;\r\n\t\t*/\r\n\t\t// 20230123: WHATWG URL uses \"CheckHyphens\" false\r\n\t\t// https://url.spec.whatwg.org/#idna\r\n\r\n\t\t// update ethereum symbol\r\n\t\t// ξ => Ξ if not greek\r\n\t\tif (type !== 'Greek') { \r\n\t\t\tlet prev = 0;\r\n\t\t\twhile (true) {\r\n\t\t\t\tlet next = output.indexOf(0x3BE, prev);\r\n\t\t\t\tif (next < 0) break;\r\n\t\t\t\toutput[next] = 0x39E; \r\n\t\t\t\tprev = next + 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)\r\n\t\t// could be fixed with special case for: 2D (.) + 200E (LTR)\r\n\t\t//output.splice(0, 0, 0x200E);\r\n\t}\r\n\treturn flatten(split);\r\n}\r\n\r\nfunction ens_split(name, preserve_emoji) {\r\n\tlet offset = 0;\r\n\t// https://unicode.org/reports/tr46/#Validity_Criteria\r\n\t// 4.) \"The label must not contain a U+002E ( . ) FULL STOP.\"\r\n\treturn name.split(STOP_CH).map(label => {\r\n\t\tlet input = explode_cp(label);\r\n\t\tlet info = {\r\n\t\t\tinput,\r\n\t\t\toffset, // codepoint, not substring!\r\n\t\t};\r\n\t\toffset += input.length + 1; // + stop\r\n\t\tlet norm;\r\n\t\ttry {\r\n\t\t\t// 1.) \"The label must be in Unicode Normalization Form NFC\"\r\n\t\t\tlet tokens = info.tokens = process(input, nfc); // if we parse, we get [norm and mapped]\r\n\t\t\tlet token_count = tokens.length;\r\n\t\t\tlet type;\r\n\t\t\tif (!token_count) { // the label was effectively empty (could of had ignored characters)\r\n\t\t\t\t// 20230120: change to strict\r\n\t\t\t\t// https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59\r\n\t\t\t\t//norm = [];\r\n\t\t\t\t//type = 'None'; // use this instead of next match, \"ASCII\"\r\n\t\t\t\tthrow new Error(`empty label`);\r\n\t\t\t} else {\r\n\t\t\t\tlet chars = tokens[0];\r\n\t\t\t\tlet emoji = token_count > 1 || chars.is_emoji;\r\n\t\t\t\tif (!emoji && chars.every(cp => cp < 0x80)) { // special case for ascii\r\n\t\t\t\t\tnorm = chars;\r\n\t\t\t\t\tcheck_leading_underscore(norm);\r\n\t\t\t\t\t// only needed for ascii\r\n\t\t\t\t\t// 20230123: matches matches WHATWG, see note 3.3\r\n\t\t\t\t\tcheck_label_extension(norm);\r\n\t\t\t\t\t// cant have fenced\r\n\t\t\t\t\t// cant have cm\r\n\t\t\t\t\t// cant have wholes\r\n\t\t\t\t\t// see derive: \"Fastpath ASCII\"\r\n\t\t\t\t\ttype = 'ASCII';\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (emoji) { // there is at least one emoji\r\n\t\t\t\t\t\tinfo.emoji = true; \r\n\t\t\t\t\t\tchars = tokens.flatMap(x => x.is_emoji ? [] : x); // all of the nfc tokens concat together\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnorm = tokens.flatMap(x => !preserve_emoji && x.is_emoji ? filter_fe0f(x) : x);\r\n\t\t\t\t\tcheck_leading_underscore(norm);\r\n\t\t\t\t\tif (!chars.length) { // theres no text, just emoji\r\n\t\t\t\t\t\ttype = 'Emoji';\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// 5. \"The label must not begin with a combining mark, that is: General_Category=Mark.\"\r\n\t\t\t\t\t\tif (CM.has(norm[0])) throw error_placement('leading combining mark');\r\n\t\t\t\t\t\tfor (let i = 1; i < token_count; i++) { // we've already checked the first token\r\n\t\t\t\t\t\t\tlet cps = tokens[i];\r\n\t\t\t\t\t\t\tif (!cps.is_emoji && CM.has(cps[0])) { // every text token has emoji neighbors, eg. EtEEEtEt...\r\n\t\t\t\t\t\t\t\t// bidi_qq() not needed since emoji is LTR and cps is a CM\r\n\t\t\t\t\t\t\t\tthrow error_placement(`emoji + combining mark: \"${str_from_cps(tokens[i-1])} + ${safe_str_from_cps([cps[0]])}\"`); \r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcheck_fenced(norm);\r\n\t\t\t\t\t\tlet unique = [...new Set(chars)];\r\n\t\t\t\t\t\tlet [g] = determine_group(unique); // take the first match\r\n\t\t\t\t\t\t// see derive: \"Matching Groups have Same CM Style\"\r\n\t\t\t\t\t\t// alternative: could form a hybrid type: Latin/Japanese/...\t\r\n\t\t\t\t\t\tcheck_group(g, chars); // need text in order\r\n\t\t\t\t\t\tcheck_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)\r\n\t\t\t\t\t\ttype = g.N;\r\n\t\t\t\t\t\t// 20230121: consider exposing restricted flag\r\n\t\t\t\t\t\t// it's simpler to just check for 'Restricted'\r\n\t\t\t\t\t\t// or even better: type.endsWith(']')\r\n\t\t\t\t\t\t//if (g.R) info.restricted = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tinfo.type = type;\r\n\t\t} catch (err) {\r\n\t\t\tinfo.error = err; // use full error object\r\n\t\t}\r\n\t\tinfo.output = norm;\r\n\t\treturn info;\r\n\t});\r\n}\r\n\r\nfunction check_whole(group, unique) {\r\n\tlet maker;\r\n\tlet shared = []; // TODO: can this be avoided?\r\n\tfor (let cp of unique) {\r\n\t\tlet whole = WHOLE_MAP.get(cp);\r\n\t\tif (whole === UNIQUE_PH) return; // unique, non-confusable\r\n\t\tif (whole) {\r\n\t\t\tlet set = whole.M.get(cp); // groups which have a character that look-like this character\r\n\t\t\tmaker = maker ? maker.filter(g => set.has(g)) : [...set];\r\n\t\t\tif (!maker.length) return; // confusable intersection is empty\r\n\t\t} else {\r\n\t\t\tshared.push(cp); \r\n\t\t}\r\n\t}\r\n\tif (maker) {\r\n\t\t// we have 1+ confusable\r\n\t\t// check if any of the remaning groups\r\n\t\t// contain the shared characters too\r\n\t\tfor (let g of maker) {\r\n\t\t\tif (shared.every(cp => g.V.has(cp))) {\r\n\t\t\t\tthrow new Error(`whole-script confusable: ${group.N}/${g.N}`);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// assumption: unique.size > 0\r\n// returns list of matching groups\r\nfunction determine_group(unique) {\r\n\tlet groups = GROUPS;\r\n\tfor (let cp of unique) {\r\n\t\t// note: we need to dodge CM that are whitelisted\r\n\t\t// but that code isn't currently necessary\r\n\t\tlet gs = groups.filter(g => g.V.has(cp));\r\n\t\tif (!gs.length) {\r\n\t\t\tif (groups === GROUPS) {\r\n\t\t\t\t// the character was composed of valid parts\r\n\t\t\t\t// but it's NFC form is invalid\r\n\t\t\t\tthrow error_disallowed(cp); // this should be rare\r\n\t\t\t} else {\r\n\t\t\t\t// there is no group that contains all these characters\r\n\t\t\t\t// throw using the highest priority group that matched\r\n\t\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\t\tthrow error_group_member(groups[0], cp);\r\n\t\t\t}\r\n\t\t}\r\n\t\tgroups = gs;\r\n\t\tif (gs.length == 1) break; // there is only one group left\r\n\t}\r\n\t// there are at least 1 group(s) with all of these characters\r\n\treturn groups;\r\n}\r\n\r\n// throw on first error\r\nfunction flatten(split) {\r\n\treturn split.map(({input, error, output}) => {\r\n\t\tif (error) {\r\n\t\t\t// don't print label again if just a single label\r\n\t\t\tlet msg = error.message;\r\n\t\t\t// bidi_qq() only necessary if msg is digits\r\n\t\t\tthrow new Error(split.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input))}: ${msg}`); \r\n\t\t}\r\n\t\treturn str_from_cps(output);\r\n\t}).join(STOP_CH);\r\n}\r\n\r\nfunction error_disallowed(cp) {\r\n\t// TODO: add cp to error?\r\n\treturn new Error(`disallowed character: ${quoted_cp(cp)}`); \r\n}\r\nfunction error_group_member(g, cp) {\r\n\tlet quoted = quoted_cp(cp);\r\n\tlet gg = GROUPS.find(g => g.P.has(cp));\r\n\tif (gg) {\r\n\t\tquoted = `${gg.N} ${quoted}`;\r\n\t}\r\n\treturn new Error(`illegal mixture: ${g.N} + ${quoted}`);\r\n}\r\nfunction error_placement(where) {\r\n\treturn new Error(`illegal placement: ${where}`);\r\n}\r\n\r\n// assumption: cps.length > 0\r\n// assumption: cps[0] isn't a CM\r\n// assumption: the previous character isn't an emoji\r\nfunction check_group(g, cps) {\r\n\tlet {V, M} = g;\r\n\tfor (let cp of cps) {\r\n\t\tif (!V.has(cp)) {\r\n\t\t\t// for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. \"e{300}{300}\"\r\n\t\t\t// at the moment, it's unnecessary to introduce an extra error type\r\n\t\t\t// until there exists a whitelisted multi-character\r\n\t\t\t//   eg. if (M < 0 && is_combining_mark(cp)) { ... }\r\n\t\t\t// there are 3 cases:\r\n\t\t\t//   1. illegal cm for wrong group => mixture error\r\n\t\t\t//   2. illegal cm for same group => cm error\r\n\t\t\t//       requires set of whitelist cm per group: \r\n\t\t\t//        eg. new Set([...g.V].flatMap(nfc).filter(cp => CM.has(cp)))\r\n\t\t\t//   3. wrong group => mixture error\r\n\t\t\tthrow error_group_member(g, cp);\r\n\t\t}\r\n\t}\r\n\t//if (M >= 0) { // we have a known fixed cm count\r\n\tif (M) { // we need to check for NSM\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // see: assumption\r\n\t\t\t// 20230210: bugfix: using cps instead of decomposed h/t Carbon225\r\n\t\t\t/*\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t\t*/\r\n\t\t\t// 20230217: switch to NSM counting\r\n\t\t\t// https://www.unicode.org/reports/tr39/#Optional_Detection\r\n\t\t\tif (NSM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\tfor (let cp; j < e && NSM.has(cp = decomposed[j]); j++) {\r\n\t\t\t\t\t// a. Forbid sequences of the same nonspacing mark.\r\n\t\t\t\t\tfor (let k = i; k < j; k++) { // O(n^2) but n < 100\r\n\t\t\t\t\t\tif (decomposed[k] == cp) {\r\n\t\t\t\t\t\t\tthrow new Error(`non-spacing marks: repeated ${quoted_cp(cp)}`);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// parse to end so we have full nsm count\r\n\t\t\t\t// b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).\r\n\t\t\t\tif (j - i > NSM_MAX) {\r\n\t\t\t\t\t// note: this slice starts with a base char or spacing-mark cm\r\n\t\t\t\t\tthrow new Error(`non-spacing marks: too many ${bidi_qq(safe_str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${NSM_MAX})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// *** this code currently isn't needed ***\r\n\t/*\r\n\tlet cm_whitelist = M instanceof Map;\r\n\tfor (let i = 0, e = cps.length; i < e; ) {\r\n\t\tlet cp = cps[i++];\r\n\t\tlet seqs = cm_whitelist && M.get(cp);\r\n\t\tif (seqs) { \r\n\t\t\t// list of codepoints that can follow\r\n\t\t\t// if this exists, this will always be 1+\r\n\t\t\tlet j = i;\r\n\t\t\twhile (j < e && CM.has(cps[j])) j++;\r\n\t\t\tlet cms = cps.slice(i, j);\r\n\t\t\tlet match = seqs.find(seq => !compare_arrays(seq, cms));\r\n\t\t\tif (!match) throw new Error(`disallowed combining mark sequence: \"${safe_str_from_cps([cp, ...cms])}\"`);\r\n\t\t\ti = j;\r\n\t\t} else if (!V.has(cp)) {\r\n\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\tlet quoted = quoted_cp(cp);\r\n\t\t\tfor (let cp of cps) {\r\n\t\t\t\tlet u = UNIQUE.get(cp);\r\n\t\t\t\tif (u && u !== g) {\r\n\t\t\t\t\t// if both scripts are restricted this error is confusing\r\n\t\t\t\t\t// because we don't differentiate RestrictedA from RestrictedB \r\n\t\t\t\t\tif (!u.R) quoted = `${quoted} is ${u.N}`;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new Error(`disallowed ${g.N} character: ${quoted}`);\r\n\t\t\t//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);\r\n\t\t\t//throw new Error(`${g.N} does not allow: ${quoted}`);\r\n\t\t}\r\n\t}\r\n\tif (!cm_whitelist) {\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: \"${str_from_cps(decomposed.slice(i-1, j))}\" (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t*/\r\n}\r\n\r\n// given a list of codepoints\r\n// returns a list of lists, where emoji are a fully-qualified (as Array subclass)\r\n// eg. explode_cp(\"abc💩d\") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]\r\nfunction process(input, nf) {\r\n\tlet ret = [];\r\n\tlet chars = [];\r\n\tinput = input.slice().reverse(); // flip so we can pop\r\n\twhile (input.length) {\r\n\t\tlet emoji = consume_emoji_reversed(input);\r\n\t\tif (emoji) {\r\n\t\t\tif (chars.length) {\r\n\t\t\t\tret.push(nf(chars));\r\n\t\t\t\tchars = [];\r\n\t\t\t}\r\n\t\t\tret.push(emoji);\r\n\t\t} else {\r\n\t\t\tlet cp = input.pop();\r\n\t\t\tif (VALID.has(cp)) {\r\n\t\t\t\tchars.push(cp);\r\n\t\t\t} else {\r\n\t\t\t\tlet cps = MAPPED.get(cp);\r\n\t\t\t\tif (cps) {\r\n\t\t\t\t\tchars.push(...cps);\r\n\t\t\t\t} else if (!IGNORED.has(cp)) {\r\n\t\t\t\t\tthrow error_disallowed(cp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (chars.length) {\r\n\t\tret.push(nf(chars));\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction filter_fe0f(cps) {\r\n\treturn cps.filter(cp => cp != FE0F);\r\n}\r\n\r\n// given array of codepoints\r\n// returns the longest valid emoji sequence (or undefined if no match)\r\n// *MUTATES* the supplied array\r\n// allows optional FE0F\r\n// disallows interleaved ignored characters\r\n// fills (optional) eaten array with matched codepoints\r\nfunction consume_emoji_reversed(cps, eaten) {\r\n\tlet node = EMOJI_ROOT;\r\n\tlet emoji;\r\n\tlet saved;\r\n\tlet stack = [];\r\n\tlet pos = cps.length;\r\n\tif (eaten) eaten.length = 0; // clear input buffer (if needed)\r\n\twhile (pos) {\r\n\t\tlet cp = cps[--pos];\r\n\t\tnode = node.B.find(x => x.Q.has(cp));\r\n\t\tif (!node) break;\r\n\t\tif (node.S) { // remember\r\n\t\t\tsaved = cp;\r\n\t\t} else if (node.C) { // check exclusion\r\n\t\t\tif (cp === saved) break;\r\n\t\t}\r\n\t\tstack.push(cp);\r\n\t\tif (node.F) {\r\n\t\t\tstack.push(FE0F);\r\n\t\t\tif (pos > 0 && cps[pos - 1] == FE0F) pos--; // consume optional FE0F\r\n\t\t}\r\n\t\tif (node.V) { // this is a valid emoji (so far)\r\n\t\t\temoji = conform_emoji_copy(stack, node);\r\n\t\t\tif (eaten) eaten.push(...cps.slice(pos).reverse()); // copy input (if needed)\r\n\t\t\tcps.length = pos; // truncate\r\n\t\t}\r\n\t}\r\n\t/*\r\n\t// *** this code currently isn't needed ***\r\n\tif (!emoji) {\r\n\t\tlet cp = cps[cps.length-1];\r\n\t\tif (EMOJI_SOLO.has(cp)) {\r\n\t\t\tif (eaten) eaten.push(cp);\r\n\t\t\temoji = Emoji.of(cp);\r\n\t\t\tcps.pop();\r\n\t\t}\r\n\t}\r\n\t*/\r\n\treturn emoji;\r\n}\r\n\r\n// create a copy and fix any unicode quirks\r\nfunction conform_emoji_copy(cps, node) {\r\n\tlet copy = Emoji.from(cps); // copy stack\r\n\tif (node.V == 2) copy.splice(1, 1); // delete FE0F at position 1 (see: make.js)\r\n\treturn copy;\r\n}\r\n\r\n// return all supported emoji as fully-qualified emoji \r\n// ordered by length then lexicographic \r\nfunction ens_emoji() {\r\n\t// *** this code currently isn't needed ***\r\n\t//let ret = [...EMOJI_SOLO].map(x => [x]);\r\n\tlet ret = [];\r\n\tbuild(EMOJI_ROOT, []);\r\n\treturn ret.sort(compare_arrays);\r\n\tfunction build(node, cps, saved) {\r\n\t\tif (node.S) { \r\n\t\t\tsaved = cps[cps.length-1];\r\n\t\t} else if (node.C) { \r\n\t\t\tif (saved === cps[cps.length-1]) return;\r\n\t\t}\r\n\t\tif (node.F) cps.push(FE0F);\r\n\t\tif (node.V) ret.push(conform_emoji_copy(cps, node));\r\n\t\tfor (let br of node.B) {\r\n\t\t\tfor (let cp of br.Q) {\r\n\t\t\t\tbuild(br, [...cps, cp], saved);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// ************************************************************\r\n// tokenizer \r\n\r\nconst TY_VALID = 'valid';\r\nconst TY_MAPPED = 'mapped';\r\nconst TY_IGNORED = 'ignored';\r\nconst TY_DISALLOWED = 'disallowed';\r\nconst TY_EMOJI = 'emoji';\r\nconst TY_NFC = 'nfc';\r\nconst TY_STOP = 'stop';\r\n\r\nfunction ens_tokenize(name, {\r\n\tnf = true, // collapse unnormalized runs into a single token\r\n} = {}) {\r\n\tlet input = explode_cp(name).reverse();\r\n\tlet eaten = [];\r\n\tlet tokens = [];\r\n\twhile (input.length) {\t\t\r\n\t\tlet emoji = consume_emoji_reversed(input, eaten);\r\n\t\tif (emoji) {\r\n\t\t\ttokens.push({type: TY_EMOJI, emoji, input: eaten.slice(), cps: filter_fe0f(emoji)});\r\n\t\t} else {\r\n\t\t\tlet cp = input.pop();\r\n\t\t\tif (cp == STOP) {\r\n\t\t\t\ttokens.push({type: TY_STOP, cp});\r\n\t\t\t} else if (VALID.has(cp)) {\r\n\t\t\t\ttokens.push({type: TY_VALID, cps: [cp]});\r\n\t\t\t} else if (IGNORED.has(cp)) {\r\n\t\t\t\ttokens.push({type: TY_IGNORED, cp});\r\n\t\t\t} else {\r\n\t\t\t\tlet cps = MAPPED.get(cp);\r\n\t\t\t\tif (cps) {\r\n\t\t\t\t\ttokens.push({type: TY_MAPPED, cp, cps: cps.slice()});\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttokens.push({type: TY_DISALLOWED, cp});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (nf) {\r\n\t\tfor (let i = 0, start = -1; i < tokens.length; i++) {\r\n\t\t\tlet token = tokens[i];\r\n\t\t\tif (is_valid_or_mapped(token.type)) {\r\n\t\t\t\tif (requires_check(token.cps)) { // normalization might be needed\r\n\t\t\t\t\tlet end = i + 1;\r\n\t\t\t\t\tfor (let pos = end; pos < tokens.length; pos++) { // find adjacent text\r\n\t\t\t\t\t\tlet {type, cps} = tokens[pos];\r\n\t\t\t\t\t\tif (is_valid_or_mapped(type)) {\r\n\t\t\t\t\t\t\tif (!requires_check(cps)) break;\r\n\t\t\t\t\t\t\tend = pos + 1;\r\n\t\t\t\t\t\t} else if (type !== TY_IGNORED) { // || type !== TY_DISALLOWED) { \r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (start < 0) start = i;\r\n\t\t\t\t\tlet slice = tokens.slice(start, end);\r\n\t\t\t\t\tlet cps0 = slice.flatMap(x => is_valid_or_mapped(x.type) ? x.cps : []); // strip junk tokens\r\n\t\t\t\t\tlet cps = nfc(cps0);\r\n\t\t\t\t\tif (compare_arrays(cps, cps0)) { // bundle into an nfc token\r\n\t\t\t\t\t\ttokens.splice(start, end - start, {\r\n\t\t\t\t\t\t\ttype: TY_NFC, \r\n\t\t\t\t\t\t\tinput: cps0, // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps\r\n\t\t\t\t\t\t\tcps, \r\n\t\t\t\t\t\t\ttokens0: collapse_valid_tokens(slice),\r\n\t\t\t\t\t\t\ttokens: ens_tokenize(str_from_cps(cps), {nf: false})\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\ti = start;\r\n\t\t\t\t\t} else { \r\n\t\t\t\t\t\ti = end - 1; // skip to end of slice\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstart = -1; // reset\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstart = i; // remember last\r\n\t\t\t\t}\r\n\t\t\t} else if (token.type !== TY_IGNORED) { // 20221024: is this correct?\r\n\t\t\t\tstart = -1; // reset\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn collapse_valid_tokens(tokens);\r\n}\r\n\r\nfunction is_valid_or_mapped(type) {\r\n\treturn type == TY_VALID || type == TY_MAPPED;\r\n}\r\n\r\nfunction requires_check(cps) {\r\n\treturn cps.some(cp => NFC_CHECK.has(cp));\r\n}\r\n\r\nfunction collapse_valid_tokens(tokens) {\r\n\tfor (let i = 0; i < tokens.length; i++) {\r\n\t\tif (tokens[i].type == TY_VALID) {\r\n\t\t\tlet j = i + 1;\r\n\t\t\twhile (j < tokens.length && tokens[j].type == TY_VALID) j++;\r\n\t\t\ttokens.splice(i, j - i, {type: TY_VALID, cps: tokens.slice(i, j).flatMap(x => x.cps)});\r\n\t\t}\r\n\t}\r\n\treturn tokens;\r\n}\n\nexport { ens_beautify, ens_emoji, ens_normalize, ens_normalize_fragment, ens_split, ens_tokenize, is_combining_mark, nfc, nfd, safe_str_from_cps, should_escape };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}