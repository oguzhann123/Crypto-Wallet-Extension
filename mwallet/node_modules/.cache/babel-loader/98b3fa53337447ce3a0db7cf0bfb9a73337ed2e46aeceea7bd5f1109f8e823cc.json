{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classPrivateMethodInitSpec from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _defineProperty from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classPrivateMethodGet from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateMethodGet.js\";\nimport _classPrivateFieldSet from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\nimport _classPrivateFieldGet from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\n//import { TypedDataDomain, TypedDataField } from \"@ethersproject/providerabstract-signer\";\nimport { getAddress } from \"../address/index.js\";\nimport { keccak256 } from \"../crypto/index.js\";\nimport { recoverAddress } from \"../transaction/index.js\";\nimport { concat, defineProperties, getBigInt, getBytes, hexlify, isHexString, mask, toBeHex, toQuantity, toTwos, zeroPadValue, assertArgument } from \"../utils/index.js\";\nimport { id } from \"./id.js\";\nvar padding = new Uint8Array(32);\npadding.fill(0);\nvar BN__1 = BigInt(-1);\nvar BN_0 = BigInt(0);\nvar BN_1 = BigInt(1);\nvar BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n;\n;\nfunction hexPadRight(value) {\n  var bytes = getBytes(value);\n  var padOffset = bytes.length % 32;\n  if (padOffset) {\n    return concat([bytes, padding.slice(padOffset)]);\n  }\n  return hexlify(bytes);\n}\nvar hexTrue = toBeHex(BN_1, 32);\nvar hexFalse = toBeHex(BN_0, 32);\nvar domainFieldTypes = {\n  name: \"string\",\n  version: \"string\",\n  chainId: \"uint256\",\n  verifyingContract: \"address\",\n  salt: \"bytes32\"\n};\nvar domainFieldNames = [\"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"];\nfunction checkString(key) {\n  return function (value) {\n    assertArgument(typeof value === \"string\", \"invalid domain value for \".concat(JSON.stringify(key)), \"domain.\".concat(key), value);\n    return value;\n  };\n}\nvar domainChecks = {\n  name: checkString(\"name\"),\n  version: checkString(\"version\"),\n  chainId: function chainId(_value) {\n    var value = getBigInt(_value, \"domain.chainId\");\n    assertArgument(value >= 0, \"invalid chain ID\", \"domain.chainId\", _value);\n    if (Number.isSafeInteger(value)) {\n      return Number(value);\n    }\n    return toQuantity(value);\n  },\n  verifyingContract: function verifyingContract(value) {\n    try {\n      return getAddress(value).toLowerCase();\n    } catch (error) {}\n    assertArgument(false, \"invalid domain value \\\"verifyingContract\\\"\", \"domain.verifyingContract\", value);\n  },\n  salt: function salt(value) {\n    var bytes = getBytes(value, \"domain.salt\");\n    assertArgument(bytes.length === 32, \"invalid domain value \\\"salt\\\"\", \"domain.salt\", value);\n    return hexlify(bytes);\n  }\n};\nfunction getBaseEncoder(type) {\n  // intXX and uintXX\n  {\n    var match = type.match(/^(u?)int(\\d*)$/);\n    if (match) {\n      var signed = match[1] === \"\";\n      var width = parseInt(match[2] || \"256\");\n      assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && (match[2] == null || match[2] === String(width)), \"invalid numeric width\", \"type\", type);\n      var boundsUpper = mask(BN_MAX_UINT256, signed ? width - 1 : width);\n      var boundsLower = signed ? (boundsUpper + BN_1) * BN__1 : BN_0;\n      return function (_value) {\n        var value = getBigInt(_value, \"value\");\n        assertArgument(value >= boundsLower && value <= boundsUpper, \"value out-of-bounds for \".concat(type), \"value\", value);\n        return toBeHex(signed ? toTwos(value, 256) : value, 32);\n      };\n    }\n  }\n  // bytesXX\n  {\n    var _match = type.match(/^bytes(\\d+)$/);\n    if (_match) {\n      var _width = parseInt(_match[1]);\n      assertArgument(_width !== 0 && _width <= 32 && _match[1] === String(_width), \"invalid bytes width\", \"type\", type);\n      return function (value) {\n        var bytes = getBytes(value);\n        assertArgument(bytes.length === _width, \"invalid length for \".concat(type), \"value\", value);\n        return hexPadRight(value);\n      };\n    }\n  }\n  switch (type) {\n    case \"address\":\n      return function (value) {\n        return zeroPadValue(getAddress(value), 32);\n      };\n    case \"bool\":\n      return function (value) {\n        return !value ? hexFalse : hexTrue;\n      };\n    case \"bytes\":\n      return function (value) {\n        return keccak256(value);\n      };\n    case \"string\":\n      return function (value) {\n        return id(value);\n      };\n  }\n  return null;\n}\nfunction encodeType(name, fields) {\n  return \"\".concat(name, \"(\").concat(fields.map(function (_ref) {\n    var name = _ref.name,\n      type = _ref.type;\n    return type + \" \" + name;\n  }).join(\",\"), \")\");\n}\nvar _types = /*#__PURE__*/new WeakMap();\nvar _fullTypes = /*#__PURE__*/new WeakMap();\nvar _encoderCache = /*#__PURE__*/new WeakMap();\nvar _getEncoder = /*#__PURE__*/new WeakSet();\nexport var TypedDataEncoder = /*#__PURE__*/function () {\n  function TypedDataEncoder(types) {\n    _classCallCheck(this, TypedDataEncoder);\n    _classPrivateMethodInitSpec(this, _getEncoder);\n    _defineProperty(this, \"primaryType\", void 0);\n    _classPrivateFieldInitSpec(this, _types, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _fullTypes, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _encoderCache, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _types, JSON.stringify(types));\n    _classPrivateFieldSet(this, _fullTypes, new Map());\n    _classPrivateFieldSet(this, _encoderCache, new Map());\n    // Link struct types to their direct child structs\n    var links = new Map();\n    // Link structs to structs which contain them as a child\n    var parents = new Map();\n    // Link all subtypes within a given struct\n    var subtypes = new Map();\n    Object.keys(types).forEach(function (type) {\n      links.set(type, new Set());\n      parents.set(type, []);\n      subtypes.set(type, new Set());\n    });\n    for (var name in types) {\n      var uniqueNames = new Set();\n      var _iterator = _createForOfIteratorHelper(types[name]),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var field = _step.value;\n          // Check each field has a unique name\n          assertArgument(!uniqueNames.has(field.name), \"duplicate variable name \".concat(JSON.stringify(field.name), \" in \").concat(JSON.stringify(name)), \"types\", types);\n          uniqueNames.add(field.name);\n          // Get the base type (drop any array specifiers)\n          var baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1] || null;\n          assertArgument(baseType !== name, \"circular type reference to \".concat(JSON.stringify(baseType)), \"types\", types);\n          // Is this a base encoding type?\n          var encoder = getBaseEncoder(baseType);\n          if (encoder) {\n            continue;\n          }\n          assertArgument(parents.has(baseType), \"unknown type \".concat(JSON.stringify(baseType)), \"types\", types);\n          // Add linkage\n          parents.get(baseType).push(name);\n          links.get(name).add(baseType);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    // Deduce the primary type\n    var primaryTypes = Array.from(parents.keys()).filter(function (n) {\n      return parents.get(n).length === 0;\n    });\n    assertArgument(primaryTypes.length !== 0, \"missing primary type\", \"types\", types);\n    assertArgument(primaryTypes.length === 1, \"ambiguous primary types or unused types: \".concat(primaryTypes.map(function (t) {\n      return JSON.stringify(t);\n    }).join(\", \")), \"types\", types);\n    defineProperties(this, {\n      primaryType: primaryTypes[0]\n    });\n    // Check for circular type references\n    function checkCircular(type, found) {\n      assertArgument(!found.has(type), \"circular type reference to \".concat(JSON.stringify(type)), \"types\", types);\n      found.add(type);\n      var _iterator2 = _createForOfIteratorHelper(links.get(type)),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var child = _step2.value;\n          if (!parents.has(child)) {\n            continue;\n          }\n          // Recursively check children\n          checkCircular(child, found);\n          // Mark all ancestors as having this decendant\n          var _iterator3 = _createForOfIteratorHelper(found),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var subtype = _step3.value;\n              subtypes.get(subtype).add(child);\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      found.delete(type);\n    }\n    checkCircular(this.primaryType, new Set());\n    // Compute each fully describe type\n    var _iterator4 = _createForOfIteratorHelper(subtypes),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _step4$value = _slicedToArray(_step4.value, 2),\n          _name = _step4$value[0],\n          set = _step4$value[1];\n        var st = Array.from(set);\n        st.sort();\n        _classPrivateFieldGet(this, _fullTypes).set(_name, encodeType(_name, types[_name]) + st.map(function (t) {\n          return encodeType(t, types[t]);\n        }).join(\"\"));\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  }\n  _createClass(TypedDataEncoder, [{\n    key: \"types\",\n    get: function get() {\n      return JSON.parse(_classPrivateFieldGet(this, _types));\n    }\n  }, {\n    key: \"getEncoder\",\n    value: function getEncoder(type) {\n      var encoder = _classPrivateFieldGet(this, _encoderCache).get(type);\n      if (!encoder) {\n        encoder = _classPrivateMethodGet(this, _getEncoder, _getEncoder2).call(this, type);\n        _classPrivateFieldGet(this, _encoderCache).set(type, encoder);\n      }\n      return encoder;\n    }\n  }, {\n    key: \"encodeType\",\n    value: function encodeType(name) {\n      var result = _classPrivateFieldGet(this, _fullTypes).get(name);\n      assertArgument(result, \"unknown type: \".concat(JSON.stringify(name)), \"name\", name);\n      return result;\n    }\n  }, {\n    key: \"encodeData\",\n    value: function encodeData(type, value) {\n      return this.getEncoder(type)(value);\n    }\n  }, {\n    key: \"hashStruct\",\n    value: function hashStruct(name, value) {\n      return keccak256(this.encodeData(name, value));\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(value) {\n      return this.encodeData(this.primaryType, value);\n    }\n  }, {\n    key: \"hash\",\n    value: function hash(value) {\n      return this.hashStruct(this.primaryType, value);\n    }\n  }, {\n    key: \"_visit\",\n    value: function _visit(type, value, callback) {\n      var _this = this;\n      // Basic encoder type (address, bool, uint256, etc)\n      {\n        var encoder = getBaseEncoder(type);\n        if (encoder) {\n          return callback(type, value);\n        }\n      }\n      // Array\n      var match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n      if (match) {\n        assertArgument(!match[3] || parseInt(match[3]) === value.length, \"array length mismatch; expected length \".concat(parseInt(match[3])), \"value\", value);\n        return value.map(function (v) {\n          return _this._visit(match[1], v, callback);\n        });\n      }\n      // Struct\n      var fields = this.types[type];\n      if (fields) {\n        return fields.reduce(function (accum, _ref2) {\n          var name = _ref2.name,\n            type = _ref2.type;\n          accum[name] = _this._visit(type, value[name], callback);\n          return accum;\n        }, {});\n      }\n      assertArgument(false, \"unknown type: \".concat(type), \"type\", type);\n    }\n  }, {\n    key: \"visit\",\n    value: function visit(value, callback) {\n      return this._visit(this.primaryType, value, callback);\n    }\n  }], [{\n    key: \"from\",\n    value: function from(types) {\n      return new TypedDataEncoder(types);\n    }\n  }, {\n    key: \"getPrimaryType\",\n    value: function getPrimaryType(types) {\n      return TypedDataEncoder.from(types).primaryType;\n    }\n  }, {\n    key: \"hashStruct\",\n    value: function hashStruct(name, types, value) {\n      return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n  }, {\n    key: \"hashDomain\",\n    value: function hashDomain(domain) {\n      var domainFields = [];\n      for (var name in domain) {\n        if (domain[name] == null) {\n          continue;\n        }\n        var type = domainFieldTypes[name];\n        assertArgument(type, \"invalid typed-data domain key: \".concat(JSON.stringify(name)), \"domain\", domain);\n        domainFields.push({\n          name: name,\n          type: type\n        });\n      }\n      domainFields.sort(function (a, b) {\n        return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n      });\n      return TypedDataEncoder.hashStruct(\"EIP712Domain\", {\n        EIP712Domain: domainFields\n      }, domain);\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(domain, types, value) {\n      return concat([\"0x1901\", TypedDataEncoder.hashDomain(domain), TypedDataEncoder.from(types).hash(value)]);\n    }\n  }, {\n    key: \"hash\",\n    value: function hash(domain, types, value) {\n      return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n    // Replaces all address types with ENS names with their looked up address\n  }, {\n    key: \"resolveNames\",\n    value: function () {\n      var _resolveNames = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(domain, types, value, resolveName) {\n        var key, ensCache, encoder, name;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              // Make a copy to isolate it from the object passed in\n              domain = Object.assign({}, domain);\n              // Allow passing null to ignore value\n              for (key in domain) {\n                if (domain[key] == null) {\n                  delete domain[key];\n                }\n              }\n              // Look up all ENS names\n              ensCache = {}; // Do we need to look up the domain's verifyingContract?\n              if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n                ensCache[domain.verifyingContract] = \"0x\";\n              }\n              // We are going to use the encoder to visit all the base values\n              encoder = TypedDataEncoder.from(types); // Get a list of all the addresses\n              encoder.visit(value, function (type, value) {\n                if (type === \"address\" && !isHexString(value, 20)) {\n                  ensCache[value] = \"0x\";\n                }\n                return value;\n              });\n              // Lookup each name\n              _context.t0 = _regeneratorRuntime().keys(ensCache);\n            case 7:\n              if ((_context.t1 = _context.t0()).done) {\n                _context.next = 14;\n                break;\n              }\n              name = _context.t1.value;\n              _context.next = 11;\n              return resolveName(name);\n            case 11:\n              ensCache[name] = _context.sent;\n              _context.next = 7;\n              break;\n            case 14:\n              // Replace the domain verifyingContract if needed\n              if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n                domain.verifyingContract = ensCache[domain.verifyingContract];\n              }\n              // Replace all ENS names with their address\n              value = encoder.visit(value, function (type, value) {\n                if (type === \"address\" && ensCache[value]) {\n                  return ensCache[value];\n                }\n                return value;\n              });\n              return _context.abrupt(\"return\", {\n                domain: domain,\n                value: value\n              });\n            case 17:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      function resolveNames(_x, _x2, _x3, _x4) {\n        return _resolveNames.apply(this, arguments);\n      }\n      return resolveNames;\n    }()\n  }, {\n    key: \"getPayload\",\n    value: function getPayload(domain, types, value) {\n      // Validate the domain fields\n      TypedDataEncoder.hashDomain(domain);\n      // Derive the EIP712Domain Struct reference type\n      var domainValues = {};\n      var domainTypes = [];\n      domainFieldNames.forEach(function (name) {\n        var value = domain[name];\n        if (value == null) {\n          return;\n        }\n        domainValues[name] = domainChecks[name](value);\n        domainTypes.push({\n          name: name,\n          type: domainFieldTypes[name]\n        });\n      });\n      var encoder = TypedDataEncoder.from(types);\n      var typesWithDomain = Object.assign({}, types);\n      assertArgument(typesWithDomain.EIP712Domain == null, \"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n      typesWithDomain.EIP712Domain = domainTypes;\n      // Validate the data structures and types\n      encoder.encode(value);\n      return {\n        types: typesWithDomain,\n        domain: domainValues,\n        primaryType: encoder.primaryType,\n        message: encoder.visit(value, function (type, value) {\n          // bytes\n          if (type.match(/^bytes(\\d*)/)) {\n            return hexlify(getBytes(value));\n          }\n          // uint or int\n          if (type.match(/^u?int/)) {\n            return getBigInt(value).toString();\n          }\n          switch (type) {\n            case \"address\":\n              return value.toLowerCase();\n            case \"bool\":\n              return !!value;\n            case \"string\":\n              assertArgument(typeof value === \"string\", \"invalid string\", \"value\", value);\n              return value;\n          }\n          assertArgument(false, \"unsupported type\", \"type\", type);\n        })\n      };\n    }\n  }]);\n  return TypedDataEncoder;\n}();\n/**\n *  Compute the address used to sign the typed data for the %%signature%%.\n */\nfunction _getEncoder2(type) {\n  var _this2 = this;\n  // Basic encoder type (address, bool, uint256, etc)\n  {\n    var encoder = getBaseEncoder(type);\n    if (encoder) {\n      return encoder;\n    }\n  }\n  // Array\n  var match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n  if (match) {\n    var subtype = match[1];\n    var subEncoder = this.getEncoder(subtype);\n    return function (value) {\n      assertArgument(!match[3] || parseInt(match[3]) === value.length, \"array length mismatch; expected length \".concat(parseInt(match[3])), \"value\", value);\n      var result = value.map(subEncoder);\n      if (_classPrivateFieldGet(_this2, _fullTypes).has(subtype)) {\n        result = result.map(keccak256);\n      }\n      return keccak256(concat(result));\n    };\n  }\n  // Struct\n  var fields = this.types[type];\n  if (fields) {\n    var encodedType = id(_classPrivateFieldGet(this, _fullTypes).get(type));\n    return function (value) {\n      var values = fields.map(function (_ref3) {\n        var name = _ref3.name,\n          type = _ref3.type;\n        var result = _this2.getEncoder(type)(value[name]);\n        if (_classPrivateFieldGet(_this2, _fullTypes).has(type)) {\n          return keccak256(result);\n        }\n        return result;\n      });\n      values.unshift(encodedType);\n      return concat(values);\n    };\n  }\n  assertArgument(false, \"unknown type: \".concat(type), \"type\", type);\n}\nexport function verifyTypedData(domain, types, value, signature) {\n  return recoverAddress(TypedDataEncoder.hash(domain, types, value), signature);\n}","map":{"version":3,"names":["getAddress","keccak256","recoverAddress","concat","defineProperties","getBigInt","getBytes","hexlify","isHexString","mask","toBeHex","toQuantity","toTwos","zeroPadValue","assertArgument","id","padding","Uint8Array","fill","BN__1","BigInt","BN_0","BN_1","BN_MAX_UINT256","hexPadRight","value","bytes","padOffset","length","slice","hexTrue","hexFalse","domainFieldTypes","name","version","chainId","verifyingContract","salt","domainFieldNames","checkString","key","JSON","stringify","domainChecks","_value","Number","isSafeInteger","toLowerCase","error","getBaseEncoder","type","match","signed","width","parseInt","String","boundsUpper","boundsLower","encodeType","fields","map","_ref","join","_types","WeakMap","_fullTypes","_encoderCache","_getEncoder","WeakSet","TypedDataEncoder","types","_classCallCheck","_classPrivateMethodInitSpec","_defineProperty","_classPrivateFieldInitSpec","writable","_classPrivateFieldSet","Map","links","parents","subtypes","Object","keys","forEach","set","Set","uniqueNames","_iterator","_createForOfIteratorHelper","_step","s","n","done","field","has","add","baseType","encoder","get","push","err","e","f","primaryTypes","Array","from","filter","t","primaryType","checkCircular","found","_iterator2","_step2","child","_iterator3","_step3","subtype","delete","_iterator4","_step4","_step4$value","_slicedToArray","st","sort","_classPrivateFieldGet","_createClass","parse","getEncoder","_classPrivateMethodGet","_getEncoder2","call","result","encodeData","hashStruct","encode","hash","_visit","callback","_this","v","reduce","accum","_ref2","visit","getPrimaryType","hashDomain","domain","domainFields","a","b","indexOf","EIP712Domain","_resolveNames","_asyncToGenerator","_regeneratorRuntime","mark","_callee","resolveName","ensCache","wrap","_callee$","_context","prev","next","assign","t0","t1","sent","abrupt","stop","resolveNames","_x","_x2","_x3","_x4","apply","arguments","getPayload","domainValues","domainTypes","typesWithDomain","message","toString","_this2","subEncoder","encodedType","values","_ref3","unshift","verifyTypedData","signature"],"sources":["C:\\Users\\Oguzhan\\Desktop\\BlockGuard\\mwallet\\node_modules\\ethers\\src.ts\\hash\\typed-data.ts"],"sourcesContent":["//import { TypedDataDomain, TypedDataField } from \"@ethersproject/providerabstract-signer\";\nimport { getAddress } from \"../address/index.js\";\nimport { keccak256 } from \"../crypto/index.js\";\nimport { recoverAddress } from \"../transaction/index.js\";\nimport {\n    concat, defineProperties, getBigInt, getBytes, hexlify, isHexString, mask, toBeHex, toQuantity, toTwos, zeroPadValue,\n    assertArgument\n} from \"../utils/index.js\";\n\nimport { id } from \"./id.js\";\n\nimport type { SignatureLike } from \"../crypto/index.js\";\nimport type { BigNumberish, BytesLike } from \"../utils/index.js\";\n\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\n\nconst BN__1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\nexport interface TypedDataDomain {\n    name?: null | string;\n    version?: null | string;\n    chainId?: null | BigNumberish;\n    verifyingContract?: null | string;\n    salt?: null | BytesLike;\n};\n\nexport interface TypedDataField {\n    name: string;\n    type: string;\n};\n\nfunction hexPadRight(value: BytesLike): string {\n    const bytes = getBytes(value);\n    const padOffset = bytes.length % 32\n    if (padOffset) {\n        return concat([ bytes, padding.slice(padOffset) ]);\n    }\n    return hexlify(bytes);\n}\n\nconst hexTrue = toBeHex(BN_1, 32);\nconst hexFalse = toBeHex(BN_0, 32);\n\nconst domainFieldTypes: Record<string, string> = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\n\nconst domainFieldNames: Array<string> = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\n\nfunction checkString(key: string): (value: any) => string {\n    return function (value: any){\n        assertArgument(typeof(value) === \"string\", `invalid domain value for ${ JSON.stringify(key) }`, `domain.${ key }`, value);\n        return value;\n    }\n}\n\nconst domainChecks: Record<string, (value: any) => any> = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function(_value: any) {\n        const value = getBigInt(_value, \"domain.chainId\");\n        assertArgument(value >= 0, \"invalid chain ID\", \"domain.chainId\", _value);\n        if (Number.isSafeInteger(value)) { return Number(value); }\n        return toQuantity(value);\n    },\n    verifyingContract: function(value: any) {\n        try {\n            return getAddress(value).toLowerCase();\n        } catch (error) { }\n        assertArgument(false, `invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function(value: any) {\n        const bytes = getBytes(value, \"domain.salt\");\n        assertArgument(bytes.length === 32, `invalid domain value \"salt\"`, \"domain.salt\", value);\n        return hexlify(bytes);\n    }\n}\n\nfunction getBaseEncoder(type: string): null | ((value: any) => string) {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n\n            const width = parseInt(match[2] || \"256\");\n            assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && (match[2] == null || match[2] === String(width)), \"invalid numeric width\", \"type\", type);\n\n            const boundsUpper = mask(BN_MAX_UINT256, signed ? (width - 1): width);\n            const boundsLower = signed ? ((boundsUpper + BN_1) * BN__1): BN_0;\n\n            return function(_value: BigNumberish) {\n                const value = getBigInt(_value, \"value\");\n\n                assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${ type }`, \"value\", value);\n\n                return toBeHex(signed ? toTwos(value, 256): value, 32);\n            };\n        }\n    }\n\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            assertArgument(width !== 0 && width <= 32 && match[1] === String(width), \"invalid bytes width\", \"type\", type);\n\n            return function(value: BytesLike) {\n                const bytes = getBytes(value);\n                assertArgument(bytes.length === width, `invalid length for ${ type }`, \"value\", value);\n                return hexPadRight(value);\n            };\n        }\n    }\n\n    switch (type) {\n        case \"address\": return function(value: string) {\n            return zeroPadValue(getAddress(value), 32);\n        };\n        case \"bool\": return function(value: boolean) {\n            return ((!value) ? hexFalse: hexTrue);\n        };\n        case \"bytes\": return function(value: BytesLike) {\n            return keccak256(value);\n        };\n        case \"string\": return function(value: string) {\n            return id(value);\n        };\n    }\n\n    return null;\n}\n\nfunction encodeType(name: string, fields: Array<TypedDataField>): string {\n    return `${ name }(${ fields.map(({ name, type }) => (type + \" \" + name)).join(\",\") })`;\n}\n\nexport class TypedDataEncoder {\n    readonly primaryType!: string;\n\n    readonly #types: string;\n    get types(): Record<string, Array<TypedDataField>> {\n        return JSON.parse(this.#types);\n    }\n\n    readonly #fullTypes: Map<string, string>\n\n    readonly #encoderCache: Map<string, (value: any) => string>;\n\n    constructor(types: Record<string, Array<TypedDataField>>) {\n        this.#types = JSON.stringify(types);\n        this.#fullTypes = new Map();\n        this.#encoderCache = new Map();\n\n        // Link struct types to their direct child structs\n        const links: Map<string, Set<string>> = new Map();\n\n        // Link structs to structs which contain them as a child\n        const parents: Map<string, Array<string>> = new Map();\n\n        // Link all subtypes within a given struct\n        const subtypes: Map<string, Set<string>> = new Map();\n\n        Object.keys(types).forEach((type) => {\n            links.set(type, new Set());\n            parents.set(type, [ ]);\n            subtypes.set(type, new Set());\n        });\n\n        for (const name in types) {\n            const uniqueNames: Set<string> = new Set();\n\n            for (const field of types[name]) {\n\n                // Check each field has a unique name\n                assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${ JSON.stringify(field.name) } in ${ JSON.stringify(name) }`, \"types\", types);\n                uniqueNames.add(field.name);\n\n                // Get the base type (drop any array specifiers)\n                const baseType = (<any>(field.type.match(/^([^\\x5b]*)(\\x5b|$)/)))[1] || null;\n                assertArgument(baseType !== name, `circular type reference to ${ JSON.stringify(baseType) }`, \"types\", types);\n\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) { continue; }\n\n                assertArgument(parents.has(baseType), `unknown type ${ JSON.stringify(baseType) }`, \"types\", types);\n\n                // Add linkage\n                (parents.get(baseType) as Array<string>).push(name);\n                (links.get(name) as Set<string>).add(baseType);\n            }\n        }\n\n        // Deduce the primary type\n        const primaryTypes = Array.from(parents.keys()).filter((n) => ((parents.get(n) as Array<string>).length === 0));\n        assertArgument(primaryTypes.length !== 0, \"missing primary type\", \"types\", types);\n        assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${ primaryTypes.map((t) => (JSON.stringify(t))).join(\", \") }`, \"types\", types);\n\n        defineProperties<TypedDataEncoder>(this, { primaryType: primaryTypes[0] });\n\n        // Check for circular type references\n        function checkCircular(type: string, found: Set<string>) {\n            assertArgument(!found.has(type), `circular type reference to ${ JSON.stringify(type) }`, \"types\", types);\n\n            found.add(type);\n\n            for (const child of (links.get(type) as Set<string>)) {\n                if (!parents.has(child)) { continue; }\n\n                // Recursively check children\n                checkCircular(child, found);\n\n                // Mark all ancestors as having this decendant\n                for (const subtype of found) {\n                    (subtypes.get(subtype) as Set<string>).add(child);\n                }\n            }\n\n            found.delete(type);\n        }\n        checkCircular(this.primaryType, new Set());\n\n        // Compute each fully describe type\n        for (const [ name, set ] of subtypes) {\n            const st = Array.from(set);\n            st.sort();\n            this.#fullTypes.set(name, encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\"));\n        }\n    }\n\n    getEncoder(type: string): (value: any) => string {\n        let encoder = this.#encoderCache.get(type);\n        if (!encoder) {\n            encoder = this.#getEncoder(type);\n            this.#encoderCache.set(type, encoder);\n        }\n        return encoder;\n    }\n\n    #getEncoder(type: string): (value: any) => string {\n\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return encoder; }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            return (value: Array<any>) => {\n                assertArgument(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${ parseInt(match[3]) }`, \"value\", value);\n\n                let result = value.map(subEncoder);\n                if (this.#fullTypes.has(subtype)) {\n                    result = result.map(keccak256);\n                }\n\n                return keccak256(concat(result));\n            };\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = id(this.#fullTypes.get(type) as string);\n            return (value: Record<string, any>) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this.#fullTypes.has(type)) { return keccak256(result); }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return concat(values);\n            }\n        }\n\n        assertArgument(false, `unknown type: ${ type }`, \"type\", type);\n    }\n\n    encodeType(name: string): string {\n        const result = this.#fullTypes.get(name);\n        assertArgument(result, `unknown type: ${ JSON.stringify(name) }`, \"name\", name);\n        return result;\n    }\n\n    encodeData(type: string, value: any): string {\n        return this.getEncoder(type)(value);\n    }\n\n    hashStruct(name: string, value: Record<string, any>): string {\n        return keccak256(this.encodeData(name, value));\n    }\n\n    encode(value: Record<string, any>): string {\n        return this.encodeData(this.primaryType, value);\n    }\n\n    hash(value: Record<string, any>): string {\n        return this.hashStruct(this.primaryType, value);\n    }\n\n    _visit(type: string, value: any, callback: (type: string, data: any) => any): any {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return callback(type, value); }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            assertArgument(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${ parseInt(match[3]) }`, \"value\", value);\n            return value.map((v: any) => this._visit(match[1], v, callback));\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, <Record<string, any>>{});\n        }\n\n        assertArgument(false, `unknown type: ${ type }`, \"type\", type);\n    }\n\n    visit(value: Record<string, any>, callback: (type: string, data: any) => any): any {\n        return this._visit(this.primaryType, value, callback);\n    }\n\n    static from(types: Record<string, Array<TypedDataField>>): TypedDataEncoder {\n        return new TypedDataEncoder(types);\n    }\n\n    static getPrimaryType(types: Record<string, Array<TypedDataField>>): string {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n\n    static hashStruct(name: string, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n\n    static hashDomain(domain: TypedDataDomain): string {\n        const domainFields: Array<TypedDataField> = [ ];\n        for (const name in domain) {\n            if ((<Record<string, any>>domain)[name] == null) { continue; }\n            const type = domainFieldTypes[name];\n            assertArgument(type, `invalid typed-data domain key: ${ JSON.stringify(name) }`, \"domain\", domain);\n            domainFields.push({ name, type });\n        }\n\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n\n    static encode(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return concat([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n\n    static hash(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n\n    // Replaces all address types with ENS names with their looked up address\n    static async resolveNames(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, resolveName: (name: string) => Promise<string>): Promise<{ domain: TypedDataDomain, value: any }> {\n        // Make a copy to isolate it from the object passed in\n        domain = Object.assign({ }, domain);\n\n        // Allow passing null to ignore value\n        for (const key in domain) {\n            if ((<Record<string, any>>domain)[key] == null) {\n                delete (<Record<string, any>>domain)[key];\n            }\n        }\n\n        // Look up all ENS names\n        const ensCache: Record<string, string> = { };\n\n        // Do we need to look up the domain's verifyingContract?\n        if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n            ensCache[domain.verifyingContract] = \"0x\";\n        }\n\n        // We are going to use the encoder to visit all the base values\n        const encoder = TypedDataEncoder.from(types);\n\n        // Get a list of all the addresses\n        encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && !isHexString(value, 20)) {\n                ensCache[value] = \"0x\";\n            }\n            return value;\n        });\n\n        // Lookup each name\n        for (const name in ensCache) {\n            ensCache[name] = await resolveName(name);\n        }\n\n        // Replace the domain verifyingContract if needed\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n            domain.verifyingContract = ensCache[domain.verifyingContract];\n        }\n\n        // Replace all ENS names with their address\n        value = encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && ensCache[value]) { return ensCache[value]; }\n            return value;\n        });\n\n        return { domain, value };\n    }\n\n    static getPayload(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): any {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n\n        // Derive the EIP712Domain Struct reference type\n        const domainValues: Record<string, any> = { };\n        const domainTypes: Array<{ name: string, type:string }> = [ ];\n\n        domainFieldNames.forEach((name) => {\n            const value = (<any>domain)[name];\n            if (value == null) { return; }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n\n        const encoder = TypedDataEncoder.from(types);\n\n        const typesWithDomain = Object.assign({ }, types);\n        assertArgument(typesWithDomain.EIP712Domain == null, \"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n\n        typesWithDomain.EIP712Domain = domainTypes;\n\n        // Validate the data structures and types\n        encoder.encode(value);\n\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type: string, value: any) => {\n\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return hexlify(getBytes(value));\n                }\n\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return getBigInt(value).toString();\n                }\n\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        assertArgument(typeof(value) === \"string\", \"invalid string\", \"value\", value);\n                        return value;\n                }\n\n                assertArgument(false, \"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n\n/**\n *  Compute the address used to sign the typed data for the %%signature%%.\n */\nexport function verifyTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, signature: SignatureLike): string {\n    return recoverAddress(TypedDataEncoder.hash(domain, types, value), signature);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}