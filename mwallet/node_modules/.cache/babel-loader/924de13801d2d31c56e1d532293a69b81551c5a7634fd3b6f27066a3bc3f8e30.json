{"ast":null,"code":"import _classCallCheck from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classPrivateFieldInitSpec from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldSet from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\nimport _classPrivateFieldGet from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nimport { getAddress } from \"../address/index.js\";\nimport { keccak256, Signature, SigningKey } from \"../crypto/index.js\";\nimport { concat, decodeRlp, encodeRlp, getBytes, getBigInt, getNumber, hexlify, assert, assertArgument, toBeArray, zeroPadValue } from \"../utils/index.js\";\nimport { accessListify } from \"./accesslist.js\";\nimport { recoverAddress } from \"./address.js\";\nvar BN_0 = BigInt(0);\nvar BN_2 = BigInt(2);\nvar BN_27 = BigInt(27);\nvar BN_28 = BigInt(28);\nvar BN_35 = BigInt(35);\nvar BN_MAX_UINT = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nfunction handleAddress(value) {\n  if (value === \"0x\") {\n    return null;\n  }\n  return getAddress(value);\n}\nfunction handleAccessList(value, param) {\n  try {\n    return accessListify(value);\n  } catch (error) {\n    assertArgument(false, error.message, param, value);\n  }\n}\nfunction handleNumber(_value, param) {\n  if (_value === \"0x\") {\n    return 0;\n  }\n  return getNumber(_value, param);\n}\nfunction handleUint(_value, param) {\n  if (_value === \"0x\") {\n    return BN_0;\n  }\n  var value = getBigInt(_value, param);\n  assertArgument(value <= BN_MAX_UINT, \"value exceeds uint size\", param, value);\n  return value;\n}\nfunction formatNumber(_value, name) {\n  var value = getBigInt(_value, \"value\");\n  var result = toBeArray(value);\n  assertArgument(result.length <= 32, \"value too large\", \"tx.\".concat(name), value);\n  return result;\n}\nfunction formatAccessList(value) {\n  return accessListify(value).map(function (set) {\n    return [set.address, set.storageKeys];\n  });\n}\nfunction _parseLegacy(data) {\n  var fields = decodeRlp(data);\n  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), \"invalid field count for legacy transaction\", \"data\", data);\n  var tx = {\n    type: 0,\n    nonce: handleNumber(fields[0], \"nonce\"),\n    gasPrice: handleUint(fields[1], \"gasPrice\"),\n    gasLimit: handleUint(fields[2], \"gasLimit\"),\n    to: handleAddress(fields[3]),\n    value: handleUint(fields[4], \"value\"),\n    data: hexlify(fields[5]),\n    chainId: BN_0\n  };\n  // Legacy unsigned transaction\n  if (fields.length === 6) {\n    return tx;\n  }\n  var v = handleUint(fields[6], \"v\");\n  var r = handleUint(fields[7], \"r\");\n  var s = handleUint(fields[8], \"s\");\n  if (r === BN_0 && s === BN_0) {\n    // EIP-155 unsigned transaction\n    tx.chainId = v;\n  } else {\n    // Compute the EIP-155 chain ID (or 0 for legacy)\n    var chainId = (v - BN_35) / BN_2;\n    if (chainId < BN_0) {\n      chainId = BN_0;\n    }\n    tx.chainId = chainId;\n    // Signed Legacy Transaction\n    assertArgument(chainId !== BN_0 || v === BN_27 || v === BN_28, \"non-canonical legacy v\", \"v\", fields[6]);\n    tx.signature = Signature.from({\n      r: zeroPadValue(fields[7], 32),\n      s: zeroPadValue(fields[8], 32),\n      v: v\n    });\n    tx.hash = keccak256(data);\n  }\n  return tx;\n}\nfunction _serializeLegacy(tx, sig) {\n  var fields = [formatNumber(tx.nonce || 0, \"nonce\"), formatNumber(tx.gasPrice || 0, \"gasPrice\"), formatNumber(tx.gasLimit || 0, \"gasLimit\"), tx.to != null ? getAddress(tx.to) : \"0x\", formatNumber(tx.value || 0, \"value\"), tx.data || \"0x\"];\n  var chainId = BN_0;\n  if (tx.chainId != BN_0) {\n    // A chainId was provided; if non-zero we'll use EIP-155\n    chainId = getBigInt(tx.chainId, \"tx.chainId\");\n    // We have a chainId in the tx and an EIP-155 v in the signature,\n    // make sure they agree with each other\n    assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n  } else if (tx.signature) {\n    // No explicit chainId, but EIP-155 have a derived implicit chainId\n    var legacy = tx.signature.legacyChainId;\n    if (legacy != null) {\n      chainId = legacy;\n    }\n  }\n  // Requesting an unsigned transaction\n  if (!sig) {\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== BN_0) {\n      fields.push(toBeArray(chainId));\n      fields.push(\"0x\");\n      fields.push(\"0x\");\n    }\n    return encodeRlp(fields);\n  }\n  // @TODO: We should probably check that tx.signature, chainId, and sig\n  //        match but that logic could break existing code, so schedule\n  //        this for the next major bump.\n  // Compute the EIP-155 v\n  var v = BigInt(27 + sig.yParity);\n  if (chainId !== BN_0) {\n    v = Signature.getChainIdV(chainId, sig.v);\n  } else if (BigInt(sig.v) !== v) {\n    assertArgument(false, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n  }\n  // Add the signature\n  fields.push(toBeArray(v));\n  fields.push(toBeArray(sig.r));\n  fields.push(toBeArray(sig.s));\n  return encodeRlp(fields);\n}\nfunction _parseEipSignature(tx, fields, serialize) {\n  var yParity;\n  try {\n    yParity = handleNumber(fields[0], \"yParity\");\n    if (yParity !== 0 && yParity !== 1) {\n      throw new Error(\"bad yParity\");\n    }\n  } catch (error) {\n    assertArgument(false, \"invalid yParity\", \"yParity\", fields[0]);\n  }\n  var r = zeroPadValue(fields[1], 32);\n  var s = zeroPadValue(fields[2], 32);\n  var signature = Signature.from({\n    r: r,\n    s: s,\n    yParity: yParity\n  });\n  tx.signature = signature;\n}\nfunction _parseEip1559(data) {\n  var fields = decodeRlp(getBytes(data).slice(1));\n  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), \"invalid field count for transaction type: 2\", \"data\", hexlify(data));\n  var maxPriorityFeePerGas = handleUint(fields[2], \"maxPriorityFeePerGas\");\n  var maxFeePerGas = handleUint(fields[3], \"maxFeePerGas\");\n  var tx = {\n    type: 2,\n    chainId: handleUint(fields[0], \"chainId\"),\n    nonce: handleNumber(fields[1], \"nonce\"),\n    maxPriorityFeePerGas: maxPriorityFeePerGas,\n    maxFeePerGas: maxFeePerGas,\n    gasPrice: null,\n    gasLimit: handleUint(fields[4], \"gasLimit\"),\n    to: handleAddress(fields[5]),\n    value: handleUint(fields[6], \"value\"),\n    data: hexlify(fields[7]),\n    accessList: handleAccessList(fields[8], \"accessList\")\n  };\n  // Unsigned EIP-1559 Transaction\n  if (fields.length === 9) {\n    return tx;\n  }\n  tx.hash = keccak256(data);\n  _parseEipSignature(tx, fields.slice(9), _serializeEip1559);\n  return tx;\n}\nfunction _serializeEip1559(tx, sig) {\n  var fields = [formatNumber(tx.chainId || 0, \"chainId\"), formatNumber(tx.nonce || 0, \"nonce\"), formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"), formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"), formatNumber(tx.gasLimit || 0, \"gasLimit\"), tx.to != null ? getAddress(tx.to) : \"0x\", formatNumber(tx.value || 0, \"value\"), tx.data || \"0x\", formatAccessList(tx.accessList || [])];\n  if (sig) {\n    fields.push(formatNumber(sig.yParity, \"yParity\"));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig.s));\n  }\n  return concat([\"0x02\", encodeRlp(fields)]);\n}\nfunction _parseEip2930(data) {\n  var fields = decodeRlp(getBytes(data).slice(1));\n  assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), \"invalid field count for transaction type: 1\", \"data\", hexlify(data));\n  var tx = {\n    type: 1,\n    chainId: handleUint(fields[0], \"chainId\"),\n    nonce: handleNumber(fields[1], \"nonce\"),\n    gasPrice: handleUint(fields[2], \"gasPrice\"),\n    gasLimit: handleUint(fields[3], \"gasLimit\"),\n    to: handleAddress(fields[4]),\n    value: handleUint(fields[5], \"value\"),\n    data: hexlify(fields[6]),\n    accessList: handleAccessList(fields[7], \"accessList\")\n  };\n  // Unsigned EIP-2930 Transaction\n  if (fields.length === 8) {\n    return tx;\n  }\n  tx.hash = keccak256(data);\n  _parseEipSignature(tx, fields.slice(8), _serializeEip2930);\n  return tx;\n}\nfunction _serializeEip2930(tx, sig) {\n  var fields = [formatNumber(tx.chainId || 0, \"chainId\"), formatNumber(tx.nonce || 0, \"nonce\"), formatNumber(tx.gasPrice || 0, \"gasPrice\"), formatNumber(tx.gasLimit || 0, \"gasLimit\"), tx.to != null ? getAddress(tx.to) : \"0x\", formatNumber(tx.value || 0, \"value\"), tx.data || \"0x\", formatAccessList(tx.accessList || [])];\n  if (sig) {\n    fields.push(formatNumber(sig.yParity, \"recoveryParam\"));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig.s));\n  }\n  return concat([\"0x01\", encodeRlp(fields)]);\n}\n/**\n *  A **Transaction** describes an operation to be executed on\n *  Ethereum by an Externally Owned Account (EOA). It includes\n *  who (the [[to]] address), what (the [[data]]) and how much (the\n *  [[value]] in ether) the operation should entail.\n *\n *  @example:\n *    tx = new Transaction()\n *    //_result:\n *\n *    tx.data = \"0x1234\";\n *    //_result:\n */\nvar _type = /*#__PURE__*/new WeakMap();\nvar _to = /*#__PURE__*/new WeakMap();\nvar _data = /*#__PURE__*/new WeakMap();\nvar _nonce = /*#__PURE__*/new WeakMap();\nvar _gasLimit = /*#__PURE__*/new WeakMap();\nvar _gasPrice = /*#__PURE__*/new WeakMap();\nvar _maxPriorityFeePerGas = /*#__PURE__*/new WeakMap();\nvar _maxFeePerGas = /*#__PURE__*/new WeakMap();\nvar _value2 = /*#__PURE__*/new WeakMap();\nvar _chainId = /*#__PURE__*/new WeakMap();\nvar _sig = /*#__PURE__*/new WeakMap();\nvar _accessList = /*#__PURE__*/new WeakMap();\nexport var Transaction = /*#__PURE__*/function () {\n  /**\n   *  Creates a new Transaction with default values.\n   */\n  function Transaction() {\n    _classCallCheck(this, Transaction);\n    _classPrivateFieldInitSpec(this, _type, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _to, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _data, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _nonce, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _gasLimit, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _gasPrice, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _maxPriorityFeePerGas, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _maxFeePerGas, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _value2, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _chainId, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _sig, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _accessList, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _type, null);\n    _classPrivateFieldSet(this, _to, null);\n    _classPrivateFieldSet(this, _nonce, 0);\n    _classPrivateFieldSet(this, _gasLimit, BigInt(0));\n    _classPrivateFieldSet(this, _gasPrice, null);\n    _classPrivateFieldSet(this, _maxPriorityFeePerGas, null);\n    _classPrivateFieldSet(this, _maxFeePerGas, null);\n    _classPrivateFieldSet(this, _data, \"0x\");\n    _classPrivateFieldSet(this, _value2, BigInt(0));\n    _classPrivateFieldSet(this, _chainId, BigInt(0));\n    _classPrivateFieldSet(this, _sig, null);\n    _classPrivateFieldSet(this, _accessList, null);\n  }\n  /**\n   *  The transaction hash, if signed. Otherwise, ``null``.\n   */\n  _createClass(Transaction, [{\n    key: \"type\",\n    get:\n    /**\n     *  The transaction type.\n     *\n     *  If null, the type will be automatically inferred based on\n     *  explicit properties.\n     */\n    function get() {\n      return _classPrivateFieldGet(this, _type);\n    },\n    set: function set(value) {\n      switch (value) {\n        case null:\n          _classPrivateFieldSet(this, _type, null);\n          break;\n        case 0:\n        case \"legacy\":\n          _classPrivateFieldSet(this, _type, 0);\n          break;\n        case 1:\n        case \"berlin\":\n        case \"eip-2930\":\n          _classPrivateFieldSet(this, _type, 1);\n          break;\n        case 2:\n        case \"london\":\n        case \"eip-1559\":\n          _classPrivateFieldSet(this, _type, 2);\n          break;\n        default:\n          assertArgument(false, \"unsupported transaction type\", \"type\", value);\n      }\n    }\n    /**\n     *  The name of the transaction type.\n     */\n  }, {\n    key: \"typeName\",\n    get: function get() {\n      switch (this.type) {\n        case 0:\n          return \"legacy\";\n        case 1:\n          return \"eip-2930\";\n        case 2:\n          return \"eip-1559\";\n      }\n      return null;\n    }\n    /**\n     *  The ``to`` address for the transaction or ``null`` if the\n     *  transaction is an ``init`` transaction.\n     */\n  }, {\n    key: \"to\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _to);\n    },\n    set: function set(value) {\n      _classPrivateFieldSet(this, _to, value == null ? null : getAddress(value));\n    }\n    /**\n     *  The transaction nonce.\n     */\n  }, {\n    key: \"nonce\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _nonce);\n    },\n    set: function set(value) {\n      _classPrivateFieldSet(this, _nonce, getNumber(value, \"value\"));\n    }\n    /**\n     *  The gas limit.\n     */\n  }, {\n    key: \"gasLimit\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _gasLimit);\n    },\n    set: function set(value) {\n      _classPrivateFieldSet(this, _gasLimit, getBigInt(value));\n    }\n    /**\n     *  The gas price.\n     *\n     *  On legacy networks this defines the fee that will be paid. On\n     *  EIP-1559 networks, this should be ``null``.\n     */\n  }, {\n    key: \"gasPrice\",\n    get: function get() {\n      var value = _classPrivateFieldGet(this, _gasPrice);\n      if (value == null && (this.type === 0 || this.type === 1)) {\n        return BN_0;\n      }\n      return value;\n    },\n    set: function set(value) {\n      _classPrivateFieldSet(this, _gasPrice, value == null ? null : getBigInt(value, \"gasPrice\"));\n    }\n    /**\n     *  The maximum priority fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */\n  }, {\n    key: \"maxPriorityFeePerGas\",\n    get: function get() {\n      var value = _classPrivateFieldGet(this, _maxPriorityFeePerGas);\n      if (value == null) {\n        if (this.type === 2) {\n          return BN_0;\n        }\n        return null;\n      }\n      return value;\n    },\n    set: function set(value) {\n      _classPrivateFieldSet(this, _maxPriorityFeePerGas, value == null ? null : getBigInt(value, \"maxPriorityFeePerGas\"));\n    }\n    /**\n     *  The maximum total fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */\n  }, {\n    key: \"maxFeePerGas\",\n    get: function get() {\n      var value = _classPrivateFieldGet(this, _maxFeePerGas);\n      if (value == null) {\n        if (this.type === 2) {\n          return BN_0;\n        }\n        return null;\n      }\n      return value;\n    },\n    set: function set(value) {\n      _classPrivateFieldSet(this, _maxFeePerGas, value == null ? null : getBigInt(value, \"maxFeePerGas\"));\n    }\n    /**\n     *  The transaction data. For ``init`` transactions this is the\n     *  deployment code.\n     */\n  }, {\n    key: \"data\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _data);\n    },\n    set: function set(value) {\n      _classPrivateFieldSet(this, _data, hexlify(value));\n    }\n    /**\n     *  The amount of ether to send in this transactions.\n     */\n  }, {\n    key: \"value\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _value2);\n    },\n    set: function set(value) {\n      _classPrivateFieldSet(this, _value2, getBigInt(value, \"value\"));\n    }\n    /**\n     *  The chain ID this transaction is valid on.\n     */\n  }, {\n    key: \"chainId\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _chainId);\n    },\n    set: function set(value) {\n      _classPrivateFieldSet(this, _chainId, getBigInt(value));\n    }\n    /**\n     *  If signed, the signature for this transaction.\n     */\n  }, {\n    key: \"signature\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _sig) || null;\n    },\n    set: function set(value) {\n      _classPrivateFieldSet(this, _sig, value == null ? null : Signature.from(value));\n    }\n    /**\n     *  The access list.\n     *\n     *  An access list permits discounted (but pre-paid) access to\n     *  bytecode and state variable access within contract execution.\n     */\n  }, {\n    key: \"accessList\",\n    get: function get() {\n      var value = _classPrivateFieldGet(this, _accessList) || null;\n      if (value == null) {\n        if (this.type === 1 || this.type === 2) {\n          return [];\n        }\n        return null;\n      }\n      return value;\n    },\n    set: function set(value) {\n      _classPrivateFieldSet(this, _accessList, value == null ? null : accessListify(value));\n    }\n  }, {\n    key: \"hash\",\n    get: function get() {\n      if (this.signature == null) {\n        return null;\n      }\n      return keccak256(this.serialized);\n    }\n    /**\n     *  The pre-image hash of this transaction.\n     *\n     *  This is the digest that a [[Signer]] must sign to authorize\n     *  this transaction.\n     */\n  }, {\n    key: \"unsignedHash\",\n    get: function get() {\n      return keccak256(this.unsignedSerialized);\n    }\n    /**\n     *  The sending address, if signed. Otherwise, ``null``.\n     */\n  }, {\n    key: \"from\",\n    get: function get() {\n      if (this.signature == null) {\n        return null;\n      }\n      return recoverAddress(this.unsignedHash, this.signature);\n    }\n    /**\n     *  The public key of the sender, if signed. Otherwise, ``null``.\n     */\n  }, {\n    key: \"fromPublicKey\",\n    get: function get() {\n      if (this.signature == null) {\n        return null;\n      }\n      return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);\n    }\n    /**\n     *  Returns true if signed.\n     *\n     *  This provides a Type Guard that properties requiring a signed\n     *  transaction are non-null.\n     */\n  }, {\n    key: \"isSigned\",\n    value: function isSigned() {\n      //isSigned(): this is SignedTransaction {\n      return this.signature != null;\n    }\n    /**\n     *  The serialized transaction.\n     *\n     *  This throws if the transaction is unsigned. For the pre-image,\n     *  use [[unsignedSerialized]].\n     */\n  }, {\n    key: \"serialized\",\n    get: function get() {\n      assert(this.signature != null, \"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\", \"UNSUPPORTED_OPERATION\", {\n        operation: \".serialized\"\n      });\n      switch (this.inferType()) {\n        case 0:\n          return _serializeLegacy(this, this.signature);\n        case 1:\n          return _serializeEip2930(this, this.signature);\n        case 2:\n          return _serializeEip1559(this, this.signature);\n      }\n      assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n        operation: \".serialized\"\n      });\n    }\n    /**\n     *  The transaction pre-image.\n     *\n     *  The hash of this is the digest which needs to be signed to\n     *  authorize this transaction.\n     */\n  }, {\n    key: \"unsignedSerialized\",\n    get: function get() {\n      switch (this.inferType()) {\n        case 0:\n          return _serializeLegacy(this);\n        case 1:\n          return _serializeEip2930(this);\n        case 2:\n          return _serializeEip1559(this);\n      }\n      assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n        operation: \".unsignedSerialized\"\n      });\n    }\n    /**\n     *  Return the most \"likely\" type; currently the highest\n     *  supported transaction type.\n     */\n  }, {\n    key: \"inferType\",\n    value: function inferType() {\n      return this.inferTypes().pop();\n    }\n    /**\n     *  Validates the explicit properties and returns a list of compatible\n     *  transaction types.\n     */\n  }, {\n    key: \"inferTypes\",\n    value: function inferTypes() {\n      // Checks that there are no conflicting properties set\n      var hasGasPrice = this.gasPrice != null;\n      var hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;\n      var hasAccessList = this.accessList != null;\n      //if (hasGasPrice && hasFee) {\n      //    throw new Error(\"transaction cannot have gasPrice and maxFeePerGas\");\n      //}\n      if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {\n        assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, \"priorityFee cannot be more than maxFee\", \"BAD_DATA\", {\n          value: this\n        });\n      }\n      //if (this.type === 2 && hasGasPrice) {\n      //    throw new Error(\"eip-1559 transaction cannot have gasPrice\");\n      //}\n      assert(!hasFee || this.type !== 0 && this.type !== 1, \"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\", \"BAD_DATA\", {\n        value: this\n      });\n      assert(this.type !== 0 || !hasAccessList, \"legacy transaction cannot have accessList\", \"BAD_DATA\", {\n        value: this\n      });\n      var types = [];\n      // Explicit type\n      if (this.type != null) {\n        types.push(this.type);\n      } else {\n        if (hasFee) {\n          types.push(2);\n        } else if (hasGasPrice) {\n          types.push(1);\n          if (!hasAccessList) {\n            types.push(0);\n          }\n        } else if (hasAccessList) {\n          types.push(1);\n          types.push(2);\n        } else {\n          types.push(0);\n          types.push(1);\n          types.push(2);\n        }\n      }\n      types.sort();\n      return types;\n    }\n    /**\n     *  Returns true if this transaction is a legacy transaction (i.e.\n     *  ``type === 0``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n  }, {\n    key: \"isLegacy\",\n    value: function isLegacy() {\n      return this.type === 0;\n    }\n    /**\n     *  Returns true if this transaction is berlin hardform transaction (i.e.\n     *  ``type === 1``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n  }, {\n    key: \"isBerlin\",\n    value: function isBerlin() {\n      return this.type === 1;\n    }\n    /**\n     *  Returns true if this transaction is london hardform transaction (i.e.\n     *  ``type === 2``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n  }, {\n    key: \"isLondon\",\n    value: function isLondon() {\n      return this.type === 2;\n    }\n    /**\n     *  Create a copy of this transaciton.\n     */\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return Transaction.from(this);\n    }\n    /**\n     *  Return a JSON-friendly object.\n     */\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var s = function s(v) {\n        if (v == null) {\n          return null;\n        }\n        return v.toString();\n      };\n      return {\n        type: this.type,\n        to: this.to,\n        //            from: this.from,\n        data: this.data,\n        nonce: this.nonce,\n        gasLimit: s(this.gasLimit),\n        gasPrice: s(this.gasPrice),\n        maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),\n        maxFeePerGas: s(this.maxFeePerGas),\n        value: s(this.value),\n        chainId: s(this.chainId),\n        sig: this.signature ? this.signature.toJSON() : null,\n        accessList: this.accessList\n      };\n    }\n    /**\n     *  Create a **Transaction** from a serialized transaction or a\n     *  Transaction-like object.\n     */\n  }], [{\n    key: \"from\",\n    value: function from(tx) {\n      if (tx == null) {\n        return new Transaction();\n      }\n      if (typeof tx === \"string\") {\n        var payload = getBytes(tx);\n        if (payload[0] >= 0x7f) {\n          // @TODO: > vs >= ??\n          return Transaction.from(_parseLegacy(payload));\n        }\n        switch (payload[0]) {\n          case 1:\n            return Transaction.from(_parseEip2930(payload));\n          case 2:\n            return Transaction.from(_parseEip1559(payload));\n        }\n        assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", {\n          operation: \"from\"\n        });\n      }\n      var result = new Transaction();\n      if (tx.type != null) {\n        result.type = tx.type;\n      }\n      if (tx.to != null) {\n        result.to = tx.to;\n      }\n      if (tx.nonce != null) {\n        result.nonce = tx.nonce;\n      }\n      if (tx.gasLimit != null) {\n        result.gasLimit = tx.gasLimit;\n      }\n      if (tx.gasPrice != null) {\n        result.gasPrice = tx.gasPrice;\n      }\n      if (tx.maxPriorityFeePerGas != null) {\n        result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n      }\n      if (tx.maxFeePerGas != null) {\n        result.maxFeePerGas = tx.maxFeePerGas;\n      }\n      if (tx.data != null) {\n        result.data = tx.data;\n      }\n      if (tx.value != null) {\n        result.value = tx.value;\n      }\n      if (tx.chainId != null) {\n        result.chainId = tx.chainId;\n      }\n      if (tx.signature != null) {\n        result.signature = Signature.from(tx.signature);\n      }\n      if (tx.accessList != null) {\n        result.accessList = tx.accessList;\n      }\n      if (tx.hash != null) {\n        assertArgument(result.isSigned(), \"unsigned transaction cannot define hash\", \"tx\", tx);\n        assertArgument(result.hash === tx.hash, \"hash mismatch\", \"tx\", tx);\n      }\n      if (tx.from != null) {\n        assertArgument(result.isSigned(), \"unsigned transaction cannot define from\", \"tx\", tx);\n        assertArgument(result.from.toLowerCase() === (tx.from || \"\").toLowerCase(), \"from mismatch\", \"tx\", tx);\n      }\n      return result;\n    }\n  }]);\n  return Transaction;\n}();","map":{"version":3,"names":["getAddress","keccak256","Signature","SigningKey","concat","decodeRlp","encodeRlp","getBytes","getBigInt","getNumber","hexlify","assert","assertArgument","toBeArray","zeroPadValue","accessListify","recoverAddress","BN_0","BigInt","BN_2","BN_27","BN_28","BN_35","BN_MAX_UINT","handleAddress","value","handleAccessList","param","error","message","handleNumber","_value","handleUint","formatNumber","name","result","length","formatAccessList","map","set","address","storageKeys","_parseLegacy","data","fields","Array","isArray","tx","type","nonce","gasPrice","gasLimit","to","chainId","v","r","s","signature","from","hash","_serializeLegacy","sig","networkV","legacyChainId","legacy","push","yParity","getChainIdV","_parseEipSignature","serialize","Error","_parseEip1559","slice","maxPriorityFeePerGas","maxFeePerGas","accessList","_serializeEip1559","_parseEip2930","_serializeEip2930","_type","WeakMap","_to","_data","_nonce","_gasLimit","_gasPrice","_maxPriorityFeePerGas","_maxFeePerGas","_value2","_chainId","_sig","_accessList","Transaction","_classCallCheck","_classPrivateFieldInitSpec","writable","_classPrivateFieldSet","_createClass","key","get","_classPrivateFieldGet","serialized","unsignedSerialized","unsignedHash","recoverPublicKey","isSigned","operation","inferType","inferTypes","pop","hasGasPrice","hasFee","hasAccessList","types","sort","isLegacy","isBerlin","isLondon","clone","toJSON","toString","payload","toLowerCase"],"sources":["C:\\Users\\Oguzhan\\Desktop\\BlockGuard\\mwallet\\node_modules\\ethers\\src.ts\\transaction\\transaction.ts"],"sourcesContent":["\nimport { getAddress } from \"../address/index.js\";\nimport { keccak256, Signature, SigningKey } from \"../crypto/index.js\";\nimport {\n    concat, decodeRlp, encodeRlp, getBytes, getBigInt, getNumber, hexlify,\n    assert, assertArgument, toBeArray, zeroPadValue\n} from \"../utils/index.js\";\n\nimport { accessListify } from \"./accesslist.js\";\nimport { recoverAddress } from \"./address.js\";\n\nimport type { BigNumberish, BytesLike } from \"../utils/index.js\";\nimport type { SignatureLike } from \"../crypto/index.js\";\n\nimport type { AccessList, AccessListish } from \"./index.js\";\n\n\nconst BN_0 = BigInt(0);\nconst BN_2 = BigInt(2);\nconst BN_27 = BigInt(27)\nconst BN_28 = BigInt(28)\nconst BN_35 = BigInt(35);\nconst BN_MAX_UINT = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\nexport interface TransactionLike<A = string> {\n    /**\n     *  The type.\n     */\n    type?: null | number;\n\n    /**\n     *  The recipient address or ``null`` for an ``init`` transaction.\n     */\n    to?: null | A;\n\n    /**\n     *  The sender.\n     */\n    from?: null | A;\n\n    /**\n     *  The nonce.\n     */\n    nonce?: null | number;\n\n    /**\n     *  The maximum amount of gas that can be used.\n     */\n    gasLimit?: null | BigNumberish;\n\n    /**\n     *  The gas price for legacy and berlin transactions.\n     */\n    gasPrice?: null | BigNumberish;\n\n    /**\n     *  The maximum priority fee per gas for london transactions.\n     */\n    maxPriorityFeePerGas?: null | BigNumberish;\n\n    /**\n     *  The maximum total fee per gas for london transactions.\n     */\n    maxFeePerGas?: null | BigNumberish;\n\n    /**\n     *  The data.\n     */\n    data?: null | string;\n\n    /**\n     *  The value (in wei) to send.\n     */\n    value?: null | BigNumberish;\n\n    /**\n     *  The chain ID the transaction is valid on.\n     */\n    chainId?: null | BigNumberish;\n\n    /**\n     *  The transaction hash.\n     */\n    hash?: null | string;\n\n    /**\n     *  The signature provided by the sender.\n     */\n    signature?: null | SignatureLike;\n\n    /**\n     *  The access list for berlin and london transactions.\n     */\n    accessList?: null | AccessListish;\n}\n\nfunction handleAddress(value: string): null | string {\n    if (value === \"0x\") { return null; }\n    return getAddress(value);\n}\n\nfunction handleAccessList(value: any, param: string): AccessList {\n    try {\n        return accessListify(value);\n    } catch (error: any) {\n        assertArgument(false, error.message, param, value);\n    }\n}\n\nfunction handleNumber(_value: string, param: string): number {\n    if (_value === \"0x\") { return 0; }\n    return getNumber(_value, param);\n}\n\nfunction handleUint(_value: string, param: string): bigint {\n    if (_value === \"0x\") { return BN_0; }\n    const value = getBigInt(_value, param);\n    assertArgument(value <= BN_MAX_UINT, \"value exceeds uint size\", param, value);\n    return value;\n}\n\nfunction formatNumber(_value: BigNumberish, name: string): Uint8Array {\n    const value = getBigInt(_value, \"value\");\n    const result = toBeArray(value);\n    assertArgument(result.length <= 32, `value too large`, `tx.${ name }`, value);\n    return result;\n}\n\nfunction formatAccessList(value: AccessListish): Array<[ string, Array<string> ]> {\n    return accessListify(value).map((set) => [ set.address, set.storageKeys ]);\n}\n\nfunction _parseLegacy(data: Uint8Array): TransactionLike {\n    const fields: any = decodeRlp(data);\n\n    assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6),\n        \"invalid field count for legacy transaction\", \"data\", data);\n\n    const tx: TransactionLike = {\n        type:     0,\n        nonce:    handleNumber(fields[0], \"nonce\"),\n        gasPrice: handleUint(fields[1], \"gasPrice\"),\n        gasLimit: handleUint(fields[2], \"gasLimit\"),\n        to:       handleAddress(fields[3]),\n        value:    handleUint(fields[4], \"value\"),\n        data:     hexlify(fields[5]),\n        chainId:  BN_0\n    };\n\n    // Legacy unsigned transaction\n    if (fields.length === 6) { return tx; }\n\n    const v = handleUint(fields[6], \"v\");\n    const r = handleUint(fields[7], \"r\");\n    const s = handleUint(fields[8], \"s\");\n\n    if (r === BN_0 && s === BN_0) {\n        // EIP-155 unsigned transaction\n        tx.chainId = v;\n\n    } else {\n\n        // Compute the EIP-155 chain ID (or 0 for legacy)\n        let chainId = (v - BN_35) / BN_2;\n        if (chainId < BN_0) { chainId = BN_0; }\n        tx.chainId = chainId\n\n        // Signed Legacy Transaction\n        assertArgument(chainId !== BN_0 || (v === BN_27 || v === BN_28), \"non-canonical legacy v\", \"v\", fields[6]);\n\n        tx.signature = Signature.from({\n            r: zeroPadValue(fields[7], 32),\n            s: zeroPadValue(fields[8], 32),\n            v\n        });\n\n        tx.hash = keccak256(data);\n    }\n\n    return tx;\n}\n\nfunction _serializeLegacy(tx: Transaction, sig?: Signature): string {\n    const fields: Array<any> = [\n        formatNumber(tx.nonce || 0, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit || 0, \"gasLimit\"),\n        ((tx.to != null) ? getAddress(tx.to): \"0x\"),\n        formatNumber(tx.value || 0, \"value\"),\n        (tx.data || \"0x\"),\n    ];\n\n    let chainId = BN_0;\n    if (tx.chainId != BN_0) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = getBigInt(tx.chainId, \"tx.chainId\");\n\n        // We have a chainId in the tx and an EIP-155 v in the signature,\n        // make sure they agree with each other\n        assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId,\n             \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n\n    } else if (tx.signature) {\n        // No explicit chainId, but EIP-155 have a derived implicit chainId\n        const legacy = tx.signature.legacyChainId;\n        if (legacy != null) { chainId = legacy; }\n    }\n\n    // Requesting an unsigned transaction\n    if (!sig) {\n        // We have an EIP-155 transaction (chainId was specified and non-zero)\n        if (chainId !== BN_0) {\n            fields.push(toBeArray(chainId));\n            fields.push(\"0x\");\n            fields.push(\"0x\");\n        }\n\n        return encodeRlp(fields);\n    }\n\n    // @TODO: We should probably check that tx.signature, chainId, and sig\n    //        match but that logic could break existing code, so schedule\n    //        this for the next major bump.\n\n    // Compute the EIP-155 v\n    let v = BigInt(27 + sig.yParity);\n    if (chainId !== BN_0) {\n        v = Signature.getChainIdV(chainId, sig.v);\n    } else if (BigInt(sig.v) !== v) {\n        assertArgument(false, \"tx.chainId/sig.v mismatch\", \"sig\", sig);\n    }\n\n    // Add the signature\n    fields.push(toBeArray(v));\n    fields.push(toBeArray(sig.r));\n    fields.push(toBeArray(sig.s));\n\n    return encodeRlp(fields);\n}\n\nfunction _parseEipSignature(tx: TransactionLike, fields: Array<string>, serialize: (tx: TransactionLike) => string): void {\n    let yParity: number;\n    try {\n        yParity = handleNumber(fields[0], \"yParity\");\n        if (yParity !== 0 && yParity !== 1) { throw new Error(\"bad yParity\"); }\n    } catch (error) {\n        assertArgument(false, \"invalid yParity\", \"yParity\", fields[0]);\n    }\n\n    const r = zeroPadValue(fields[1], 32);\n    const s = zeroPadValue(fields[2], 32);\n\n    const signature = Signature.from({ r, s, yParity });\n    tx.signature = signature;\n}\n\nfunction _parseEip1559(data: Uint8Array): TransactionLike {\n    const fields: any = decodeRlp(getBytes(data).slice(1));\n\n    assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12),\n        \"invalid field count for transaction type: 2\", \"data\", hexlify(data));\n\n    const maxPriorityFeePerGas = handleUint(fields[2], \"maxPriorityFeePerGas\");\n    const maxFeePerGas = handleUint(fields[3], \"maxFeePerGas\");\n    const tx: TransactionLike = {\n        type:                  2,\n        chainId:               handleUint(fields[0], \"chainId\"),\n        nonce:                 handleNumber(fields[1], \"nonce\"),\n        maxPriorityFeePerGas:  maxPriorityFeePerGas,\n        maxFeePerGas:          maxFeePerGas,\n        gasPrice:              null,\n        gasLimit:              handleUint(fields[4], \"gasLimit\"),\n        to:                    handleAddress(fields[5]),\n        value:                 handleUint(fields[6], \"value\"),\n        data:                  hexlify(fields[7]),\n        accessList:            handleAccessList(fields[8], \"accessList\"),\n    };\n\n    // Unsigned EIP-1559 Transaction\n    if (fields.length === 9) { return tx; }\n\n    tx.hash = keccak256(data);\n\n    _parseEipSignature(tx, fields.slice(9), _serializeEip1559);\n\n    return tx;\n}\n\nfunction _serializeEip1559(tx: TransactionLike, sig?: Signature): string {\n    const fields: Array<any> = [\n        formatNumber(tx.chainId || 0, \"chainId\"),\n        formatNumber(tx.nonce || 0, \"nonce\"),\n        formatNumber(tx.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(tx.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(tx.gasLimit || 0, \"gasLimit\"),\n        ((tx.to != null) ? getAddress(tx.to): \"0x\"),\n        formatNumber(tx.value || 0, \"value\"),\n        (tx.data || \"0x\"),\n        (formatAccessList(tx.accessList || []))\n    ];\n\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"yParity\"));\n        fields.push(toBeArray(sig.r));\n        fields.push(toBeArray(sig.s));\n    }\n\n    return concat([ \"0x02\", encodeRlp(fields)]);\n}\n\nfunction _parseEip2930(data: Uint8Array): TransactionLike {\n    const fields: any = decodeRlp(getBytes(data).slice(1));\n\n    assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11),\n        \"invalid field count for transaction type: 1\", \"data\", hexlify(data));\n\n    const tx: TransactionLike = {\n        type:       1,\n        chainId:    handleUint(fields[0], \"chainId\"),\n        nonce:      handleNumber(fields[1], \"nonce\"),\n        gasPrice:   handleUint(fields[2], \"gasPrice\"),\n        gasLimit:   handleUint(fields[3], \"gasLimit\"),\n        to:         handleAddress(fields[4]),\n        value:      handleUint(fields[5], \"value\"),\n        data:       hexlify(fields[6]),\n        accessList: handleAccessList(fields[7], \"accessList\")\n    };\n\n    // Unsigned EIP-2930 Transaction\n    if (fields.length === 8) { return tx; }\n\n    tx.hash = keccak256(data);\n\n    _parseEipSignature(tx, fields.slice(8), _serializeEip2930);\n\n    return tx;\n}\n\nfunction _serializeEip2930(tx: TransactionLike, sig?: Signature): string {\n    const fields: any = [\n        formatNumber(tx.chainId || 0, \"chainId\"),\n        formatNumber(tx.nonce || 0, \"nonce\"),\n        formatNumber(tx.gasPrice || 0, \"gasPrice\"),\n        formatNumber(tx.gasLimit || 0, \"gasLimit\"),\n        ((tx.to != null) ? getAddress(tx.to): \"0x\"),\n        formatNumber(tx.value || 0, \"value\"),\n        (tx.data || \"0x\"),\n        (formatAccessList(tx.accessList || []))\n    ];\n\n    if (sig) {\n        fields.push(formatNumber(sig.yParity, \"recoveryParam\"));\n        fields.push(toBeArray(sig.r));\n        fields.push(toBeArray(sig.s));\n    }\n\n    return concat([ \"0x01\", encodeRlp(fields)]);\n}\n\n/**\n *  A **Transaction** describes an operation to be executed on\n *  Ethereum by an Externally Owned Account (EOA). It includes\n *  who (the [[to]] address), what (the [[data]]) and how much (the\n *  [[value]] in ether) the operation should entail.\n *\n *  @example:\n *    tx = new Transaction()\n *    //_result:\n *\n *    tx.data = \"0x1234\";\n *    //_result:\n */\nexport class Transaction implements TransactionLike<string> {\n    #type: null | number;\n    #to: null | string;\n    #data: string;\n    #nonce: number;\n    #gasLimit: bigint;\n    #gasPrice: null | bigint;\n    #maxPriorityFeePerGas: null | bigint;\n    #maxFeePerGas: null | bigint;\n    #value: bigint;\n    #chainId: bigint;\n    #sig: null | Signature;\n    #accessList: null | AccessList;\n\n    /**\n     *  The transaction type.\n     *\n     *  If null, the type will be automatically inferred based on\n     *  explicit properties.\n     */\n    get type(): null | number { return this.#type; }\n    set type(value: null | number | string) {\n        switch (value) {\n            case null:\n                this.#type = null;\n                break;\n            case 0: case \"legacy\":\n                this.#type = 0;\n                break;\n            case 1: case \"berlin\": case \"eip-2930\":\n                this.#type = 1;\n                break;\n            case 2: case \"london\": case \"eip-1559\":\n                this.#type = 2;\n                break;\n            default:\n                assertArgument(false, \"unsupported transaction type\", \"type\", value);\n        }\n    }\n\n    /**\n     *  The name of the transaction type.\n     */\n    get typeName(): null | string {\n        switch (this.type) {\n            case 0: return \"legacy\";\n            case 1: return \"eip-2930\";\n            case 2: return \"eip-1559\";\n        }\n\n        return null;\n    }\n\n    /**\n     *  The ``to`` address for the transaction or ``null`` if the\n     *  transaction is an ``init`` transaction.\n     */\n    get to(): null | string { return this.#to; }\n    set to(value: null | string) {\n        this.#to = (value == null) ? null: getAddress(value);\n    }\n\n    /**\n     *  The transaction nonce.\n     */\n    get nonce(): number { return this.#nonce; }\n    set nonce(value: BigNumberish) { this.#nonce = getNumber(value, \"value\"); }\n\n    /**\n     *  The gas limit.\n     */\n    get gasLimit(): bigint { return this.#gasLimit; }\n    set gasLimit(value: BigNumberish) { this.#gasLimit = getBigInt(value); }\n\n    /**\n     *  The gas price.\n     *\n     *  On legacy networks this defines the fee that will be paid. On\n     *  EIP-1559 networks, this should be ``null``.\n     */\n    get gasPrice(): null | bigint {\n        const value = this.#gasPrice;\n        if (value == null && (this.type === 0 || this.type === 1)) { return BN_0; }\n        return value;\n    }\n    set gasPrice(value: null | BigNumberish) {\n        this.#gasPrice = (value == null) ? null: getBigInt(value, \"gasPrice\");\n    }\n\n    /**\n     *  The maximum priority fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */\n    get maxPriorityFeePerGas(): null | bigint {\n        const value = this.#maxPriorityFeePerGas;\n        if (value == null) {\n            if (this.type === 2) { return BN_0; }\n            return null;\n        }\n        return value;\n    }\n    set maxPriorityFeePerGas(value: null | BigNumberish) {\n        this.#maxPriorityFeePerGas = (value == null) ? null: getBigInt(value, \"maxPriorityFeePerGas\");\n    }\n\n    /**\n     *  The maximum total fee per unit of gas to pay. On legacy\n     *  networks this should be ``null``.\n     */\n    get maxFeePerGas(): null | bigint {\n        const value = this.#maxFeePerGas;\n        if (value == null) {\n            if (this.type === 2) { return BN_0; }\n            return null;\n        }\n        return value;\n    }\n    set maxFeePerGas(value: null | BigNumberish) {\n        this.#maxFeePerGas = (value == null) ? null: getBigInt(value, \"maxFeePerGas\");\n    }\n\n    /**\n     *  The transaction data. For ``init`` transactions this is the\n     *  deployment code.\n     */\n    get data(): string { return this.#data; }\n    set data(value: BytesLike) { this.#data = hexlify(value); }\n\n    /**\n     *  The amount of ether to send in this transactions.\n     */\n    get value(): bigint { return this.#value; }\n    set value(value: BigNumberish) {\n        this.#value = getBigInt(value, \"value\");\n    }\n\n    /**\n     *  The chain ID this transaction is valid on.\n     */\n    get chainId(): bigint { return this.#chainId; }\n    set chainId(value: BigNumberish) { this.#chainId = getBigInt(value); }\n\n    /**\n     *  If signed, the signature for this transaction.\n     */\n    get signature(): null | Signature { return this.#sig || null; }\n    set signature(value: null | SignatureLike) {\n        this.#sig = (value == null) ? null: Signature.from(value);\n    }\n\n    /**\n     *  The access list.\n     *\n     *  An access list permits discounted (but pre-paid) access to\n     *  bytecode and state variable access within contract execution.\n     */\n    get accessList(): null | AccessList {\n        const value = this.#accessList || null;\n        if (value == null) {\n            if (this.type === 1 || this.type === 2) { return [ ]; }\n            return null;\n        }\n        return value;\n    }\n    set accessList(value: null | AccessListish) {\n        this.#accessList = (value == null) ? null: accessListify(value);\n    }\n\n    /**\n     *  Creates a new Transaction with default values.\n     */\n    constructor() {\n        this.#type = null;\n        this.#to = null;\n        this.#nonce = 0;\n        this.#gasLimit = BigInt(0);\n        this.#gasPrice = null;\n        this.#maxPriorityFeePerGas = null;\n        this.#maxFeePerGas = null;\n        this.#data = \"0x\";\n        this.#value = BigInt(0);\n        this.#chainId = BigInt(0);\n        this.#sig = null;\n        this.#accessList = null;\n    }\n\n    /**\n     *  The transaction hash, if signed. Otherwise, ``null``.\n     */\n    get hash(): null | string {\n        if (this.signature == null) { return null; }\n        return keccak256(this.serialized);\n    }\n\n    /**\n     *  The pre-image hash of this transaction.\n     *\n     *  This is the digest that a [[Signer]] must sign to authorize\n     *  this transaction.\n     */\n    get unsignedHash(): string {\n        return keccak256(this.unsignedSerialized);\n    }\n\n    /**\n     *  The sending address, if signed. Otherwise, ``null``.\n     */\n    get from(): null | string {\n        if (this.signature == null) { return null; }\n        return recoverAddress(this.unsignedHash, this.signature);\n    }\n\n    /**\n     *  The public key of the sender, if signed. Otherwise, ``null``.\n     */\n    get fromPublicKey(): null | string {\n        if (this.signature == null) { return null; }\n        return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);\n    }\n\n    /**\n     *  Returns true if signed.\n     *\n     *  This provides a Type Guard that properties requiring a signed\n     *  transaction are non-null.\n     */\n    isSigned(): this is (Transaction & { type: number, typeName: string, from: string, signature: Signature }) {\n    //isSigned(): this is SignedTransaction {\n        return this.signature != null;\n    }\n\n    /**\n     *  The serialized transaction.\n     *\n     *  This throws if the transaction is unsigned. For the pre-image,\n     *  use [[unsignedSerialized]].\n     */\n    get serialized(): string {\n        assert(this.signature != null, \"cannot serialize unsigned transaction; maybe you meant .unsignedSerialized\", \"UNSUPPORTED_OPERATION\", { operation: \".serialized\"});\n\n        switch (this.inferType()) {\n            case 0:\n                return _serializeLegacy(this, this.signature);\n            case 1:\n                return _serializeEip2930(this, this.signature);\n            case 2:\n                return _serializeEip1559(this, this.signature);\n        }\n\n        assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", { operation: \".serialized\" });\n    }\n\n    /**\n     *  The transaction pre-image.\n     *\n     *  The hash of this is the digest which needs to be signed to\n     *  authorize this transaction.\n     */\n    get unsignedSerialized(): string {\n        switch (this.inferType()) {\n            case 0:\n                return _serializeLegacy(this);\n            case 1:\n                return _serializeEip2930(this);\n            case 2:\n                return _serializeEip1559(this);\n        }\n\n        assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", { operation: \".unsignedSerialized\" });\n    }\n\n    /**\n     *  Return the most \"likely\" type; currently the highest\n     *  supported transaction type.\n     */\n    inferType(): number {\n        return <number>(this.inferTypes().pop());\n    }\n\n    /**\n     *  Validates the explicit properties and returns a list of compatible\n     *  transaction types.\n     */\n    inferTypes(): Array<number> {\n\n        // Checks that there are no conflicting properties set\n        const hasGasPrice = this.gasPrice != null;\n        const hasFee = (this.maxFeePerGas != null || this.maxPriorityFeePerGas != null);\n        const hasAccessList = (this.accessList != null);\n\n        //if (hasGasPrice && hasFee) {\n        //    throw new Error(\"transaction cannot have gasPrice and maxFeePerGas\");\n        //}\n\n        if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {\n            assert(this.maxFeePerGas >= this.maxPriorityFeePerGas, \"priorityFee cannot be more than maxFee\", \"BAD_DATA\", { value: this });\n        }\n\n        //if (this.type === 2 && hasGasPrice) {\n        //    throw new Error(\"eip-1559 transaction cannot have gasPrice\");\n        //}\n\n        assert(!hasFee || (this.type !== 0 && this.type !== 1), \"transaction type cannot have maxFeePerGas or maxPriorityFeePerGas\", \"BAD_DATA\", { value: this });\n        assert(this.type !== 0 || !hasAccessList, \"legacy transaction cannot have accessList\", \"BAD_DATA\", { value: this })\n\n        const types: Array<number> = [ ];\n\n        // Explicit type\n        if (this.type != null) {\n            types.push(this.type);\n\n        } else {\n            if (hasFee) {\n                types.push(2);\n            } else if (hasGasPrice) {\n                types.push(1);\n                if (!hasAccessList) { types.push(0); }\n            } else if (hasAccessList) {\n                types.push(1);\n                types.push(2);\n            } else {\n                types.push(0);\n                types.push(1);\n                types.push(2);\n            }\n        }\n\n        types.sort();\n\n        return types;\n    }\n\n    /**\n     *  Returns true if this transaction is a legacy transaction (i.e.\n     *  ``type === 0``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isLegacy(): this is (Transaction & { type: 0, gasPrice: bigint }) {\n        return (this.type === 0);\n    }\n\n    /**\n     *  Returns true if this transaction is berlin hardform transaction (i.e.\n     *  ``type === 1``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isBerlin(): this is (Transaction & { type: 1, gasPrice: bigint, accessList: AccessList }) {\n        return (this.type === 1);\n    }\n\n    /**\n     *  Returns true if this transaction is london hardform transaction (i.e.\n     *  ``type === 2``).\n     *\n     *  This provides a Type Guard that the related properties are\n     *  non-null.\n     */\n    isLondon(): this is (Transaction & { type: 2, accessList: AccessList, maxFeePerGas: bigint, maxPriorityFeePerGas: bigint}) {\n        return (this.type === 2);\n    }\n\n    /**\n     *  Create a copy of this transaciton.\n     */\n    clone(): Transaction {\n        return Transaction.from(this);\n    }\n\n    /**\n     *  Return a JSON-friendly object.\n     */\n    toJSON(): any {\n        const s = (v: null | bigint) => {\n            if (v == null) { return null; }\n            return v.toString();\n        };\n\n        return {\n            type: this.type,\n            to: this.to,\n//            from: this.from,\n            data: this.data,\n            nonce: this.nonce,\n            gasLimit: s(this.gasLimit),\n            gasPrice: s(this.gasPrice),\n            maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),\n            maxFeePerGas: s(this.maxFeePerGas),\n            value: s(this.value),\n            chainId: s(this.chainId),\n            sig: this.signature ? this.signature.toJSON(): null,\n            accessList: this.accessList\n        };\n    }\n\n    /**\n     *  Create a **Transaction** from a serialized transaction or a\n     *  Transaction-like object.\n     */\n    static from(tx?: string | TransactionLike<string>): Transaction {\n        if (tx == null) { return new Transaction(); }\n\n        if (typeof(tx) === \"string\") {\n            const payload = getBytes(tx);\n\n            if (payload[0] >= 0x7f) { // @TODO: > vs >= ??\n                return Transaction.from(_parseLegacy(payload));\n            }\n\n            switch(payload[0]) {\n                case 1: return Transaction.from(_parseEip2930(payload));\n                case 2: return Transaction.from(_parseEip1559(payload));\n            }\n            assert(false, \"unsupported transaction type\", \"UNSUPPORTED_OPERATION\", { operation: \"from\" });\n        }\n\n        const result = new Transaction();\n        if (tx.type != null) { result.type = tx.type; }\n        if (tx.to != null) { result.to = tx.to; }\n        if (tx.nonce != null) { result.nonce = tx.nonce; }\n        if (tx.gasLimit != null) { result.gasLimit = tx.gasLimit; }\n        if (tx.gasPrice != null) { result.gasPrice = tx.gasPrice; }\n        if (tx.maxPriorityFeePerGas != null) { result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas; }\n        if (tx.maxFeePerGas != null) { result.maxFeePerGas = tx.maxFeePerGas; }\n        if (tx.data != null) { result.data = tx.data; }\n        if (tx.value != null) { result.value = tx.value; }\n        if (tx.chainId != null) { result.chainId = tx.chainId; }\n        if (tx.signature != null) { result.signature = Signature.from(tx.signature); }\n        if (tx.accessList != null) { result.accessList = tx.accessList; }\n\n        if (tx.hash != null) {\n            assertArgument(result.isSigned(), \"unsigned transaction cannot define hash\", \"tx\", tx);\n            assertArgument(result.hash === tx.hash, \"hash mismatch\", \"tx\", tx);\n        }\n\n        if (tx.from != null) {\n            assertArgument(result.isSigned(), \"unsigned transaction cannot define from\", \"tx\", tx);\n            assertArgument(result.from.toLowerCase() === (tx.from || \"\").toLowerCase(), \"from mismatch\", \"tx\", tx);\n        }\n\n        return result;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}