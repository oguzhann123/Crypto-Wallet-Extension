{"ast":null,"code":"import _classCallCheck from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classPrivateMethodInitSpec from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _defineProperty from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classPrivateMethodGet from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateMethodGet.js\";\nimport _classPrivateFieldGet from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nimport _classPrivateFieldSet from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\n/**\n *  About fixed-point math...\n *\n *  @_section: api/utils/fixed-point-math:Fixed-Point Maths  [about-fixed-point-math]\n */\nimport { getBytes } from \"./data.js\";\nimport { assert, assertArgument, assertPrivate } from \"./errors.js\";\nimport { getBigInt, fromTwos, mask, toBigInt } from \"./maths.js\";\nimport { defineProperties } from \"./properties.js\";\nvar BN_N1 = BigInt(-1);\nvar BN_0 = BigInt(0);\nvar BN_1 = BigInt(1);\nvar BN_5 = BigInt(5);\nvar _guard = {};\n// Constant to pull zeros from for multipliers\nvar Zeros = \"0000\";\nwhile (Zeros.length < 80) {\n  Zeros += Zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getTens(decimals) {\n  var result = Zeros;\n  while (result.length < decimals) {\n    result += result;\n  }\n  return BigInt(\"1\" + result.substring(0, decimals));\n}\nfunction checkValue(val, format, safeOp) {\n  var width = BigInt(format.width);\n  if (format.signed) {\n    var limit = BN_1 << width - BN_1;\n    assert(safeOp == null || val >= -limit && val < limit, \"overflow\", \"NUMERIC_FAULT\", {\n      operation: safeOp,\n      fault: \"overflow\",\n      value: val\n    });\n    if (val > BN_0) {\n      val = fromTwos(mask(val, width), width);\n    } else {\n      val = -fromTwos(mask(-val, width), width);\n    }\n  } else {\n    var _limit = BN_1 << width;\n    assert(safeOp == null || val >= 0 && val < _limit, \"overflow\", \"NUMERIC_FAULT\", {\n      operation: safeOp,\n      fault: \"overflow\",\n      value: val\n    });\n    val = (val % _limit + _limit) % _limit & _limit - BN_1;\n  }\n  return val;\n}\nfunction getFormat(value) {\n  if (typeof value === \"number\") {\n    value = \"fixed128x\".concat(value);\n  }\n  var signed = true;\n  var width = 128;\n  var decimals = 18;\n  if (typeof value === \"string\") {\n    // Parse the format string\n    if (value === \"fixed\") {\n      // defaults...\n    } else if (value === \"ufixed\") {\n      signed = false;\n    } else {\n      var match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n      assertArgument(match, \"invalid fixed format\", \"format\", value);\n      signed = match[1] !== \"u\";\n      width = parseInt(match[2]);\n      decimals = parseInt(match[3]);\n    }\n  } else if (value) {\n    // Extract the values from the object\n    var v = value;\n    var check = function check(key, type, defaultValue) {\n      if (v[key] == null) {\n        return defaultValue;\n      }\n      assertArgument(typeof v[key] === type, \"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, v[key]);\n      return v[key];\n    };\n    signed = check(\"signed\", \"boolean\", signed);\n    width = check(\"width\", \"number\", width);\n    decimals = check(\"decimals\", \"number\", decimals);\n  }\n  assertArgument(width % 8 === 0, \"invalid FixedNumber width (not byte aligned)\", \"format.width\", width);\n  assertArgument(decimals <= 80, \"invalid FixedNumber decimals (too large)\", \"format.decimals\", decimals);\n  var name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n  return {\n    signed: signed,\n    width: width,\n    decimals: decimals,\n    name: name\n  };\n}\nfunction toString(val, decimals) {\n  var negative = \"\";\n  if (val < BN_0) {\n    negative = \"-\";\n    val *= BN_N1;\n  }\n  var str = val.toString();\n  // No decimal point for whole values\n  if (decimals === 0) {\n    return negative + str;\n  }\n  // Pad out to the whole component (including a whole digit)\n  while (str.length <= decimals) {\n    str = Zeros + str;\n  }\n  // Insert the decimal point\n  var index = str.length - decimals;\n  str = str.substring(0, index) + \".\" + str.substring(index);\n  // Trim the whole component (leaving at least one 0)\n  while (str[0] === \"0\" && str[1] !== \".\") {\n    str = str.substring(1);\n  }\n  // Trim the decimal component (leaving at least one 0)\n  while (str[str.length - 1] === \"0\" && str[str.length - 2] !== \".\") {\n    str = str.substring(0, str.length - 1);\n  }\n  return negative + str;\n}\n/**\n *  A FixedNumber represents a value over its [[FixedFormat]]\n *  arithmetic field.\n *\n *  A FixedNumber can be used to perform math, losslessly, on\n *  values which have decmial places.\n *\n *  A FixedNumber has a fixed bit-width to store values in, and stores all\n *  values internally by multiplying the value by 10 raised to the power of\n *  %%decimals%%.\n *\n *  If operations are performed that cause a value to grow too high (close to\n *  positive infinity) or too low (close to negative infinity), the value\n *  is said to //overflow//.\n *\n *  For example, an 8-bit signed value, with 0 decimals may only be within\n *  the range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become\n *  ``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.\n *\n *  Many operation have a normal and //unsafe// variant. The normal variant\n *  will throw a [[NumericFaultError]] on any overflow, while the //unsafe//\n *  variant will silently allow overflow, corrupting its value value.\n *\n *  If operations are performed that cause a value to become too small\n *  (close to zero), the value loses precison and is said to //underflow//.\n *\n *  For example, an value with 1 decimal place may store a number as small\n *  as ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit\n *  into 1 decimal place, so underflow occurs which means precision is lost\n *  and the value becomes ``0``.\n *\n *  Some operations have a normal and //signalling// variant. The normal\n *  variant will silently ignore underflow, while the //signalling// variant\n *  will thow a [[NumericFaultError]] on underflow.\n */\nvar _format2 = /*#__PURE__*/new WeakMap();\nvar _val = /*#__PURE__*/new WeakMap();\nvar _tens = /*#__PURE__*/new WeakMap();\nvar _checkFormat = /*#__PURE__*/new WeakSet();\nvar _checkValue = /*#__PURE__*/new WeakSet();\nvar _add = /*#__PURE__*/new WeakSet();\nvar _sub = /*#__PURE__*/new WeakSet();\nvar _mul = /*#__PURE__*/new WeakSet();\nvar _div = /*#__PURE__*/new WeakSet();\nexport var FixedNumber = /*#__PURE__*/function () {\n  // Use this when changing this file to get some typing info,\n  // but then switch to any to mask the internal type\n  //constructor(guard: any, value: bigint, format: _FixedFormat) {\n  /**\n   *  @private\n   */\n  function FixedNumber(guard, value, format) {\n    _classCallCheck(this, FixedNumber);\n    _classPrivateMethodInitSpec(this, _div);\n    _classPrivateMethodInitSpec(this, _mul);\n    _classPrivateMethodInitSpec(this, _sub);\n    _classPrivateMethodInitSpec(this, _add);\n    _classPrivateMethodInitSpec(this, _checkValue);\n    _classPrivateMethodInitSpec(this, _checkFormat);\n    /**\n     *  The specific fixed-point arithmetic field for this value.\n     */\n    _defineProperty(this, \"format\", void 0);\n    _classPrivateFieldInitSpec(this, _format2, {\n      writable: true,\n      value: void 0\n    });\n    // The actual value (accounting for decimals)\n    _classPrivateFieldInitSpec(this, _val, {\n      writable: true,\n      value: void 0\n    });\n    // A base-10 value to multiple values by to maintain the magnitude\n    _classPrivateFieldInitSpec(this, _tens, {\n      writable: true,\n      value: void 0\n    });\n    /**\n     *  This is a property so console.log shows a human-meaningful value.\n     *\n     *  @private\n     */\n    _defineProperty(this, \"_value\", void 0);\n    assertPrivate(guard, _guard, \"FixedNumber\");\n    _classPrivateFieldSet(this, _val, value);\n    _classPrivateFieldSet(this, _format2, format);\n    var _value = toString(value, format.decimals);\n    defineProperties(this, {\n      format: format.name,\n      _value: _value\n    });\n    _classPrivateFieldSet(this, _tens, getTens(format.decimals));\n  }\n  /**\n   *  If true, negative values are permitted, otherwise only\n   *  positive values and zero are allowed.\n   */\n  _createClass(FixedNumber, [{\n    key: \"signed\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _format2).signed;\n    }\n    /**\n     *  The number of bits available to store the value.\n     */\n  }, {\n    key: \"width\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _format2).width;\n    }\n    /**\n     *  The number of decimal places in the fixed-point arithment field.\n     */\n  }, {\n    key: \"decimals\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _format2).decimals;\n    }\n    /**\n     *  The value as an integer, based on the smallest unit the\n     *  [[decimals]] allow.\n     */\n  }, {\n    key: \"value\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _val);\n    }\n  }, {\n    key: \"addUnsafe\",\n    value:\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%, ignoring overflow.\n     */\n    function addUnsafe(other) {\n      return _classPrivateMethodGet(this, _add, _add2).call(this, other);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n  }, {\n    key: \"add\",\n    value: function add(other) {\n      return _classPrivateMethodGet(this, _add, _add2).call(this, other, \"add\");\n    }\n  }, {\n    key: \"subUnsafe\",\n    value:\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%, ignoring overflow.\n     */\n    function subUnsafe(other) {\n      return _classPrivateMethodGet(this, _sub, _sub2).call(this, other);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n  }, {\n    key: \"sub\",\n    value: function sub(other) {\n      return _classPrivateMethodGet(this, _sub, _sub2).call(this, other, \"sub\");\n    }\n  }, {\n    key: \"mulUnsafe\",\n    value:\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%, ignoring overflow and underflow (precision loss).\n     */\n    function mulUnsafe(other) {\n      return _classPrivateMethodGet(this, _mul, _mul2).call(this, other);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n  }, {\n    key: \"mul\",\n    value: function mul(other) {\n      return _classPrivateMethodGet(this, _mul, _mul2).call(this, other, \"mul\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs or if underflow (precision loss) occurs.\n     */\n  }, {\n    key: \"mulSignal\",\n    value: function mulSignal(other) {\n      _classPrivateMethodGet(this, _checkFormat, _checkFormat2).call(this, other);\n      var value = _classPrivateFieldGet(this, _val) * _classPrivateFieldGet(other, _val);\n      assert(value % _classPrivateFieldGet(this, _tens) === BN_0, \"precision lost during signalling mul\", \"NUMERIC_FAULT\", {\n        operation: \"mulSignal\",\n        fault: \"underflow\",\n        value: this\n      });\n      return _classPrivateMethodGet(this, _checkValue, _checkValue2).call(this, value / _classPrivateFieldGet(this, _tens), \"mulSignal\");\n    }\n  }, {\n    key: \"divUnsafe\",\n    value:\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */\n    function divUnsafe(other) {\n      return _classPrivateMethodGet(this, _div, _div2).call(this, other);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */\n  }, {\n    key: \"div\",\n    value: function div(other) {\n      return _classPrivateMethodGet(this, _div, _div2).call(this, other, \"div\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%. A [[NumericFaultError]] is thrown if underflow\n     *  (precision loss) occurs.\n     */\n  }, {\n    key: \"divSignal\",\n    value: function divSignal(other) {\n      assert(_classPrivateFieldGet(other, _val) !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n        operation: \"div\",\n        fault: \"divide-by-zero\",\n        value: this\n      });\n      _classPrivateMethodGet(this, _checkFormat, _checkFormat2).call(this, other);\n      var value = _classPrivateFieldGet(this, _val) * _classPrivateFieldGet(this, _tens);\n      assert(value % _classPrivateFieldGet(other, _val) === BN_0, \"precision lost during signalling div\", \"NUMERIC_FAULT\", {\n        operation: \"divSignal\",\n        fault: \"underflow\",\n        value: this\n      });\n      return _classPrivateMethodGet(this, _checkValue, _checkValue2).call(this, value / _classPrivateFieldGet(other, _val), \"divSignal\");\n    }\n    /**\n     *  Returns a comparison result between %%this%% and %%other%%.\n     *\n     *  This is suitable for use in sorting, where ``-1`` implies %%this%%\n     *  is smaller, ``1`` implies %%other%% is larger and ``0`` implies\n     *  both are equal.\n     */\n  }, {\n    key: \"cmp\",\n    value: function cmp(other) {\n      var a = this.value,\n        b = other.value;\n      // Coerce a and b to the same magnitude\n      var delta = this.decimals - other.decimals;\n      if (delta > 0) {\n        b *= getTens(delta);\n      } else if (delta < 0) {\n        a *= getTens(-delta);\n      }\n      // Comnpare\n      if (a < b) {\n        return -1;\n      }\n      if (a > b) {\n        return -1;\n      }\n      return 0;\n    }\n    /**\n     *  Returns true if %%other%% is equal to %%this%%.\n     */\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return this.cmp(other) === 0;\n    }\n    /**\n     *  Returns true if %%other%% is less than to %%this%%.\n     */\n  }, {\n    key: \"lt\",\n    value: function lt(other) {\n      return this.cmp(other) < 0;\n    }\n    /**\n     *  Returns true if %%other%% is less than or equal to %%this%%.\n     */\n  }, {\n    key: \"lte\",\n    value: function lte(other) {\n      return this.cmp(other) <= 0;\n    }\n    /**\n     *  Returns true if %%other%% is greater than to %%this%%.\n     */\n  }, {\n    key: \"gt\",\n    value: function gt(other) {\n      return this.cmp(other) > 0;\n    }\n    /**\n     *  Returns true if %%other%% is greater than or equal to %%this%%.\n     */\n  }, {\n    key: \"gte\",\n    value: function gte(other) {\n      return this.cmp(other) >= 0;\n    }\n    /**\n     *  Returns a new [[FixedNumber]] which is the largest **integer**\n     *  that is less than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */\n  }, {\n    key: \"floor\",\n    value: function floor() {\n      var val = _classPrivateFieldGet(this, _val);\n      if (_classPrivateFieldGet(this, _val) < BN_0) {\n        val -= _classPrivateFieldGet(this, _tens) - BN_1;\n      }\n      val = _classPrivateFieldGet(this, _val) / _classPrivateFieldGet(this, _tens) * _classPrivateFieldGet(this, _tens);\n      return _classPrivateMethodGet(this, _checkValue, _checkValue2).call(this, val, \"floor\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] which is the smallest **integer**\n     *  that is greater than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */\n  }, {\n    key: \"ceiling\",\n    value: function ceiling() {\n      var val = _classPrivateFieldGet(this, _val);\n      if (_classPrivateFieldGet(this, _val) > BN_0) {\n        val += _classPrivateFieldGet(this, _tens) - BN_1;\n      }\n      val = _classPrivateFieldGet(this, _val) / _classPrivateFieldGet(this, _tens) * _classPrivateFieldGet(this, _tens);\n      return _classPrivateMethodGet(this, _checkValue, _checkValue2).call(this, val, \"ceiling\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the decimal component\n     *  rounded up on ties at %%decimals%% places.\n     */\n  }, {\n    key: \"round\",\n    value: function round(decimals) {\n      if (decimals == null) {\n        decimals = 0;\n      }\n      // Not enough precision to not already be rounded\n      if (decimals >= this.decimals) {\n        return this;\n      }\n      var delta = this.decimals - decimals;\n      var bump = BN_5 * getTens(delta - 1);\n      var value = this.value + bump;\n      var tens = getTens(delta);\n      value = value / tens * tens;\n      checkValue(value, _classPrivateFieldGet(this, _format2), \"round\");\n      return new FixedNumber(_guard, value, _classPrivateFieldGet(this, _format2));\n    }\n    /**\n     *  Returns true if %%this%% is equal to ``0``.\n     */\n  }, {\n    key: \"isZero\",\n    value: function isZero() {\n      return _classPrivateFieldGet(this, _val) === BN_0;\n    }\n    /**\n     *  Returns true if %%this%% is less than ``0``.\n     */\n  }, {\n    key: \"isNegative\",\n    value: function isNegative() {\n      return _classPrivateFieldGet(this, _val) < BN_0;\n    }\n    /**\n     *  Returns the string representation of %%this%%.\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this._value;\n    }\n    /**\n     *  Returns a float approximation.\n     *\n     *  Due to IEEE 754 precission (or lack thereof), this function\n     *  can only return an approximation and most values will contain\n     *  rounding errors.\n     */\n  }, {\n    key: \"toUnsafeFloat\",\n    value: function toUnsafeFloat() {\n      return parseFloat(this.toString());\n    }\n    /**\n     *  Return a new [[FixedNumber]] with the same value but has had\n     *  its field set to %%format%%.\n     *\n     *  This will throw if the value cannot fit into %%format%%.\n     */\n  }, {\n    key: \"toFormat\",\n    value: function toFormat(format) {\n      return FixedNumber.fromString(this.toString(), format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% divided by\n     *  %%decimal%% places with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted\n     *  for %%decimals%%) cannot fit in %%format%%, either due to overflow\n     *  or underflow (precision loss).\n     */\n  }], [{\n    key: \"fromValue\",\n    value: function fromValue(_value, decimals, _format) {\n      if (decimals == null) {\n        decimals = 0;\n      }\n      var format = getFormat(_format);\n      var value = getBigInt(_value, \"value\");\n      var delta = decimals - format.decimals;\n      if (delta > 0) {\n        var tens = getTens(delta);\n        assert(value % tens === BN_0, \"value loses precision for format\", \"NUMERIC_FAULT\", {\n          operation: \"fromValue\",\n          fault: \"underflow\",\n          value: _value\n        });\n        value /= tens;\n      } else if (delta < 0) {\n        value *= getTens(-delta);\n      }\n      checkValue(value, format, \"fromValue\");\n      return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%%, either due to overflow or underflow (precision loss).\n     */\n  }, {\n    key: \"fromString\",\n    value: function fromString(_value, _format) {\n      var match = _value.match(/^(-?)([0-9]*)\\.?([0-9]*)$/);\n      assertArgument(match && match[2].length + match[3].length > 0, \"invalid FixedNumber string value\", \"value\", _value);\n      var format = getFormat(_format);\n      var whole = match[2] || \"0\",\n        decimal = match[3] || \"\";\n      // Pad out the decimals\n      while (decimal.length < format.decimals) {\n        decimal += Zeros;\n      }\n      // Check precision is safe\n      assert(decimal.substring(format.decimals).match(/^0*$/), \"too many decimals for format\", \"NUMERIC_FAULT\", {\n        operation: \"fromString\",\n        fault: \"underflow\",\n        value: _value\n      });\n      // Remove extra padding\n      decimal = decimal.substring(0, format.decimals);\n      var value = BigInt(match[1] + whole + decimal);\n      checkValue(value, format, \"fromString\");\n      return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] with the big-endian representation\n     *  %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%% due to overflow.\n     */\n  }, {\n    key: \"fromBytes\",\n    value: function fromBytes(_value, _format) {\n      var value = toBigInt(getBytes(_value, \"value\"));\n      var format = getFormat(_format);\n      if (format.signed) {\n        value = fromTwos(value, format.width);\n      }\n      checkValue(value, format, \"fromBytes\");\n      return new FixedNumber(_guard, value, format);\n    }\n  }]);\n  return FixedNumber;\n}();\n//const f1 = FixedNumber.fromString(\"12.56\", \"fixed16x2\");\n//const f2 = FixedNumber.fromString(\"0.3\", \"fixed16x2\");\n//console.log(f1.divSignal(f2));\n//const BUMP = FixedNumber.from(\"0.5\");\nfunction _checkFormat2(other) {\n  assertArgument(this.format === other.format, \"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n}\nfunction _checkValue2(val, safeOp) {\n  /*\n          const width = BigInt(this.width);\n          if (this.signed) {\n              const limit = (BN_1 << (width - BN_1));\n              assert(safeOp == null || (val >= -limit  && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n                  operation: <string>safeOp, fault: \"overflow\", value: val\n              });\n  \n              if (val > BN_0) {\n                  val = fromTwos(mask(val, width), width);\n              } else {\n                  val = -fromTwos(mask(-val, width), width);\n              }\n  \n          } else {\n              const masked = mask(val, width);\n              assert(safeOp == null || (val >= 0 && val === masked), \"overflow\", \"NUMERIC_FAULT\", {\n                  operation: <string>safeOp, fault: \"overflow\", value: val\n              });\n              val = masked;\n          }\n  */\n  val = checkValue(val, _classPrivateFieldGet(this, _format2), safeOp);\n  return new FixedNumber(_guard, val, _classPrivateFieldGet(this, _format2));\n}\nfunction _add2(o, safeOp) {\n  _classPrivateMethodGet(this, _checkFormat, _checkFormat2).call(this, o);\n  return _classPrivateMethodGet(this, _checkValue, _checkValue2).call(this, _classPrivateFieldGet(this, _val) + _classPrivateFieldGet(o, _val), safeOp);\n}\nfunction _sub2(o, safeOp) {\n  _classPrivateMethodGet(this, _checkFormat, _checkFormat2).call(this, o);\n  return _classPrivateMethodGet(this, _checkValue, _checkValue2).call(this, _classPrivateFieldGet(this, _val) - _classPrivateFieldGet(o, _val), safeOp);\n}\nfunction _mul2(o, safeOp) {\n  _classPrivateMethodGet(this, _checkFormat, _checkFormat2).call(this, o);\n  return _classPrivateMethodGet(this, _checkValue, _checkValue2).call(this, _classPrivateFieldGet(this, _val) * _classPrivateFieldGet(o, _val) / _classPrivateFieldGet(this, _tens), safeOp);\n}\nfunction _div2(o, safeOp) {\n  assert(_classPrivateFieldGet(o, _val) !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n    operation: \"div\",\n    fault: \"divide-by-zero\",\n    value: this\n  });\n  _classPrivateMethodGet(this, _checkFormat, _checkFormat2).call(this, o);\n  return _classPrivateMethodGet(this, _checkValue, _checkValue2).call(this, _classPrivateFieldGet(this, _val) * _classPrivateFieldGet(this, _tens) / _classPrivateFieldGet(o, _val), safeOp);\n}","map":{"version":3,"names":["getBytes","assert","assertArgument","assertPrivate","getBigInt","fromTwos","mask","toBigInt","defineProperties","BN_N1","BigInt","BN_0","BN_1","BN_5","_guard","Zeros","length","getTens","decimals","result","substring","checkValue","val","format","safeOp","width","signed","limit","operation","fault","value","getFormat","concat","match","parseInt","v","check","key","type","defaultValue","name","String","toString","negative","str","index","_format2","WeakMap","_val","_tens","_checkFormat","WeakSet","_checkValue","_add","_sub","_mul","_div","FixedNumber","guard","_classCallCheck","_classPrivateMethodInitSpec","_defineProperty","_classPrivateFieldInitSpec","writable","_classPrivateFieldSet","_value","_createClass","get","_classPrivateFieldGet","addUnsafe","other","_classPrivateMethodGet","_add2","call","add","subUnsafe","_sub2","sub","mulUnsafe","_mul2","mul","mulSignal","_checkFormat2","_checkValue2","divUnsafe","_div2","div","divSignal","cmp","a","b","delta","eq","lt","lte","gt","gte","floor","ceiling","round","bump","tens","isZero","isNegative","toUnsafeFloat","parseFloat","toFormat","fromString","fromValue","_format","whole","decimal","fromBytes","o"],"sources":["C:\\Users\\Oguzhan\\Desktop\\BlockGuard\\mwallet\\node_modules\\ethers\\src.ts\\utils\\fixednumber.ts"],"sourcesContent":["/**\n *  About fixed-point math...\n *\n *  @_section: api/utils/fixed-point-math:Fixed-Point Maths  [about-fixed-point-math]\n */\nimport { getBytes } from \"./data.js\";\nimport { assert, assertArgument, assertPrivate } from \"./errors.js\";\nimport {\n    getBigInt, fromTwos, mask, toBigInt\n} from \"./maths.js\";\nimport { defineProperties } from \"./properties.js\";\n\nimport type { BigNumberish, BytesLike } from \"./index.js\";\n\nconst BN_N1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_5 = BigInt(5);\n\nconst _guard = { };\n\n\n// Constant to pull zeros from for multipliers\nlet Zeros = \"0000\";\nwhile (Zeros.length < 80) { Zeros += Zeros; }\n\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getTens(decimals: number): bigint {\n    let result = Zeros;\n    while (result.length < decimals) { result += result; }\n    return BigInt(\"1\" + result.substring(0, decimals));\n}\n\n\n\n    /*\n     *  Returns a new FixedFormat for %%value%%.\n     *\n     *  If %%value%% is specified as a ``number``, the bit-width is\n     *  128 bits and %%value%% is used for the ``decimals``.\n     *\n     *  A string %%value%% may begin with ``fixed`` or ``ufixed``\n     *  for signed and unsigned respectfully. If no other properties\n     *  are specified, the bit-width is 128-bits with 18 decimals.\n     *\n     *  To specify the bit-width and demicals, append them separated\n     *  by an ``\"x\"`` to the %%value%%.\n     *\n     *  For example, ``ufixed128x18`` describes an unsigned, 128-bit\n     *  wide format with 18 decimals.\n     *\n     *  If %%value%% is an other object, its properties for ``signed``,\n     *  ``width`` and ``decimals`` are checked.\n     */\n\n/**\n *  A description of a fixed-point arithmetic field.\n *\n *  When specifying the fixed format, the values override the default of\n *  a ``fixed128x18``, which implies a signed 128-bit value with 18\n *  decimals of precision.\n *\n *  The alias ``fixed`` and ``ufixed`` can be used for ``fixed128x18`` and\n *  ``ufixed128x18`` respectively.\n *\n *  When a fixed format string begins with a ``u``, it indicates the field\n *  is unsigned, so any negative values will overflow. The first number\n *  indicates the bit-width and the second number indicates the decimal\n *  precision.\n *\n *  When a ``number`` is used for a fixed format, it indicates the number\n *  of decimal places, and the default width and signed-ness will be used.\n *\n *  The bit-width must be byte aligned and the decimals can be at most 80.\n */\nexport type FixedFormat = number | string | {\n    signed?: boolean,\n    width?: number,\n    decimals?: number\n};\n\nfunction checkValue(val: bigint, format: _FixedFormat, safeOp?: string): bigint {\n    const width = BigInt(format.width);\n    if (format.signed) {\n        const limit = (BN_1 << (width - BN_1));\n        assert(safeOp == null || (val >= -limit  && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n            operation: <string>safeOp, fault: \"overflow\", value: val\n        });\n\n        if (val > BN_0) {\n            val = fromTwos(mask(val, width), width);\n        } else {\n            val = -fromTwos(mask(-val, width), width);\n        }\n\n    } else {\n        const limit = (BN_1 << width);\n        assert(safeOp == null || (val >= 0 && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n            operation: <string>safeOp, fault: \"overflow\", value: val\n        });\n        val = (((val % limit) + limit) % limit) & (limit - BN_1);\n    }\n\n    return val;\n}\n\ntype _FixedFormat = { signed: boolean, width: number, decimals: number, name: string }\n\nfunction getFormat(value?: FixedFormat): _FixedFormat {\n    if (typeof(value) === \"number\") { value = `fixed128x${value}` }\n\n    let signed = true;\n    let width = 128;\n    let decimals = 18;\n\n    if (typeof(value) === \"string\") {\n        // Parse the format string\n        if (value === \"fixed\") {\n            // defaults...\n        } else if (value === \"ufixed\") {\n            signed = false;\n        } else {\n            const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n            assertArgument(match, \"invalid fixed format\", \"format\", value);\n            signed = (match[1] !== \"u\");\n            width = parseInt(match[2]);\n            decimals = parseInt(match[3]);\n        }\n    } else if (value) {\n        // Extract the values from the object\n        const v: any = value;\n        const check = (key: string, type: string, defaultValue: any): any => {\n            if (v[key] == null) { return defaultValue; }\n            assertArgument(typeof(v[key]) === type,\n                \"invalid fixed format (\" + key + \" not \" + type +\")\", \"format.\" + key, v[key]);\n            return v[key];\n        }\n        signed = check(\"signed\", \"boolean\", signed);\n        width = check(\"width\", \"number\", width);\n        decimals = check(\"decimals\", \"number\", decimals);\n    }\n\n    assertArgument((width % 8) === 0, \"invalid FixedNumber width (not byte aligned)\", \"format.width\", width);\n    assertArgument(decimals <= 80, \"invalid FixedNumber decimals (too large)\", \"format.decimals\", decimals);\n\n    const name = (signed ? \"\": \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n\n    return { signed, width, decimals, name };\n}\n\nfunction toString(val: bigint, decimals: number) {\n    let negative = \"\";\n    if (val < BN_0) {\n        negative = \"-\";\n        val *= BN_N1;\n    }\n\n    let str = val.toString();\n\n    // No decimal point for whole values\n    if (decimals === 0) { return (negative + str); }\n\n    // Pad out to the whole component (including a whole digit)\n    while (str.length <= decimals) { str = Zeros + str; }\n\n    // Insert the decimal point\n    const index = str.length - decimals;\n    str = str.substring(0, index) + \".\" + str.substring(index);\n\n    // Trim the whole component (leaving at least one 0)\n    while (str[0] === \"0\" && str[1] !== \".\") {\n        str = str.substring(1);\n    }\n\n    // Trim the decimal component (leaving at least one 0)\n    while (str[str.length - 1] === \"0\" && str[str.length - 2] !== \".\") {\n        str = str.substring(0, str.length - 1);\n    }\n\n    return (negative + str);\n}\n\n\n/**\n *  A FixedNumber represents a value over its [[FixedFormat]]\n *  arithmetic field.\n *\n *  A FixedNumber can be used to perform math, losslessly, on\n *  values which have decmial places.\n *\n *  A FixedNumber has a fixed bit-width to store values in, and stores all\n *  values internally by multiplying the value by 10 raised to the power of\n *  %%decimals%%.\n *\n *  If operations are performed that cause a value to grow too high (close to\n *  positive infinity) or too low (close to negative infinity), the value\n *  is said to //overflow//.\n *\n *  For example, an 8-bit signed value, with 0 decimals may only be within\n *  the range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become\n *  ``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.\n *\n *  Many operation have a normal and //unsafe// variant. The normal variant\n *  will throw a [[NumericFaultError]] on any overflow, while the //unsafe//\n *  variant will silently allow overflow, corrupting its value value.\n *\n *  If operations are performed that cause a value to become too small\n *  (close to zero), the value loses precison and is said to //underflow//.\n *\n *  For example, an value with 1 decimal place may store a number as small\n *  as ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit\n *  into 1 decimal place, so underflow occurs which means precision is lost\n *  and the value becomes ``0``.\n *\n *  Some operations have a normal and //signalling// variant. The normal\n *  variant will silently ignore underflow, while the //signalling// variant\n *  will thow a [[NumericFaultError]] on underflow.\n */\nexport class FixedNumber {\n\n    /**\n     *  The specific fixed-point arithmetic field for this value.\n     */\n    readonly format!: string;\n\n    readonly #format: _FixedFormat;\n\n    // The actual value (accounting for decimals)\n    #val: bigint;\n\n    // A base-10 value to multiple values by to maintain the magnitude\n    readonly #tens: bigint;\n\n    /**\n     *  This is a property so console.log shows a human-meaningful value.\n     *\n     *  @private\n     */\n    readonly _value!: string;\n\n    // Use this when changing this file to get some typing info,\n    // but then switch to any to mask the internal type\n    //constructor(guard: any, value: bigint, format: _FixedFormat) {\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, value: bigint, format: any) {\n        assertPrivate(guard, _guard, \"FixedNumber\");\n\n        this.#val = value;\n\n        this.#format = format;\n\n        const _value = toString(value, format.decimals);\n\n        defineProperties<FixedNumber>(this, { format: format.name, _value });\n\n        this.#tens = getTens(format.decimals);\n    }\n\n    /**\n     *  If true, negative values are permitted, otherwise only\n     *  positive values and zero are allowed.\n     */\n    get signed(): boolean { return this.#format.signed; }\n\n    /**\n     *  The number of bits available to store the value.\n     */\n    get width(): number { return this.#format.width; }\n\n    /**\n     *  The number of decimal places in the fixed-point arithment field.\n     */\n    get decimals(): number { return this.#format.decimals; }\n\n    /**\n     *  The value as an integer, based on the smallest unit the\n     *  [[decimals]] allow.\n     */\n    get value(): bigint { return this.#val; }\n\n    #checkFormat(other: FixedNumber): void {\n        assertArgument(this.format === other.format,\n            \"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n    }\n\n    #checkValue(val: bigint, safeOp?: string): FixedNumber {\n/*\n        const width = BigInt(this.width);\n        if (this.signed) {\n            const limit = (BN_1 << (width - BN_1));\n            assert(safeOp == null || (val >= -limit  && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n                operation: <string>safeOp, fault: \"overflow\", value: val\n            });\n\n            if (val > BN_0) {\n                val = fromTwos(mask(val, width), width);\n            } else {\n                val = -fromTwos(mask(-val, width), width);\n            }\n\n        } else {\n            const masked = mask(val, width);\n            assert(safeOp == null || (val >= 0 && val === masked), \"overflow\", \"NUMERIC_FAULT\", {\n                operation: <string>safeOp, fault: \"overflow\", value: val\n            });\n            val = masked;\n        }\n*/\n        val = checkValue(val, this.#format, safeOp);\n        return new FixedNumber(_guard, val, this.#format);\n    }\n\n    #add(o: FixedNumber, safeOp?: string): FixedNumber {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val + o.#val, safeOp);\n    }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%, ignoring overflow.\n     */\n    addUnsafe(other: FixedNumber): FixedNumber { return this.#add(other); }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    add(other: FixedNumber): FixedNumber { return this.#add(other, \"add\"); }\n\n    #sub(o: FixedNumber, safeOp?: string): FixedNumber {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val - o.#val, safeOp);\n    }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%, ignoring overflow.\n     */\n    subUnsafe(other: FixedNumber): FixedNumber { return this.#sub(other); }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    sub(other: FixedNumber): FixedNumber { return this.#sub(other, \"sub\"); }\n\n    #mul(o: FixedNumber, safeOp?: string): FixedNumber {\n        this.#checkFormat(o);\n        return this.#checkValue((this.#val * o.#val) / this.#tens, safeOp);\n    }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%, ignoring overflow and underflow (precision loss).\n     */\n    mulUnsafe(other: FixedNumber): FixedNumber { return this.#mul(other); }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    mul(other: FixedNumber): FixedNumber { return this.#mul(other, \"mul\"); }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs or if underflow (precision loss) occurs.\n     */\n    mulSignal(other: FixedNumber): FixedNumber {\n        this.#checkFormat(other);\n        const value = this.#val * other.#val;\n        assert((value % this.#tens) === BN_0, \"precision lost during signalling mul\", \"NUMERIC_FAULT\", {\n            operation: \"mulSignal\", fault: \"underflow\", value: this\n        });\n        return this.#checkValue(value / this.#tens, \"mulSignal\");\n    }\n\n    #div(o: FixedNumber, safeOp?: string): FixedNumber {\n        assert(o.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\", fault: \"divide-by-zero\", value: this\n        });\n        this.#checkFormat(o);\n        return this.#checkValue((this.#val * this.#tens) / o.#val, safeOp);\n    }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */\n    divUnsafe(other: FixedNumber): FixedNumber { return this.#div(other); }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */\n    div(other: FixedNumber): FixedNumber { return this.#div(other, \"div\"); }\n\n\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%. A [[NumericFaultError]] is thrown if underflow\n     *  (precision loss) occurs.\n     */\n    divSignal(other: FixedNumber): FixedNumber {\n        assert(other.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\", fault: \"divide-by-zero\", value: this\n        });\n        this.#checkFormat(other);\n        const value = (this.#val * this.#tens);\n        assert((value % other.#val) === BN_0, \"precision lost during signalling div\", \"NUMERIC_FAULT\", {\n            operation: \"divSignal\", fault: \"underflow\", value: this\n        });\n        return this.#checkValue(value / other.#val, \"divSignal\");\n    }\n\n    /**\n     *  Returns a comparison result between %%this%% and %%other%%.\n     *\n     *  This is suitable for use in sorting, where ``-1`` implies %%this%%\n     *  is smaller, ``1`` implies %%other%% is larger and ``0`` implies\n     *  both are equal.\n     */\n     cmp(other: FixedNumber): number {\n         let a = this.value, b = other.value;\n\n         // Coerce a and b to the same magnitude\n         const delta = this.decimals - other.decimals;\n         if (delta > 0) {\n             b *= getTens(delta);\n         } else if (delta < 0) {\n             a *= getTens(-delta);\n         }\n\n         // Comnpare\n         if (a < b) { return -1; }\n         if (a > b) { return -1; }\n         return 0;\n     }\n\n    /**\n     *  Returns true if %%other%% is equal to %%this%%.\n     */\n     eq(other: FixedNumber): boolean { return this.cmp(other) === 0; }\n\n    /**\n     *  Returns true if %%other%% is less than to %%this%%.\n     */\n     lt(other: FixedNumber): boolean { return this.cmp(other) < 0; }\n\n    /**\n     *  Returns true if %%other%% is less than or equal to %%this%%.\n     */\n     lte(other: FixedNumber): boolean { return this.cmp(other) <= 0; }\n\n    /**\n     *  Returns true if %%other%% is greater than to %%this%%.\n     */\n     gt(other: FixedNumber): boolean { return this.cmp(other) > 0; }\n\n    /**\n     *  Returns true if %%other%% is greater than or equal to %%this%%.\n     */\n     gte(other: FixedNumber): boolean { return this.cmp(other) >= 0; }\n\n    /**\n     *  Returns a new [[FixedNumber]] which is the largest **integer**\n     *  that is less than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */\n    floor(): FixedNumber {\n        let val = this.#val;\n        if (this.#val < BN_0) { val -= this.#tens - BN_1; }\n        val = (this.#val / this.#tens) * this.#tens;\n        return this.#checkValue(val, \"floor\");\n    }\n\n    /**\n     *  Returns a new [[FixedNumber]] which is the smallest **integer**\n     *  that is greater than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */\n    ceiling(): FixedNumber {\n        let val = this.#val;\n        if (this.#val > BN_0) { val += this.#tens - BN_1; }\n        val = (this.#val / this.#tens) * this.#tens;\n        return this.#checkValue(val, \"ceiling\");\n    }\n\n    /**\n     *  Returns a new [[FixedNumber]] with the decimal component\n     *  rounded up on ties at %%decimals%% places.\n     */\n    round(decimals?: number): FixedNumber {\n        if (decimals == null) { decimals = 0; }\n\n        // Not enough precision to not already be rounded\n        if (decimals >= this.decimals) { return this; }\n\n        const delta = this.decimals - decimals;\n        const bump = BN_5 * getTens(delta - 1);\n\n        let value = this.value + bump;\n        const tens = getTens(delta);\n        value = (value / tens) * tens;\n\n        checkValue(value, this.#format, \"round\");\n\n        return new FixedNumber(_guard, value, this.#format);\n    }\n\n    /**\n     *  Returns true if %%this%% is equal to ``0``.\n     */\n    isZero(): boolean { return (this.#val === BN_0); }\n\n    /**\n     *  Returns true if %%this%% is less than ``0``.\n     */\n    isNegative(): boolean { return (this.#val < BN_0); }\n\n    /**\n     *  Returns the string representation of %%this%%.\n     */\n    toString(): string { return this._value; }\n\n    /**\n     *  Returns a float approximation.\n     *\n     *  Due to IEEE 754 precission (or lack thereof), this function\n     *  can only return an approximation and most values will contain\n     *  rounding errors.\n     */\n    toUnsafeFloat(): number { return parseFloat(this.toString()); }\n\n    /**\n     *  Return a new [[FixedNumber]] with the same value but has had\n     *  its field set to %%format%%.\n     *\n     *  This will throw if the value cannot fit into %%format%%.\n     */\n    toFormat(format: FixedFormat): FixedNumber {\n        return FixedNumber.fromString(this.toString(), format);\n    }\n\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% divided by\n     *  %%decimal%% places with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted\n     *  for %%decimals%%) cannot fit in %%format%%, either due to overflow\n     *  or underflow (precision loss).\n     */\n    static fromValue(_value: BigNumberish, decimals?: number, _format?: FixedFormat): FixedNumber {\n        if (decimals == null) { decimals = 0; }\n        const format = getFormat(_format);\n\n        let value = getBigInt(_value, \"value\");\n        const delta = decimals - format.decimals;\n        if (delta > 0) {\n            const tens = getTens(delta);\n            assert((value % tens) === BN_0, \"value loses precision for format\", \"NUMERIC_FAULT\", {\n                operation: \"fromValue\", fault: \"underflow\", value: _value\n            });\n            value /= tens;\n        } else if (delta < 0) {\n            value *= getTens(-delta);\n        }\n\n        checkValue(value, format, \"fromValue\");\n\n        return new FixedNumber(_guard, value, format);\n    }\n\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%%, either due to overflow or underflow (precision loss).\n     */\n    static fromString(_value: string, _format?: FixedFormat): FixedNumber {\n        const match = _value.match(/^(-?)([0-9]*)\\.?([0-9]*)$/);\n        assertArgument(match && (match[2].length + match[3].length) > 0, \"invalid FixedNumber string value\", \"value\", _value);\n\n        const format = getFormat(_format);\n\n        let whole = (match[2] || \"0\"), decimal = (match[3] || \"\");\n\n        // Pad out the decimals\n        while (decimal.length < format.decimals) { decimal += Zeros; }\n\n        // Check precision is safe\n        assert(decimal.substring(format.decimals).match(/^0*$/), \"too many decimals for format\", \"NUMERIC_FAULT\", {\n            operation: \"fromString\", fault: \"underflow\", value: _value\n        });\n\n        // Remove extra padding\n        decimal = decimal.substring(0, format.decimals);\n\n        const value = BigInt(match[1] + whole + decimal)\n\n        checkValue(value, format, \"fromString\");\n\n        return new FixedNumber(_guard, value, format);\n    }\n\n    /**\n     *  Creates a new [[FixedNumber]] with the big-endian representation\n     *  %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%% due to overflow.\n     */\n    static fromBytes(_value: BytesLike, _format?: FixedFormat): FixedNumber {\n        let value = toBigInt(getBytes(_value, \"value\"));\n        const format = getFormat(_format);\n\n        if (format.signed) { value = fromTwos(value, format.width); }\n\n        checkValue(value, format, \"fromBytes\");\n\n        return new FixedNumber(_guard, value, format);\n    }\n}\n\n//const f1 = FixedNumber.fromString(\"12.56\", \"fixed16x2\");\n//const f2 = FixedNumber.fromString(\"0.3\", \"fixed16x2\");\n//console.log(f1.divSignal(f2));\n//const BUMP = FixedNumber.from(\"0.5\");\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}