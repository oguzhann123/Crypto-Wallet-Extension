{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classPrivateFieldInitSpec from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _defineProperty from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classPrivateFieldGet from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nimport _classPrivateFieldSet from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\nimport { getAddress, resolveAddress } from \"../address/index.js\";\nimport { hashMessage, TypedDataEncoder } from \"../hash/index.js\";\nimport { AbstractSigner } from \"../providers/index.js\";\nimport { computeAddress, Transaction } from \"../transaction/index.js\";\nimport { defineProperties, resolveProperties, assert, assertArgument } from \"../utils/index.js\";\n/**\n *  The **BaseWallet** is a stream-lined implementation of a\n *  [[Signer]] that operates with a private key.\n *\n *  It is preferred to use the [[Wallet]] class, as it offers\n *  additional functionality and simplifies loading a variety\n *  of JSON formats, Mnemonic Phrases, etc.\n *\n *  This class may be of use for those attempting to implement\n *  a minimal Signer.\n */\nvar _signingKey = /*#__PURE__*/new WeakMap();\nexport var BaseWallet = /*#__PURE__*/function (_AbstractSigner) {\n  _inherits(BaseWallet, _AbstractSigner);\n  var _super = _createSuper(BaseWallet);\n  /**\n   *  Creates a new BaseWallet for %%privateKey%%, optionally\n   *  connected to %%provider%%.\n   *\n   *  If %%provider%% is not specified, only offline methods can\n   *  be used.\n   */\n  function BaseWallet(privateKey, provider) {\n    var _this;\n    _classCallCheck(this, BaseWallet);\n    _this = _super.call(this, provider);\n    /**\n     *  The wallet address.\n     */\n    _defineProperty(_assertThisInitialized(_this), \"address\", void 0);\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this), _signingKey, {\n      writable: true,\n      value: void 0\n    });\n    assertArgument(privateKey && typeof privateKey.sign === \"function\", \"invalid private key\", \"privateKey\", \"[ REDACTED ]\");\n    _classPrivateFieldSet(_assertThisInitialized(_this), _signingKey, privateKey);\n    var address = computeAddress(_this.signingKey.publicKey);\n    defineProperties(_assertThisInitialized(_this), {\n      address: address\n    });\n    return _this;\n  }\n  // Store private values behind getters to reduce visibility\n  // in console.log\n  /**\n   *  The [[SigningKey]] used for signing payloads.\n   */\n  _createClass(BaseWallet, [{\n    key: \"signingKey\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _signingKey);\n    }\n    /**\n     *  The private key for this wallet.\n     */\n  }, {\n    key: \"privateKey\",\n    get: function get() {\n      return this.signingKey.privateKey;\n    }\n  }, {\n    key: \"getAddress\",\n    value: function () {\n      var _getAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", this.address);\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function getAddress() {\n        return _getAddress.apply(this, arguments);\n      }\n      return getAddress;\n    }()\n  }, {\n    key: \"connect\",\n    value: function connect(provider) {\n      return new BaseWallet(_classPrivateFieldGet(this, _signingKey), provider);\n    }\n  }, {\n    key: \"signTransaction\",\n    value: function () {\n      var _signTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(tx) {\n        var _yield$resolvePropert, to, from, btx;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return resolveProperties({\n                to: tx.to ? resolveAddress(tx.to, this.provider) : undefined,\n                from: tx.from ? resolveAddress(tx.from, this.provider) : undefined\n              });\n            case 2:\n              _yield$resolvePropert = _context2.sent;\n              to = _yield$resolvePropert.to;\n              from = _yield$resolvePropert.from;\n              if (to != null) {\n                tx.to = to;\n              }\n              if (from != null) {\n                tx.from = from;\n              }\n              if (tx.from != null) {\n                assertArgument(getAddress(tx.from) === this.address, \"transaction from address mismatch\", \"tx.from\", tx.from);\n                delete tx.from;\n              }\n              // Build the transaction\n              btx = Transaction.from(tx);\n              btx.signature = this.signingKey.sign(btx.unsignedHash);\n              return _context2.abrupt(\"return\", btx.serialized);\n            case 11:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function signTransaction(_x) {\n        return _signTransaction.apply(this, arguments);\n      }\n      return signTransaction;\n    }()\n  }, {\n    key: \"signMessage\",\n    value: function () {\n      var _signMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(message) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              return _context3.abrupt(\"return\", this.signMessageSync(message));\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function signMessage(_x2) {\n        return _signMessage.apply(this, arguments);\n      }\n      return signMessage;\n    }() // @TODO: Add a secialized signTx and signTyped sync that enforces\n    // all parameters are known?\n    /**\n     *  Returns the signature for %%message%% signed with this wallet.\n     */\n  }, {\n    key: \"signMessageSync\",\n    value: function signMessageSync(message) {\n      return this.signingKey.sign(hashMessage(message)).serialized;\n    }\n  }, {\n    key: \"signTypedData\",\n    value: function () {\n      var _signTypedData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(domain, types, value) {\n        var _this2 = this;\n        var populated;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.next = 2;\n              return TypedDataEncoder.resolveNames(domain, types, value, /*#__PURE__*/function () {\n                var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(name) {\n                  var address;\n                  return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n                    while (1) switch (_context4.prev = _context4.next) {\n                      case 0:\n                        // @TODO: this should use resolveName; addresses don't\n                        //        need a provider\n                        assert(_this2.provider != null, \"cannot resolve ENS names without a provider\", \"UNSUPPORTED_OPERATION\", {\n                          operation: \"resolveName\",\n                          info: {\n                            name: name\n                          }\n                        });\n                        _context4.next = 3;\n                        return _this2.provider.resolveName(name);\n                      case 3:\n                        address = _context4.sent;\n                        assert(address != null, \"unconfigured ENS name\", \"UNCONFIGURED_NAME\", {\n                          value: name\n                        });\n                        return _context4.abrupt(\"return\", address);\n                      case 6:\n                      case \"end\":\n                        return _context4.stop();\n                    }\n                  }, _callee4);\n                }));\n                return function (_x6) {\n                  return _ref.apply(this, arguments);\n                };\n              }());\n            case 2:\n              populated = _context5.sent;\n              return _context5.abrupt(\"return\", this.signingKey.sign(TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized);\n            case 4:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function signTypedData(_x3, _x4, _x5) {\n        return _signTypedData.apply(this, arguments);\n      }\n      return signTypedData;\n    }()\n  }]);\n  return BaseWallet;\n}(AbstractSigner);","map":{"version":3,"names":["getAddress","resolveAddress","hashMessage","TypedDataEncoder","AbstractSigner","computeAddress","Transaction","defineProperties","resolveProperties","assert","assertArgument","_signingKey","WeakMap","BaseWallet","_AbstractSigner","_inherits","_super","_createSuper","privateKey","provider","_this","_classCallCheck","call","_defineProperty","_assertThisInitialized","_classPrivateFieldInitSpec","writable","value","sign","_classPrivateFieldSet","address","signingKey","publicKey","_createClass","key","get","_classPrivateFieldGet","_getAddress","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","abrupt","stop","apply","arguments","connect","_signTransaction","_callee2","tx","_yield$resolvePropert","to","from","btx","_callee2$","_context2","undefined","sent","signature","unsignedHash","serialized","signTransaction","_x","_signMessage","_callee3","message","_callee3$","_context3","signMessageSync","signMessage","_x2","_signTypedData","_callee5","domain","types","_this2","populated","_callee5$","_context5","resolveNames","_ref","_callee4","name","_callee4$","_context4","operation","info","resolveName","_x6","hash","signTypedData","_x3","_x4","_x5"],"sources":["C:\\Users\\Oguzhan\\Desktop\\BlockGuard\\mwallet\\node_modules\\ethers\\src.ts\\wallet\\base-wallet.ts"],"sourcesContent":["import { getAddress, resolveAddress } from \"../address/index.js\";\nimport { hashMessage, TypedDataEncoder } from \"../hash/index.js\";\nimport { AbstractSigner } from \"../providers/index.js\";\nimport { computeAddress, Transaction } from \"../transaction/index.js\";\nimport {\n    defineProperties, resolveProperties, assert, assertArgument\n} from \"../utils/index.js\";\n\nimport type { SigningKey } from \"../crypto/index.js\";\nimport type { TypedDataDomain, TypedDataField } from \"../hash/index.js\";\nimport type { Provider, TransactionRequest } from \"../providers/index.js\";\nimport type { TransactionLike } from \"../transaction/index.js\";\n\n\n/**\n *  The **BaseWallet** is a stream-lined implementation of a\n *  [[Signer]] that operates with a private key.\n *\n *  It is preferred to use the [[Wallet]] class, as it offers\n *  additional functionality and simplifies loading a variety\n *  of JSON formats, Mnemonic Phrases, etc.\n *\n *  This class may be of use for those attempting to implement\n *  a minimal Signer.\n */\nexport class BaseWallet extends AbstractSigner {\n    /**\n     *  The wallet address.\n     */\n    readonly address!: string;\n\n    readonly #signingKey: SigningKey;\n\n    /**\n     *  Creates a new BaseWallet for %%privateKey%%, optionally\n     *  connected to %%provider%%.\n     *\n     *  If %%provider%% is not specified, only offline methods can\n     *  be used.\n     */\n    constructor(privateKey: SigningKey, provider?: null | Provider) {\n        super(provider);\n\n        assertArgument(privateKey && typeof(privateKey.sign) === \"function\", \"invalid private key\", \"privateKey\", \"[ REDACTED ]\");\n\n        this.#signingKey = privateKey;\n\n        const address = computeAddress(this.signingKey.publicKey);\n        defineProperties<BaseWallet>(this, { address });\n    }\n\n    // Store private values behind getters to reduce visibility\n    // in console.log\n\n    /**\n     *  The [[SigningKey]] used for signing payloads.\n     */\n    get signingKey(): SigningKey { return this.#signingKey; }\n\n    /**\n     *  The private key for this wallet.\n     */\n    get privateKey(): string { return this.signingKey.privateKey; }\n\n    async getAddress(): Promise<string> { return this.address; }\n\n    connect(provider: null | Provider): BaseWallet {\n        return new BaseWallet(this.#signingKey, provider);\n    }\n\n    async signTransaction(tx: TransactionRequest): Promise<string> {\n\n        // Replace any Addressable or ENS name with an address\n        const { to, from } = await resolveProperties({\n            to: (tx.to ? resolveAddress(tx.to, this.provider): undefined),\n            from: (tx.from ? resolveAddress(tx.from, this.provider): undefined)\n        });\n\n        if (to != null) { tx.to = to; }\n        if (from != null) { tx.from = from; }\n\n        if (tx.from != null) {\n            assertArgument(getAddress(<string>(tx.from)) === this.address,\n                \"transaction from address mismatch\", \"tx.from\", tx.from);\n            delete tx.from;\n        }\n\n        // Build the transaction\n        const btx = Transaction.from(<TransactionLike<string>>tx);\n        btx.signature = this.signingKey.sign(btx.unsignedHash);\n\n        return btx.serialized;\n    }\n\n    async signMessage(message: string | Uint8Array): Promise<string> {\n        return this.signMessageSync(message);\n    }\n\n    // @TODO: Add a secialized signTx and signTyped sync that enforces\n    // all parameters are known?\n    /**\n     *  Returns the signature for %%message%% signed with this wallet.\n     */\n    signMessageSync(message: string | Uint8Array): string {\n        return this.signingKey.sign(hashMessage(message)).serialized;\n    }\n\n    async signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n\n        // Populate any ENS names\n        const populated = await TypedDataEncoder.resolveNames(domain, types, value, async (name: string) => {\n            // @TODO: this should use resolveName; addresses don't\n            //        need a provider\n\n            assert(this.provider != null, \"cannot resolve ENS names without a provider\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"resolveName\",\n                info: { name }\n            });\n\n            const address = await this.provider.resolveName(name);\n            assert(address != null, \"unconfigured ENS name\", \"UNCONFIGURED_NAME\", {\n                value: name\n            });\n\n            return address;\n        });\n\n        return this.signingKey.sign(TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}