{"ast":null,"code":"import _slicedToArray from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classPrivateMethodInitSpec from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateMethodGet from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateMethodGet.js\";\nimport _classPrivateFieldGet from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nimport _classPrivateFieldSet from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\nimport _asyncToGenerator from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n/**\n *  About Subclassing the Provider...\n *\n *  @_section: api/providers/abstract-provider: Subclassing Provider  [abstract-provider]\n */\n// @TODO\n// Event coalescence\n//   When we register an event with an async value (e.g. address is a Signer\n//   or ENS name), we need to add it immeidately for the Event API, but also\n//   need time to resolve the address. Upon resolving the address, we need to\n//   migrate the listener to the static event. We also need to maintain a map\n//   of Signer/ENS name to address so we can sync respond to listenerCount.\nimport { getAddress, resolveAddress } from \"../address/index.js\";\nimport { ZeroHash } from \"../constants/index.js\";\nimport { Contract } from \"../contract/index.js\";\nimport { namehash } from \"../hash/index.js\";\nimport { Transaction } from \"../transaction/index.js\";\nimport { concat, dataLength, dataSlice, hexlify, isHexString, getBigInt, getBytes, getNumber, isCallException, isError, makeError, assert, assertArgument, FetchRequest, toBeArray, toQuantity, defineProperties, EventPayload, resolveProperties, toUtf8String } from \"../utils/index.js\";\nimport { EnsResolver } from \"./ens-resolver.js\";\nimport { formatBlock, formatLog, formatTransactionReceipt, formatTransactionResponse } from \"./format.js\";\nimport { Network } from \"./network.js\";\nimport { copyRequest, Block, FeeData, Log, TransactionReceipt, TransactionResponse } from \"./provider.js\";\nimport { PollingBlockSubscriber, PollingEventSubscriber, PollingOrphanSubscriber, PollingTransactionSubscriber } from \"./subscriber-polling.js\";\n// Constants\nvar BN_2 = BigInt(2);\nvar MAX_CCIP_REDIRECTS = 10;\nfunction isPromise(value) {\n  return value && typeof value.then === \"function\";\n}\nfunction getTag(prefix, value) {\n  return prefix + \":\" + JSON.stringify(value, function (k, v) {\n    if (v == null) {\n      return \"null\";\n    }\n    if (typeof v === \"bigint\") {\n      return \"bigint:\".concat(v.toString());\n    }\n    if (typeof v === \"string\") {\n      return v.toLowerCase();\n    }\n    // Sort object keys\n    if (typeof v === \"object\" && !Array.isArray(v)) {\n      var keys = Object.keys(v);\n      keys.sort();\n      return keys.reduce(function (accum, key) {\n        accum[key] = v[key];\n        return accum;\n      }, {});\n    }\n    return v;\n  });\n}\nexport var UnmanagedSubscriber = /*#__PURE__*/function () {\n  function UnmanagedSubscriber(name) {\n    _classCallCheck(this, UnmanagedSubscriber);\n    _defineProperty(this, \"name\", void 0);\n    defineProperties(this, {\n      name: name\n    });\n  }\n  _createClass(UnmanagedSubscriber, [{\n    key: \"start\",\n    value: function start() {}\n  }, {\n    key: \"stop\",\n    value: function stop() {}\n  }, {\n    key: \"pause\",\n    value: function pause(dropWhilePaused) {}\n  }, {\n    key: \"resume\",\n    value: function resume() {}\n  }]);\n  return UnmanagedSubscriber;\n}();\nfunction copy(value) {\n  return JSON.parse(JSON.stringify(value));\n}\nfunction concisify(items) {\n  items = Array.from(new Set(items).values());\n  items.sort();\n  return items;\n}\nfunction getSubscription(_x, _x2) {\n  return _getSubscription.apply(this, arguments);\n}\nfunction _getSubscription() {\n  _getSubscription = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee40(_event, provider) {\n    var hash, event, _event2, filter, addresses, promises, addAddress;\n    return _regeneratorRuntime().wrap(function _callee40$(_context40) {\n      while (1) switch (_context40.prev = _context40.next) {\n        case 0:\n          if (!(_event == null)) {\n            _context40.next = 2;\n            break;\n          }\n          throw new Error(\"invalid event\");\n        case 2:\n          // Normalize topic array info an EventFilter\n          if (Array.isArray(_event)) {\n            _event = {\n              topics: _event\n            };\n          }\n          if (!(typeof _event === \"string\")) {\n            _context40.next = 8;\n            break;\n          }\n          _context40.t0 = _event;\n          _context40.next = _context40.t0 === \"block\" ? 7 : _context40.t0 === \"pending\" ? 7 : _context40.t0 === \"debug\" ? 7 : _context40.t0 === \"network\" ? 7 : 8;\n          break;\n        case 7:\n          return _context40.abrupt(\"return\", {\n            type: _event,\n            tag: _event\n          });\n        case 8:\n          if (!isHexString(_event, 32)) {\n            _context40.next = 11;\n            break;\n          }\n          hash = _event.toLowerCase();\n          return _context40.abrupt(\"return\", {\n            type: \"transaction\",\n            tag: getTag(\"tx\", {\n              hash: hash\n            }),\n            hash: hash\n          });\n        case 11:\n          if (!_event.orphan) {\n            _context40.next = 14;\n            break;\n          }\n          event = _event; // @TODO: Should lowercase and whatnot things here instead of copy...\n          return _context40.abrupt(\"return\", {\n            type: \"orphan\",\n            tag: getTag(\"orphan\", event),\n            filter: copy(event)\n          });\n        case 14:\n          if (!(_event.address || _event.topics)) {\n            _context40.next = 27;\n            break;\n          }\n          _event2 = _event;\n          filter = {\n            topics: (_event2.topics || []).map(function (t) {\n              if (t == null) {\n                return null;\n              }\n              if (Array.isArray(t)) {\n                return concisify(t.map(function (t) {\n                  return t.toLowerCase();\n                }));\n              }\n              return t.toLowerCase();\n            })\n          };\n          if (!_event2.address) {\n            _context40.next = 26;\n            break;\n          }\n          addresses = [];\n          promises = [];\n          addAddress = function addAddress(addr) {\n            if (isHexString(addr)) {\n              addresses.push(addr);\n            } else {\n              promises.push(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee39() {\n                return _regeneratorRuntime().wrap(function _callee39$(_context39) {\n                  while (1) switch (_context39.prev = _context39.next) {\n                    case 0:\n                      _context39.t0 = addresses;\n                      _context39.next = 3;\n                      return resolveAddress(addr, provider);\n                    case 3:\n                      _context39.t1 = _context39.sent;\n                      _context39.t0.push.call(_context39.t0, _context39.t1);\n                    case 5:\n                    case \"end\":\n                      return _context39.stop();\n                  }\n                }, _callee39);\n              }))());\n            }\n          };\n          if (Array.isArray(_event2.address)) {\n            _event2.address.forEach(addAddress);\n          } else {\n            addAddress(_event2.address);\n          }\n          if (!promises.length) {\n            _context40.next = 25;\n            break;\n          }\n          _context40.next = 25;\n          return Promise.all(promises);\n        case 25:\n          filter.address = concisify(addresses.map(function (a) {\n            return a.toLowerCase();\n          }));\n        case 26:\n          return _context40.abrupt(\"return\", {\n            filter: filter,\n            tag: getTag(\"event\", filter),\n            type: \"event\"\n          });\n        case 27:\n          assertArgument(false, \"unknown ProviderEvent\", \"event\", _event);\n        case 28:\n        case \"end\":\n          return _context40.stop();\n      }\n    }, _callee40);\n  }));\n  return _getSubscription.apply(this, arguments);\n}\nfunction getTime() {\n  return new Date().getTime();\n}\nvar _subs = /*#__PURE__*/new WeakMap();\nvar _plugins = /*#__PURE__*/new WeakMap();\nvar _pausedState = /*#__PURE__*/new WeakMap();\nvar _networkPromise = /*#__PURE__*/new WeakMap();\nvar _anyNetwork = /*#__PURE__*/new WeakMap();\nvar _performCache = /*#__PURE__*/new WeakMap();\nvar _lastBlockNumber = /*#__PURE__*/new WeakMap();\nvar _nextTimer = /*#__PURE__*/new WeakMap();\nvar _timers = /*#__PURE__*/new WeakMap();\nvar _disableCcipRead = /*#__PURE__*/new WeakMap();\nvar _perform = /*#__PURE__*/new WeakSet();\nvar _call = /*#__PURE__*/new WeakSet();\nvar _checkNetwork = /*#__PURE__*/new WeakSet();\nvar _getAccountValue = /*#__PURE__*/new WeakSet();\nvar _getBlock = /*#__PURE__*/new WeakSet();\nvar _hasSub = /*#__PURE__*/new WeakSet();\nvar _getSub = /*#__PURE__*/new WeakSet();\nexport var AbstractProvider = /*#__PURE__*/function () {\n  // @TODO: This should be a () => Promise<Network> so network can be\n  // done when needed; or rely entirely on _detectNetwork?\n  function AbstractProvider(_network) {\n    var _this = this;\n    _classCallCheck(this, AbstractProvider);\n    _classPrivateMethodInitSpec(this, _getSub);\n    _classPrivateMethodInitSpec(this, _hasSub);\n    _classPrivateMethodInitSpec(this, _getBlock);\n    // Account\n    _classPrivateMethodInitSpec(this, _getAccountValue);\n    _classPrivateMethodInitSpec(this, _checkNetwork);\n    _classPrivateMethodInitSpec(this, _call);\n    // Shares multiple identical requests made during the same 250ms\n    _classPrivateMethodInitSpec(this, _perform);\n    _classPrivateFieldInitSpec(this, _subs, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _plugins, {\n      writable: true,\n      value: void 0\n    });\n    // null=unpaused, true=paused+dropWhilePaused, false=paused\n    _classPrivateFieldInitSpec(this, _pausedState, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _networkPromise, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _anyNetwork, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _performCache, {\n      writable: true,\n      value: void 0\n    });\n    // The most recent block number if running an event or -1 if no \"block\" event\n    _classPrivateFieldInitSpec(this, _lastBlockNumber, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _nextTimer, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _timers, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _disableCcipRead, {\n      writable: true,\n      value: void 0\n    });\n    if (_network === \"any\") {\n      _classPrivateFieldSet(this, _anyNetwork, true);\n      _classPrivateFieldSet(this, _networkPromise, null);\n    } else if (_network) {\n      var network = Network.from(_network);\n      _classPrivateFieldSet(this, _anyNetwork, false);\n      _classPrivateFieldSet(this, _networkPromise, Promise.resolve(network));\n      setTimeout(function () {\n        _this.emit(\"network\", network, null);\n      }, 0);\n    } else {\n      _classPrivateFieldSet(this, _anyNetwork, false);\n      _classPrivateFieldSet(this, _networkPromise, null);\n    }\n    _classPrivateFieldSet(this, _lastBlockNumber, -1);\n    _classPrivateFieldSet(this, _performCache, new Map());\n    _classPrivateFieldSet(this, _subs, new Map());\n    _classPrivateFieldSet(this, _plugins, new Map());\n    _classPrivateFieldSet(this, _pausedState, null);\n    _classPrivateFieldSet(this, _nextTimer, 1);\n    _classPrivateFieldSet(this, _timers, new Map());\n    _classPrivateFieldSet(this, _disableCcipRead, false);\n  }\n  _createClass(AbstractProvider, [{\n    key: \"provider\",\n    get: function get() {\n      return this;\n    }\n  }, {\n    key: \"plugins\",\n    get: function get() {\n      return Array.from(_classPrivateFieldGet(this, _plugins).values());\n    }\n  }, {\n    key: \"attachPlugin\",\n    value: function attachPlugin(plugin) {\n      if (_classPrivateFieldGet(this, _plugins).get(plugin.name)) {\n        throw new Error(\"cannot replace existing plugin: \".concat(plugin.name, \" \"));\n      }\n      _classPrivateFieldGet(this, _plugins).set(plugin.name, plugin.connect(this));\n      return this;\n    }\n  }, {\n    key: \"getPlugin\",\n    value: function getPlugin(name) {\n      return _classPrivateFieldGet(this, _plugins).get(name) || null;\n    }\n  }, {\n    key: \"disableCcipRead\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _disableCcipRead);\n    },\n    set: function set(value) {\n      _classPrivateFieldSet(this, _disableCcipRead, !!value);\n    }\n  }, {\n    key: \"ccipReadFetch\",\n    value: function () {\n      var _ccipReadFetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(tx, calldata, urls) {\n        var sender, data, errorMessages, i, url, href, request, errorMessage, resp, result;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(this.disableCcipRead || urls.length === 0 || tx.to == null)) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\", null);\n            case 2:\n              sender = tx.to.toLowerCase();\n              data = calldata.toLowerCase();\n              errorMessages = [];\n              i = 0;\n            case 6:\n              if (!(i < urls.length)) {\n                _context.next = 32;\n                break;\n              }\n              url = urls[i]; // URL expansion\n              href = url.replace(\"{sender}\", sender).replace(\"{data}\", data); // If no {data} is present, use POST; otherwise GET\n              //const json: string | null = (url.indexOf(\"{data}\") >= 0) ? null: JSON.stringify({ data, sender });\n              //const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n              //    value.status = response.statusCode;\n              //    return value;\n              //});\n              request = new FetchRequest(href);\n              if (url.indexOf(\"{data}\") === -1) {\n                request.body = {\n                  data: data,\n                  sender: sender\n                };\n              }\n              this.emit(\"debug\", {\n                action: \"sendCcipReadFetchRequest\",\n                request: request,\n                index: i,\n                urls: urls\n              });\n              errorMessage = \"unknown error\";\n              _context.next = 15;\n              return request.send();\n            case 15:\n              resp = _context.sent;\n              _context.prev = 16;\n              result = resp.bodyJson;\n              if (!result.data) {\n                _context.next = 21;\n                break;\n              }\n              this.emit(\"debug\", {\n                action: \"receiveCcipReadFetchResult\",\n                request: request,\n                result: result\n              });\n              return _context.abrupt(\"return\", result.data);\n            case 21:\n              if (result.message) {\n                errorMessage = result.message;\n              }\n              this.emit(\"debug\", {\n                action: \"receiveCcipReadFetchError\",\n                request: request,\n                result: result\n              });\n              _context.next = 27;\n              break;\n            case 25:\n              _context.prev = 25;\n              _context.t0 = _context[\"catch\"](16);\n            case 27:\n              // 4xx indicates the result is not present; stop\n              assert(resp.statusCode < 400 || resp.statusCode >= 500, \"response not found during CCIP fetch: \".concat(errorMessage), \"OFFCHAIN_FAULT\", {\n                reason: \"404_MISSING_RESOURCE\",\n                transaction: tx,\n                info: {\n                  url: url,\n                  errorMessage: errorMessage\n                }\n              });\n              // 5xx indicates server issue; try the next url\n              errorMessages.push(errorMessage);\n            case 29:\n              i++;\n              _context.next = 6;\n              break;\n            case 32:\n              assert(false, \"error encountered during CCIP fetch: \".concat(errorMessages.map(function (m) {\n                return JSON.stringify(m);\n              }).join(\", \")), \"OFFCHAIN_FAULT\", {\n                reason: \"500_SERVER_ERROR\",\n                transaction: tx,\n                info: {\n                  urls: urls,\n                  errorMessages: errorMessages\n                }\n              });\n            case 33:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[16, 25]]);\n      }));\n      function ccipReadFetch(_x3, _x4, _x5) {\n        return _ccipReadFetch.apply(this, arguments);\n      }\n      return ccipReadFetch;\n    }()\n  }, {\n    key: \"_wrapBlock\",\n    value: function _wrapBlock(value, network) {\n      return new Block(formatBlock(value), this);\n    }\n  }, {\n    key: \"_wrapLog\",\n    value: function _wrapLog(value, network) {\n      return new Log(formatLog(value), this);\n    }\n  }, {\n    key: \"_wrapTransactionReceipt\",\n    value: function _wrapTransactionReceipt(value, network) {\n      return new TransactionReceipt(formatTransactionReceipt(value), this);\n    }\n  }, {\n    key: \"_wrapTransactionResponse\",\n    value: function _wrapTransactionResponse(tx, network) {\n      return new TransactionResponse(formatTransactionResponse(tx), this);\n    }\n  }, {\n    key: \"_detectNetwork\",\n    value: function _detectNetwork() {\n      assert(false, \"sub-classes must implement this\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"_detectNetwork\"\n      });\n    }\n    // Sub-classes should override this and handle PerformActionRequest requests, calling\n    // the super for any unhandled actions.\n  }, {\n    key: \"_perform\",\n    value: function () {\n      var _perform3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(req) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              assert(false, \"unsupported method: \".concat(req.method), \"UNSUPPORTED_OPERATION\", {\n                operation: req.method,\n                info: req\n              });\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n      function _perform(_x6) {\n        return _perform3.apply(this, arguments);\n      }\n      return _perform;\n    }() // State\n  }, {\n    key: \"getBlockNumber\",\n    value: function () {\n      var _getBlockNumber = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var blockNumber;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.t0 = getNumber;\n              _context3.next = 3;\n              return _classPrivateMethodGet(this, _perform, _perform2).call(this, {\n                method: \"getBlockNumber\"\n              });\n            case 3:\n              _context3.t1 = _context3.sent;\n              blockNumber = (0, _context3.t0)(_context3.t1, \"%response\");\n              if (_classPrivateFieldGet(this, _lastBlockNumber) >= 0) {\n                _classPrivateFieldSet(this, _lastBlockNumber, blockNumber);\n              }\n              return _context3.abrupt(\"return\", blockNumber);\n            case 7:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function getBlockNumber() {\n        return _getBlockNumber.apply(this, arguments);\n      }\n      return getBlockNumber;\n    }()\n  }, {\n    key: \"_getAddress\",\n    value: function _getAddress(address) {\n      return resolveAddress(address, this);\n    }\n  }, {\n    key: \"_getBlockTag\",\n    value: function _getBlockTag(blockTag) {\n      if (blockTag == null) {\n        return \"latest\";\n      }\n      switch (blockTag) {\n        case \"earliest\":\n          return \"0x0\";\n        case \"latest\":\n        case \"pending\":\n        case \"safe\":\n        case \"finalized\":\n          return blockTag;\n      }\n      if (isHexString(blockTag)) {\n        if (isHexString(blockTag, 32)) {\n          return blockTag;\n        }\n        return toQuantity(blockTag);\n      }\n      if (typeof blockTag === \"bigint\") {\n        blockTag = getNumber(blockTag, \"blockTag\");\n      }\n      if (typeof blockTag === \"number\") {\n        if (blockTag >= 0) {\n          return toQuantity(blockTag);\n        }\n        if (_classPrivateFieldGet(this, _lastBlockNumber) >= 0) {\n          return toQuantity(_classPrivateFieldGet(this, _lastBlockNumber) + blockTag);\n        }\n        return this.getBlockNumber().then(function (b) {\n          return toQuantity(b + blockTag);\n        });\n      }\n      assertArgument(false, \"invalid blockTag\", \"blockTag\", blockTag);\n    }\n  }, {\n    key: \"_getFilter\",\n    value: function _getFilter(filter) {\n      // Create a canonical representation of the topics\n      var topics = (filter.topics || []).map(function (t) {\n        if (t == null) {\n          return null;\n        }\n        if (Array.isArray(t)) {\n          return concisify(t.map(function (t) {\n            return t.toLowerCase();\n          }));\n        }\n        return t.toLowerCase();\n      });\n      var blockHash = \"blockHash\" in filter ? filter.blockHash : undefined;\n      var resolve = function resolve(_address, fromBlock, toBlock) {\n        var address = undefined;\n        switch (_address.length) {\n          case 0:\n            break;\n          case 1:\n            address = _address[0];\n            break;\n          default:\n            _address.sort();\n            address = _address;\n        }\n        if (blockHash) {\n          if (fromBlock != null || toBlock != null) {\n            throw new Error(\"invalid filter\");\n          }\n        }\n        var filter = {};\n        if (address) {\n          filter.address = address;\n        }\n        if (topics.length) {\n          filter.topics = topics;\n        }\n        if (fromBlock) {\n          filter.fromBlock = fromBlock;\n        }\n        if (toBlock) {\n          filter.toBlock = toBlock;\n        }\n        if (blockHash) {\n          filter.blockHash = blockHash;\n        }\n        return filter;\n      };\n      // Addresses could be async (ENS names or Addressables)\n      var address = [];\n      if (filter.address) {\n        if (Array.isArray(filter.address)) {\n          var _iterator = _createForOfIteratorHelper(filter.address),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var addr = _step.value;\n              address.push(this._getAddress(addr));\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        } else {\n          address.push(this._getAddress(filter.address));\n        }\n      }\n      var fromBlock = undefined;\n      if (\"fromBlock\" in filter) {\n        fromBlock = this._getBlockTag(filter.fromBlock);\n      }\n      var toBlock = undefined;\n      if (\"toBlock\" in filter) {\n        toBlock = this._getBlockTag(filter.toBlock);\n      }\n      if (address.filter(function (a) {\n        return typeof a !== \"string\";\n      }).length || fromBlock != null && typeof fromBlock !== \"string\" || toBlock != null && typeof toBlock !== \"string\") {\n        return Promise.all([Promise.all(address), fromBlock, toBlock]).then(function (result) {\n          return resolve(result[0], result[1], result[2]);\n        });\n      }\n      return resolve(address, fromBlock, toBlock);\n    }\n  }, {\n    key: \"_getTransactionRequest\",\n    value: function _getTransactionRequest(_request) {\n      var request = copyRequest(_request);\n      var promises = [];\n      [\"to\", \"from\"].forEach(function (key) {\n        if (request[key] == null) {\n          return;\n        }\n        var addr = resolveAddress(request[key]);\n        if (isPromise(addr)) {\n          promises.push(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n            return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n              while (1) switch (_context4.prev = _context4.next) {\n                case 0:\n                  _context4.next = 2;\n                  return addr;\n                case 2:\n                  request[key] = _context4.sent;\n                case 3:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }, _callee4);\n          }))());\n        } else {\n          request[key] = addr;\n        }\n      });\n      if (request.blockTag != null) {\n        var blockTag = this._getBlockTag(request.blockTag);\n        if (isPromise(blockTag)) {\n          promises.push(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n            return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n              while (1) switch (_context5.prev = _context5.next) {\n                case 0:\n                  _context5.next = 2;\n                  return blockTag;\n                case 2:\n                  request.blockTag = _context5.sent;\n                case 3:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }, _callee5);\n          }))());\n        } else {\n          request.blockTag = blockTag;\n        }\n      }\n      if (promises.length) {\n        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n          return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n            while (1) switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return Promise.all(promises);\n              case 2:\n                return _context6.abrupt(\"return\", request);\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }, _callee6);\n        }))();\n      }\n      return request;\n    }\n  }, {\n    key: \"getNetwork\",\n    value: function () {\n      var _getNetwork = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var _this2 = this;\n        var detectNetwork, networkPromise, _yield$Promise$all, _yield$Promise$all2, expected, actual;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              if (!(_classPrivateFieldGet(this, _networkPromise) == null)) {\n                _context7.next = 6;\n                break;\n              }\n              // Detect the current network (shared with all calls)\n              detectNetwork = this._detectNetwork().then(function (network) {\n                _this2.emit(\"network\", network, null);\n                return network;\n              }, function (error) {\n                // Reset the networkPromise on failure, so we will try again\n                if (_classPrivateFieldGet(_this2, _networkPromise) === detectNetwork) {\n                  _classPrivateFieldSet(_this2, _networkPromise, null);\n                }\n                throw error;\n              });\n              _classPrivateFieldSet(this, _networkPromise, detectNetwork);\n              _context7.next = 5;\n              return detectNetwork;\n            case 5:\n              return _context7.abrupt(\"return\", _context7.sent.clone());\n            case 6:\n              networkPromise = _classPrivateFieldGet(this, _networkPromise);\n              _context7.next = 9;\n              return Promise.all([networkPromise, this._detectNetwork() // The actual connected network\n              ]);\n            case 9:\n              _yield$Promise$all = _context7.sent;\n              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n              expected = _yield$Promise$all2[0];\n              actual = _yield$Promise$all2[1];\n              if (expected.chainId !== actual.chainId) {\n                if (_classPrivateFieldGet(this, _anyNetwork)) {\n                  // The \"any\" network can change, so notify listeners\n                  this.emit(\"network\", actual, expected);\n                  // Update the network if something else hasn't already changed it\n                  if (_classPrivateFieldGet(this, _networkPromise) === networkPromise) {\n                    _classPrivateFieldSet(this, _networkPromise, Promise.resolve(actual));\n                  }\n                } else {\n                  // Otherwise, we do not allow changes to the underlying network\n                  assert(false, \"network changed: \".concat(expected.chainId, \" => \").concat(actual.chainId, \" \"), \"NETWORK_ERROR\", {\n                    event: \"changed\"\n                  });\n                }\n              }\n              return _context7.abrupt(\"return\", expected.clone());\n            case 15:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function getNetwork() {\n        return _getNetwork.apply(this, arguments);\n      }\n      return getNetwork;\n    }()\n  }, {\n    key: \"getFeeData\",\n    value: function () {\n      var _getFeeData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var _this3 = this;\n        var _yield$resolvePropert, block, gasPrice, maxFeePerGas, maxPriorityFeePerGas;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              _context9.next = 2;\n              return resolveProperties({\n                block: this.getBlock(\"latest\"),\n                gasPrice: _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n                  var _gasPrice;\n                  return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n                    while (1) switch (_context8.prev = _context8.next) {\n                      case 0:\n                        _context8.prev = 0;\n                        _context8.next = 3;\n                        return _classPrivateMethodGet(_this3, _perform, _perform2).call(_this3, {\n                          method: \"getGasPrice\"\n                        });\n                      case 3:\n                        _gasPrice = _context8.sent;\n                        return _context8.abrupt(\"return\", getBigInt(_gasPrice, \"%response\"));\n                      case 7:\n                        _context8.prev = 7;\n                        _context8.t0 = _context8[\"catch\"](0);\n                      case 9:\n                        return _context8.abrupt(\"return\", null);\n                      case 10:\n                      case \"end\":\n                        return _context8.stop();\n                    }\n                  }, _callee8, null, [[0, 7]]);\n                }))()\n              });\n            case 2:\n              _yield$resolvePropert = _context9.sent;\n              block = _yield$resolvePropert.block;\n              gasPrice = _yield$resolvePropert.gasPrice;\n              maxFeePerGas = null, maxPriorityFeePerGas = null;\n              if (block && block.baseFeePerGas) {\n                // We may want to compute this more accurately in the future,\n                // using the formula \"check if the base fee is correct\".\n                // See: https://eips.ethereum.org/EIPS/eip-1559\n                maxPriorityFeePerGas = BigInt(\"1000000000\");\n                // Allow a network to override their maximum priority fee per gas\n                //const priorityFeePlugin = (await this.getNetwork()).getPlugin<MaxPriorityFeePlugin>(\"org.ethers.plugins.max-priority-fee\");\n                //if (priorityFeePlugin) {\n                //    maxPriorityFeePerGas = await priorityFeePlugin.getPriorityFee(this);\n                //}\n                maxFeePerGas = block.baseFeePerGas * BN_2 + maxPriorityFeePerGas;\n              }\n              return _context9.abrupt(\"return\", new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas));\n            case 8:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this);\n      }));\n      function getFeeData() {\n        return _getFeeData.apply(this, arguments);\n      }\n      return getFeeData;\n    }()\n  }, {\n    key: \"estimateGas\",\n    value: function () {\n      var _estimateGas = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(_tx) {\n        var tx;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              tx = this._getTransactionRequest(_tx);\n              if (!isPromise(tx)) {\n                _context10.next = 5;\n                break;\n              }\n              _context10.next = 4;\n              return tx;\n            case 4:\n              tx = _context10.sent;\n            case 5:\n              _context10.t0 = getBigInt;\n              _context10.next = 8;\n              return _classPrivateMethodGet(this, _perform, _perform2).call(this, {\n                method: \"estimateGas\",\n                transaction: tx\n              });\n            case 8:\n              _context10.t1 = _context10.sent;\n              return _context10.abrupt(\"return\", (0, _context10.t0)(_context10.t1, \"%response\"));\n            case 10:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this);\n      }));\n      function estimateGas(_x7) {\n        return _estimateGas.apply(this, arguments);\n      }\n      return estimateGas;\n    }()\n  }, {\n    key: \"call\",\n    value: function () {\n      var _call3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(_tx) {\n        var _yield$resolvePropert2, tx, blockTag;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              _context11.next = 2;\n              return resolveProperties({\n                tx: this._getTransactionRequest(_tx),\n                blockTag: this._getBlockTag(_tx.blockTag)\n              });\n            case 2:\n              _yield$resolvePropert2 = _context11.sent;\n              tx = _yield$resolvePropert2.tx;\n              blockTag = _yield$resolvePropert2.blockTag;\n              _context11.next = 7;\n              return _classPrivateMethodGet(this, _checkNetwork, _checkNetwork2).call(this, _classPrivateMethodGet(this, _call, _call2).call(this, tx, blockTag, _tx.enableCcipRead ? 0 : -1));\n            case 7:\n              return _context11.abrupt(\"return\", _context11.sent);\n            case 8:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this);\n      }));\n      function call(_x8) {\n        return _call3.apply(this, arguments);\n      }\n      return call;\n    }()\n  }, {\n    key: \"getBalance\",\n    value: function () {\n      var _getBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(address, blockTag) {\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              _context12.t0 = getBigInt;\n              _context12.next = 3;\n              return _classPrivateMethodGet(this, _getAccountValue, _getAccountValue2).call(this, {\n                method: \"getBalance\"\n              }, address, blockTag);\n            case 3:\n              _context12.t1 = _context12.sent;\n              return _context12.abrupt(\"return\", (0, _context12.t0)(_context12.t1, \"%response\"));\n            case 5:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this);\n      }));\n      function getBalance(_x9, _x10) {\n        return _getBalance.apply(this, arguments);\n      }\n      return getBalance;\n    }()\n  }, {\n    key: \"getTransactionCount\",\n    value: function () {\n      var _getTransactionCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(address, blockTag) {\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              _context13.t0 = getNumber;\n              _context13.next = 3;\n              return _classPrivateMethodGet(this, _getAccountValue, _getAccountValue2).call(this, {\n                method: \"getTransactionCount\"\n              }, address, blockTag);\n            case 3:\n              _context13.t1 = _context13.sent;\n              return _context13.abrupt(\"return\", (0, _context13.t0)(_context13.t1, \"%response\"));\n            case 5:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, this);\n      }));\n      function getTransactionCount(_x11, _x12) {\n        return _getTransactionCount.apply(this, arguments);\n      }\n      return getTransactionCount;\n    }()\n  }, {\n    key: \"getCode\",\n    value: function () {\n      var _getCode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(address, blockTag) {\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              _context14.t0 = hexlify;\n              _context14.next = 3;\n              return _classPrivateMethodGet(this, _getAccountValue, _getAccountValue2).call(this, {\n                method: \"getCode\"\n              }, address, blockTag);\n            case 3:\n              _context14.t1 = _context14.sent;\n              return _context14.abrupt(\"return\", (0, _context14.t0)(_context14.t1));\n            case 5:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, _callee14, this);\n      }));\n      function getCode(_x13, _x14) {\n        return _getCode.apply(this, arguments);\n      }\n      return getCode;\n    }()\n  }, {\n    key: \"getStorage\",\n    value: function () {\n      var _getStorage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(address, _position, blockTag) {\n        var position;\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) switch (_context15.prev = _context15.next) {\n            case 0:\n              position = getBigInt(_position, \"position\");\n              _context15.t0 = hexlify;\n              _context15.next = 4;\n              return _classPrivateMethodGet(this, _getAccountValue, _getAccountValue2).call(this, {\n                method: \"getStorage\",\n                position: position\n              }, address, blockTag);\n            case 4:\n              _context15.t1 = _context15.sent;\n              return _context15.abrupt(\"return\", (0, _context15.t0)(_context15.t1));\n            case 6:\n            case \"end\":\n              return _context15.stop();\n          }\n        }, _callee15, this);\n      }));\n      function getStorage(_x15, _x16, _x17) {\n        return _getStorage.apply(this, arguments);\n      }\n      return getStorage;\n    }() // Write\n  }, {\n    key: \"broadcastTransaction\",\n    value: function () {\n      var _broadcastTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(signedTx) {\n        var _yield$resolvePropert3, blockNumber, hash, network, tx;\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) switch (_context16.prev = _context16.next) {\n            case 0:\n              _context16.next = 2;\n              return resolveProperties({\n                blockNumber: this.getBlockNumber(),\n                hash: this._perform({\n                  method: \"broadcastTransaction\",\n                  signedTransaction: signedTx\n                }),\n                network: this.getNetwork()\n              });\n            case 2:\n              _yield$resolvePropert3 = _context16.sent;\n              blockNumber = _yield$resolvePropert3.blockNumber;\n              hash = _yield$resolvePropert3.hash;\n              network = _yield$resolvePropert3.network;\n              tx = Transaction.from(signedTx);\n              if (!(tx.hash !== hash)) {\n                _context16.next = 9;\n                break;\n              }\n              throw new Error(\"@TODO: the returned hash did not match\");\n            case 9:\n              return _context16.abrupt(\"return\", this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber));\n            case 10:\n            case \"end\":\n              return _context16.stop();\n          }\n        }, _callee16, this);\n      }));\n      function broadcastTransaction(_x18) {\n        return _broadcastTransaction.apply(this, arguments);\n      }\n      return broadcastTransaction;\n    }()\n  }, {\n    key: \"getBlock\",\n    value: // Queries\n    function () {\n      var _getBlock3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(block, prefetchTxs) {\n        var _yield$resolvePropert4, network, params;\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              _context17.next = 2;\n              return resolveProperties({\n                network: this.getNetwork(),\n                params: _classPrivateMethodGet(this, _getBlock, _getBlock2).call(this, block, !!prefetchTxs)\n              });\n            case 2:\n              _yield$resolvePropert4 = _context17.sent;\n              network = _yield$resolvePropert4.network;\n              params = _yield$resolvePropert4.params;\n              if (!(params == null)) {\n                _context17.next = 7;\n                break;\n              }\n              return _context17.abrupt(\"return\", null);\n            case 7:\n              return _context17.abrupt(\"return\", this._wrapBlock(params, network));\n            case 8:\n            case \"end\":\n              return _context17.stop();\n          }\n        }, _callee17, this);\n      }));\n      function getBlock(_x19, _x20) {\n        return _getBlock3.apply(this, arguments);\n      }\n      return getBlock;\n    }()\n  }, {\n    key: \"getTransaction\",\n    value: function () {\n      var _getTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(hash) {\n        var _yield$resolvePropert5, network, params;\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) switch (_context18.prev = _context18.next) {\n            case 0:\n              _context18.next = 2;\n              return resolveProperties({\n                network: this.getNetwork(),\n                params: _classPrivateMethodGet(this, _perform, _perform2).call(this, {\n                  method: \"getTransaction\",\n                  hash: hash\n                })\n              });\n            case 2:\n              _yield$resolvePropert5 = _context18.sent;\n              network = _yield$resolvePropert5.network;\n              params = _yield$resolvePropert5.params;\n              if (!(params == null)) {\n                _context18.next = 7;\n                break;\n              }\n              return _context18.abrupt(\"return\", null);\n            case 7:\n              return _context18.abrupt(\"return\", this._wrapTransactionResponse(params, network));\n            case 8:\n            case \"end\":\n              return _context18.stop();\n          }\n        }, _callee18, this);\n      }));\n      function getTransaction(_x21) {\n        return _getTransaction.apply(this, arguments);\n      }\n      return getTransaction;\n    }()\n  }, {\n    key: \"getTransactionReceipt\",\n    value: function () {\n      var _getTransactionReceipt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(hash) {\n        var _yield$resolvePropert6, network, params, tx;\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) switch (_context19.prev = _context19.next) {\n            case 0:\n              _context19.next = 2;\n              return resolveProperties({\n                network: this.getNetwork(),\n                params: _classPrivateMethodGet(this, _perform, _perform2).call(this, {\n                  method: \"getTransactionReceipt\",\n                  hash: hash\n                })\n              });\n            case 2:\n              _yield$resolvePropert6 = _context19.sent;\n              network = _yield$resolvePropert6.network;\n              params = _yield$resolvePropert6.params;\n              if (!(params == null)) {\n                _context19.next = 7;\n                break;\n              }\n              return _context19.abrupt(\"return\", null);\n            case 7:\n              if (!(params.gasPrice == null && params.effectiveGasPrice == null)) {\n                _context19.next = 14;\n                break;\n              }\n              _context19.next = 10;\n              return _classPrivateMethodGet(this, _perform, _perform2).call(this, {\n                method: \"getTransaction\",\n                hash: hash\n              });\n            case 10:\n              tx = _context19.sent;\n              if (!(tx == null)) {\n                _context19.next = 13;\n                break;\n              }\n              throw new Error(\"report this; could not find tx or effectiveGasPrice\");\n            case 13:\n              params.effectiveGasPrice = tx.gasPrice;\n            case 14:\n              return _context19.abrupt(\"return\", this._wrapTransactionReceipt(params, network));\n            case 15:\n            case \"end\":\n              return _context19.stop();\n          }\n        }, _callee19, this);\n      }));\n      function getTransactionReceipt(_x22) {\n        return _getTransactionReceipt.apply(this, arguments);\n      }\n      return getTransactionReceipt;\n    }()\n  }, {\n    key: \"getTransactionResult\",\n    value: function () {\n      var _getTransactionResult = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(hash) {\n        var _yield$resolvePropert7, result;\n        return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n          while (1) switch (_context20.prev = _context20.next) {\n            case 0:\n              _context20.next = 2;\n              return resolveProperties({\n                network: this.getNetwork(),\n                result: _classPrivateMethodGet(this, _perform, _perform2).call(this, {\n                  method: \"getTransactionResult\",\n                  hash: hash\n                })\n              });\n            case 2:\n              _yield$resolvePropert7 = _context20.sent;\n              result = _yield$resolvePropert7.result;\n              if (!(result == null)) {\n                _context20.next = 6;\n                break;\n              }\n              return _context20.abrupt(\"return\", null);\n            case 6:\n              return _context20.abrupt(\"return\", hexlify(result));\n            case 7:\n            case \"end\":\n              return _context20.stop();\n          }\n        }, _callee20, this);\n      }));\n      function getTransactionResult(_x23) {\n        return _getTransactionResult.apply(this, arguments);\n      }\n      return getTransactionResult;\n    }() // Bloom-filter Queries\n  }, {\n    key: \"getLogs\",\n    value: function () {\n      var _getLogs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(_filter) {\n        var _this4 = this;\n        var filter, _yield$resolvePropert8, network, params;\n        return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n          while (1) switch (_context21.prev = _context21.next) {\n            case 0:\n              filter = this._getFilter(_filter);\n              if (!isPromise(filter)) {\n                _context21.next = 5;\n                break;\n              }\n              _context21.next = 4;\n              return filter;\n            case 4:\n              filter = _context21.sent;\n            case 5:\n              _context21.next = 7;\n              return resolveProperties({\n                network: this.getNetwork(),\n                params: _classPrivateMethodGet(this, _perform, _perform2).call(this, {\n                  method: \"getLogs\",\n                  filter: filter\n                })\n              });\n            case 7:\n              _yield$resolvePropert8 = _context21.sent;\n              network = _yield$resolvePropert8.network;\n              params = _yield$resolvePropert8.params;\n              return _context21.abrupt(\"return\", params.map(function (p) {\n                return _this4._wrapLog(p, network);\n              }));\n            case 11:\n            case \"end\":\n              return _context21.stop();\n          }\n        }, _callee21, this);\n      }));\n      function getLogs(_x24) {\n        return _getLogs.apply(this, arguments);\n      }\n      return getLogs;\n    }() // ENS\n  }, {\n    key: \"_getProvider\",\n    value: function _getProvider(chainId) {\n      assert(false, \"provider cannot connect to target network\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"_getProvider()\"\n      });\n    }\n  }, {\n    key: \"getResolver\",\n    value: function () {\n      var _getResolver = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(name) {\n        return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n          while (1) switch (_context22.prev = _context22.next) {\n            case 0:\n              _context22.next = 2;\n              return EnsResolver.fromName(this, name);\n            case 2:\n              return _context22.abrupt(\"return\", _context22.sent);\n            case 3:\n            case \"end\":\n              return _context22.stop();\n          }\n        }, _callee22, this);\n      }));\n      function getResolver(_x25) {\n        return _getResolver.apply(this, arguments);\n      }\n      return getResolver;\n    }()\n  }, {\n    key: \"getAvatar\",\n    value: function () {\n      var _getAvatar = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(name) {\n        var resolver;\n        return _regeneratorRuntime().wrap(function _callee23$(_context23) {\n          while (1) switch (_context23.prev = _context23.next) {\n            case 0:\n              _context23.next = 2;\n              return this.getResolver(name);\n            case 2:\n              resolver = _context23.sent;\n              if (!resolver) {\n                _context23.next = 7;\n                break;\n              }\n              _context23.next = 6;\n              return resolver.getAvatar();\n            case 6:\n              return _context23.abrupt(\"return\", _context23.sent);\n            case 7:\n              return _context23.abrupt(\"return\", null);\n            case 8:\n            case \"end\":\n              return _context23.stop();\n          }\n        }, _callee23, this);\n      }));\n      function getAvatar(_x26) {\n        return _getAvatar.apply(this, arguments);\n      }\n      return getAvatar;\n    }()\n  }, {\n    key: \"resolveName\",\n    value: function () {\n      var _resolveName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(name) {\n        var resolver;\n        return _regeneratorRuntime().wrap(function _callee24$(_context24) {\n          while (1) switch (_context24.prev = _context24.next) {\n            case 0:\n              _context24.next = 2;\n              return this.getResolver(name);\n            case 2:\n              resolver = _context24.sent;\n              if (!resolver) {\n                _context24.next = 7;\n                break;\n              }\n              _context24.next = 6;\n              return resolver.getAddress();\n            case 6:\n              return _context24.abrupt(\"return\", _context24.sent);\n            case 7:\n              return _context24.abrupt(\"return\", null);\n            case 8:\n            case \"end\":\n              return _context24.stop();\n          }\n        }, _callee24, this);\n      }));\n      function resolveName(_x27) {\n        return _resolveName.apply(this, arguments);\n      }\n      return resolveName;\n    }()\n  }, {\n    key: \"lookupAddress\",\n    value: function () {\n      var _lookupAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(address) {\n        var node, ensAddr, ensContract, resolver, resolverContract, name, check;\n        return _regeneratorRuntime().wrap(function _callee25$(_context25) {\n          while (1) switch (_context25.prev = _context25.next) {\n            case 0:\n              address = getAddress(address);\n              node = namehash(address.substring(2).toLowerCase() + \".addr.reverse\");\n              _context25.prev = 2;\n              _context25.next = 5;\n              return EnsResolver.getEnsAddress(this);\n            case 5:\n              ensAddr = _context25.sent;\n              ensContract = new Contract(ensAddr, [\"function resolver(bytes32) view returns (address)\"], this);\n              _context25.next = 9;\n              return ensContract.resolver(node);\n            case 9:\n              resolver = _context25.sent;\n              if (!(resolver == null || resolver === ZeroHash)) {\n                _context25.next = 12;\n                break;\n              }\n              return _context25.abrupt(\"return\", null);\n            case 12:\n              resolverContract = new Contract(resolver, [\"function name(bytes32) view returns (string)\"], this);\n              _context25.next = 15;\n              return resolverContract.name(node);\n            case 15:\n              name = _context25.sent;\n              _context25.next = 18;\n              return this.resolveName(name);\n            case 18:\n              check = _context25.sent;\n              if (!(check !== address)) {\n                _context25.next = 21;\n                break;\n              }\n              return _context25.abrupt(\"return\", null);\n            case 21:\n              return _context25.abrupt(\"return\", name);\n            case 24:\n              _context25.prev = 24;\n              _context25.t0 = _context25[\"catch\"](2);\n              if (!(isError(_context25.t0, \"BAD_DATA\") && _context25.t0.value === \"0x\")) {\n                _context25.next = 28;\n                break;\n              }\n              return _context25.abrupt(\"return\", null);\n            case 28:\n              if (!isError(_context25.t0, \"CALL_EXCEPTION\")) {\n                _context25.next = 30;\n                break;\n              }\n              return _context25.abrupt(\"return\", null);\n            case 30:\n              throw _context25.t0;\n            case 31:\n              return _context25.abrupt(\"return\", null);\n            case 32:\n            case \"end\":\n              return _context25.stop();\n          }\n        }, _callee25, this, [[2, 24]]);\n      }));\n      function lookupAddress(_x28) {\n        return _lookupAddress.apply(this, arguments);\n      }\n      return lookupAddress;\n    }()\n  }, {\n    key: \"waitForTransaction\",\n    value: function () {\n      var _waitForTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28(hash, _confirms, timeout) {\n        var _this5 = this;\n        var confirms;\n        return _regeneratorRuntime().wrap(function _callee28$(_context28) {\n          while (1) switch (_context28.prev = _context28.next) {\n            case 0:\n              confirms = _confirms != null ? _confirms : 1;\n              if (!(confirms === 0)) {\n                _context28.next = 3;\n                break;\n              }\n              return _context28.abrupt(\"return\", this.getTransactionReceipt(hash));\n            case 3:\n              return _context28.abrupt(\"return\", new Promise( /*#__PURE__*/function () {\n                var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27(resolve, reject) {\n                  var timer, listener;\n                  return _regeneratorRuntime().wrap(function _callee27$(_context27) {\n                    while (1) switch (_context27.prev = _context27.next) {\n                      case 0:\n                        timer = null;\n                        listener = /*#__PURE__*/function () {\n                          var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26(blockNumber) {\n                            var receipt;\n                            return _regeneratorRuntime().wrap(function _callee26$(_context26) {\n                              while (1) switch (_context26.prev = _context26.next) {\n                                case 0:\n                                  _context26.prev = 0;\n                                  _context26.next = 3;\n                                  return _this5.getTransactionReceipt(hash);\n                                case 3:\n                                  receipt = _context26.sent;\n                                  if (!(receipt != null)) {\n                                    _context26.next = 9;\n                                    break;\n                                  }\n                                  if (!(blockNumber - receipt.blockNumber + 1 >= confirms)) {\n                                    _context26.next = 9;\n                                    break;\n                                  }\n                                  resolve(receipt);\n                                  //this.off(\"block\", listener);\n                                  if (timer) {\n                                    clearTimeout(timer);\n                                    timer = null;\n                                  }\n                                  return _context26.abrupt(\"return\");\n                                case 9:\n                                  _context26.next = 14;\n                                  break;\n                                case 11:\n                                  _context26.prev = 11;\n                                  _context26.t0 = _context26[\"catch\"](0);\n                                  console.log(\"EEE\", _context26.t0);\n                                case 14:\n                                  _this5.once(\"block\", listener);\n                                case 15:\n                                case \"end\":\n                                  return _context26.stop();\n                              }\n                            }, _callee26, null, [[0, 11]]);\n                          }));\n                          return function listener(_x34) {\n                            return _ref6.apply(this, arguments);\n                          };\n                        }();\n                        if (timeout != null) {\n                          timer = setTimeout(function () {\n                            if (timer == null) {\n                              return;\n                            }\n                            timer = null;\n                            _this5.off(\"block\", listener);\n                            reject(makeError(\"timeout\", \"TIMEOUT\", {\n                              reason: \"timeout\"\n                            }));\n                          }, timeout);\n                        }\n                        _context27.t0 = listener;\n                        _context27.next = 6;\n                        return _this5.getBlockNumber();\n                      case 6:\n                        _context27.t1 = _context27.sent;\n                        (0, _context27.t0)(_context27.t1);\n                      case 8:\n                      case \"end\":\n                        return _context27.stop();\n                    }\n                  }, _callee27);\n                }));\n                return function (_x32, _x33) {\n                  return _ref5.apply(this, arguments);\n                };\n              }()));\n            case 4:\n            case \"end\":\n              return _context28.stop();\n          }\n        }, _callee28, this);\n      }));\n      function waitForTransaction(_x29, _x30, _x31) {\n        return _waitForTransaction.apply(this, arguments);\n      }\n      return waitForTransaction;\n    }()\n  }, {\n    key: \"waitForBlock\",\n    value: function () {\n      var _waitForBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee29(blockTag) {\n        return _regeneratorRuntime().wrap(function _callee29$(_context29) {\n          while (1) switch (_context29.prev = _context29.next) {\n            case 0:\n              assert(false, \"not implemented yet\", \"NOT_IMPLEMENTED\", {\n                operation: \"waitForBlock\"\n              });\n            case 1:\n            case \"end\":\n              return _context29.stop();\n          }\n        }, _callee29);\n      }));\n      function waitForBlock(_x35) {\n        return _waitForBlock.apply(this, arguments);\n      }\n      return waitForBlock;\n    }()\n  }, {\n    key: \"_clearTimeout\",\n    value: function _clearTimeout(timerId) {\n      var timer = _classPrivateFieldGet(this, _timers).get(timerId);\n      if (!timer) {\n        return;\n      }\n      if (timer.timer) {\n        clearTimeout(timer.timer);\n      }\n      _classPrivateFieldGet(this, _timers).delete(timerId);\n    }\n  }, {\n    key: \"_setTimeout\",\n    value: function _setTimeout(_func, timeout) {\n      var _this$nextTimer,\n        _this$nextTimer2,\n        _this6 = this;\n      if (timeout == null) {\n        timeout = 0;\n      }\n      var timerId = (_classPrivateFieldSet(this, _nextTimer, (_this$nextTimer = _classPrivateFieldGet(this, _nextTimer), _this$nextTimer2 = _this$nextTimer++, _this$nextTimer)), _this$nextTimer2);\n      var func = function func() {\n        _classPrivateFieldGet(_this6, _timers).delete(timerId);\n        _func();\n      };\n      if (this.paused) {\n        _classPrivateFieldGet(this, _timers).set(timerId, {\n          timer: null,\n          func: func,\n          time: timeout\n        });\n      } else {\n        var timer = setTimeout(func, timeout);\n        _classPrivateFieldGet(this, _timers).set(timerId, {\n          timer: timer,\n          func: func,\n          time: getTime()\n        });\n      }\n      return timerId;\n    }\n  }, {\n    key: \"_forEachSubscriber\",\n    value: function _forEachSubscriber(func) {\n      var _iterator2 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _subs).values()),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var sub = _step2.value;\n          func(sub.subscriber);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    // Event API; sub-classes should override this; any supported\n    // event filter will have been munged into an EventFilter\n  }, {\n    key: \"_getSubscriber\",\n    value: function _getSubscriber(sub) {\n      switch (sub.type) {\n        case \"debug\":\n        case \"network\":\n          return new UnmanagedSubscriber(sub.type);\n        case \"block\":\n          return new PollingBlockSubscriber(this);\n        case \"event\":\n          return new PollingEventSubscriber(this, sub.filter);\n        case \"transaction\":\n          return new PollingTransactionSubscriber(this, sub.hash);\n        case \"orphan\":\n          return new PollingOrphanSubscriber(this, sub.filter);\n      }\n      throw new Error(\"unsupported event: \".concat(sub.type));\n    }\n  }, {\n    key: \"_recoverSubscriber\",\n    value: function _recoverSubscriber(oldSub, newSub) {\n      var _iterator3 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _subs).values()),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var sub = _step3.value;\n          if (sub.subscriber === oldSub) {\n            if (sub.started) {\n              sub.subscriber.stop();\n            }\n            sub.subscriber = newSub;\n            if (sub.started) {\n              newSub.start();\n            }\n            if (_classPrivateFieldGet(this, _pausedState) != null) {\n              newSub.pause(_classPrivateFieldGet(this, _pausedState));\n            }\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"on\",\n    value: function () {\n      var _on = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee30(event, listener) {\n        var sub;\n        return _regeneratorRuntime().wrap(function _callee30$(_context30) {\n          while (1) switch (_context30.prev = _context30.next) {\n            case 0:\n              _context30.next = 2;\n              return _classPrivateMethodGet(this, _getSub, _getSub2).call(this, event);\n            case 2:\n              sub = _context30.sent;\n              sub.listeners.push({\n                listener: listener,\n                once: false\n              });\n              if (!sub.started) {\n                sub.subscriber.start();\n                sub.started = true;\n                if (_classPrivateFieldGet(this, _pausedState) != null) {\n                  sub.subscriber.pause(_classPrivateFieldGet(this, _pausedState));\n                }\n              }\n              return _context30.abrupt(\"return\", this);\n            case 6:\n            case \"end\":\n              return _context30.stop();\n          }\n        }, _callee30, this);\n      }));\n      function on(_x36, _x37) {\n        return _on.apply(this, arguments);\n      }\n      return on;\n    }()\n  }, {\n    key: \"once\",\n    value: function () {\n      var _once = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee31(event, listener) {\n        var sub;\n        return _regeneratorRuntime().wrap(function _callee31$(_context31) {\n          while (1) switch (_context31.prev = _context31.next) {\n            case 0:\n              _context31.next = 2;\n              return _classPrivateMethodGet(this, _getSub, _getSub2).call(this, event);\n            case 2:\n              sub = _context31.sent;\n              sub.listeners.push({\n                listener: listener,\n                once: true\n              });\n              if (!sub.started) {\n                sub.subscriber.start();\n                sub.started = true;\n                if (_classPrivateFieldGet(this, _pausedState) != null) {\n                  sub.subscriber.pause(_classPrivateFieldGet(this, _pausedState));\n                }\n              }\n              return _context31.abrupt(\"return\", this);\n            case 6:\n            case \"end\":\n              return _context31.stop();\n          }\n        }, _callee31, this);\n      }));\n      function once(_x38, _x39) {\n        return _once.apply(this, arguments);\n      }\n      return once;\n    }()\n  }, {\n    key: \"emit\",\n    value: function () {\n      var _emit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee32(event) {\n        var _this7 = this;\n        var _len,\n          args,\n          _key,\n          sub,\n          count,\n          _args32 = arguments;\n        return _regeneratorRuntime().wrap(function _callee32$(_context32) {\n          while (1) switch (_context32.prev = _context32.next) {\n            case 0:\n              for (_len = _args32.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = _args32[_key];\n              }\n              _context32.next = 3;\n              return _classPrivateMethodGet(this, _hasSub, _hasSub2).call(this, event, args);\n            case 3:\n              sub = _context32.sent;\n              if (!(!sub || sub.listeners.length === 0)) {\n                _context32.next = 6;\n                break;\n              }\n              return _context32.abrupt(\"return\", false);\n            case 6:\n              ;\n              count = sub.listeners.length;\n              sub.listeners = sub.listeners.filter(function (_ref7) {\n                var listener = _ref7.listener,\n                  once = _ref7.once;\n                var payload = new EventPayload(_this7, once ? null : listener, event);\n                try {\n                  listener.call.apply(listener, [_this7].concat(args, [payload]));\n                } catch (error) {}\n                return !once;\n              });\n              if (sub.listeners.length === 0) {\n                if (sub.started) {\n                  sub.subscriber.stop();\n                }\n                _classPrivateFieldGet(this, _subs).delete(sub.tag);\n              }\n              return _context32.abrupt(\"return\", count > 0);\n            case 11:\n            case \"end\":\n              return _context32.stop();\n          }\n        }, _callee32, this);\n      }));\n      function emit(_x40) {\n        return _emit.apply(this, arguments);\n      }\n      return emit;\n    }()\n  }, {\n    key: \"listenerCount\",\n    value: function () {\n      var _listenerCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee33(event) {\n        var sub, total, _iterator4, _step4, listeners;\n        return _regeneratorRuntime().wrap(function _callee33$(_context33) {\n          while (1) switch (_context33.prev = _context33.next) {\n            case 0:\n              if (!event) {\n                _context33.next = 7;\n                break;\n              }\n              _context33.next = 3;\n              return _classPrivateMethodGet(this, _hasSub, _hasSub2).call(this, event);\n            case 3:\n              sub = _context33.sent;\n              if (sub) {\n                _context33.next = 6;\n                break;\n              }\n              return _context33.abrupt(\"return\", 0);\n            case 6:\n              return _context33.abrupt(\"return\", sub.listeners.length);\n            case 7:\n              total = 0;\n              _iterator4 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _subs).values());\n              try {\n                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                  listeners = _step4.value.listeners;\n                  total += listeners.length;\n                }\n              } catch (err) {\n                _iterator4.e(err);\n              } finally {\n                _iterator4.f();\n              }\n              return _context33.abrupt(\"return\", total);\n            case 11:\n            case \"end\":\n              return _context33.stop();\n          }\n        }, _callee33, this);\n      }));\n      function listenerCount(_x41) {\n        return _listenerCount.apply(this, arguments);\n      }\n      return listenerCount;\n    }()\n  }, {\n    key: \"listeners\",\n    value: function () {\n      var _listeners = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee34(event) {\n        var sub, result, _iterator5, _step5, _listeners2;\n        return _regeneratorRuntime().wrap(function _callee34$(_context34) {\n          while (1) switch (_context34.prev = _context34.next) {\n            case 0:\n              if (!event) {\n                _context34.next = 7;\n                break;\n              }\n              _context34.next = 3;\n              return _classPrivateMethodGet(this, _hasSub, _hasSub2).call(this, event);\n            case 3:\n              sub = _context34.sent;\n              if (sub) {\n                _context34.next = 6;\n                break;\n              }\n              return _context34.abrupt(\"return\", []);\n            case 6:\n              return _context34.abrupt(\"return\", sub.listeners.map(function (_ref8) {\n                var listener = _ref8.listener;\n                return listener;\n              }));\n            case 7:\n              result = [];\n              _iterator5 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _subs).values());\n              try {\n                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                  _listeners2 = _step5.value.listeners;\n                  result = result.concat(_listeners2.map(function (_ref9) {\n                    var listener = _ref9.listener;\n                    return listener;\n                  }));\n                }\n              } catch (err) {\n                _iterator5.e(err);\n              } finally {\n                _iterator5.f();\n              }\n              return _context34.abrupt(\"return\", result);\n            case 11:\n            case \"end\":\n              return _context34.stop();\n          }\n        }, _callee34, this);\n      }));\n      function listeners(_x42) {\n        return _listeners.apply(this, arguments);\n      }\n      return listeners;\n    }()\n  }, {\n    key: \"off\",\n    value: function () {\n      var _off = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee35(event, listener) {\n        var sub, index;\n        return _regeneratorRuntime().wrap(function _callee35$(_context35) {\n          while (1) switch (_context35.prev = _context35.next) {\n            case 0:\n              _context35.next = 2;\n              return _classPrivateMethodGet(this, _hasSub, _hasSub2).call(this, event);\n            case 2:\n              sub = _context35.sent;\n              if (sub) {\n                _context35.next = 5;\n                break;\n              }\n              return _context35.abrupt(\"return\", this);\n            case 5:\n              if (listener) {\n                index = sub.listeners.map(function (_ref10) {\n                  var listener = _ref10.listener;\n                  return listener;\n                }).indexOf(listener);\n                if (index >= 0) {\n                  sub.listeners.splice(index, 1);\n                }\n              }\n              if (!listener || sub.listeners.length === 0) {\n                if (sub.started) {\n                  sub.subscriber.stop();\n                }\n                _classPrivateFieldGet(this, _subs).delete(sub.tag);\n              }\n              return _context35.abrupt(\"return\", this);\n            case 8:\n            case \"end\":\n              return _context35.stop();\n          }\n        }, _callee35, this);\n      }));\n      function off(_x43, _x44) {\n        return _off.apply(this, arguments);\n      }\n      return off;\n    }()\n  }, {\n    key: \"removeAllListeners\",\n    value: function () {\n      var _removeAllListeners = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee36(event) {\n        var _yield$_classPrivateM, tag, started, subscriber, _iterator6, _step6, _step6$value, _tag, _step6$value$, _started, _subscriber;\n        return _regeneratorRuntime().wrap(function _callee36$(_context36) {\n          while (1) switch (_context36.prev = _context36.next) {\n            case 0:\n              if (!event) {\n                _context36.next = 11;\n                break;\n              }\n              _context36.next = 3;\n              return _classPrivateMethodGet(this, _getSub, _getSub2).call(this, event);\n            case 3:\n              _yield$_classPrivateM = _context36.sent;\n              tag = _yield$_classPrivateM.tag;\n              started = _yield$_classPrivateM.started;\n              subscriber = _yield$_classPrivateM.subscriber;\n              if (started) {\n                subscriber.stop();\n              }\n              _classPrivateFieldGet(this, _subs).delete(tag);\n              _context36.next = 13;\n              break;\n            case 11:\n              _iterator6 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _subs));\n              try {\n                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                  _step6$value = _slicedToArray(_step6.value, 2), _tag = _step6$value[0], _step6$value$ = _step6$value[1], _started = _step6$value$.started, _subscriber = _step6$value$.subscriber;\n                  if (_started) {\n                    _subscriber.stop();\n                  }\n                  _classPrivateFieldGet(this, _subs).delete(_tag);\n                }\n              } catch (err) {\n                _iterator6.e(err);\n              } finally {\n                _iterator6.f();\n              }\n            case 13:\n              return _context36.abrupt(\"return\", this);\n            case 14:\n            case \"end\":\n              return _context36.stop();\n          }\n        }, _callee36, this);\n      }));\n      function removeAllListeners(_x45) {\n        return _removeAllListeners.apply(this, arguments);\n      }\n      return removeAllListeners;\n    }() // Alias for \"on\"\n  }, {\n    key: \"addListener\",\n    value: function () {\n      var _addListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee37(event, listener) {\n        return _regeneratorRuntime().wrap(function _callee37$(_context37) {\n          while (1) switch (_context37.prev = _context37.next) {\n            case 0:\n              _context37.next = 2;\n              return this.on(event, listener);\n            case 2:\n              return _context37.abrupt(\"return\", _context37.sent);\n            case 3:\n            case \"end\":\n              return _context37.stop();\n          }\n        }, _callee37, this);\n      }));\n      function addListener(_x46, _x47) {\n        return _addListener.apply(this, arguments);\n      }\n      return addListener;\n    }() // Alias for \"off\"\n  }, {\n    key: \"removeListener\",\n    value: function () {\n      var _removeListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee38(event, listener) {\n        return _regeneratorRuntime().wrap(function _callee38$(_context38) {\n          while (1) switch (_context38.prev = _context38.next) {\n            case 0:\n              return _context38.abrupt(\"return\", this.off(event, listener));\n            case 1:\n            case \"end\":\n              return _context38.stop();\n          }\n        }, _callee38, this);\n      }));\n      function removeListener(_x48, _x49) {\n        return _removeListener.apply(this, arguments);\n      }\n      return removeListener;\n    }() // Sub-classes should override this to shutdown any sockets, etc.\n    // but MUST call this super.shutdown.\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      // Stop all listeners\n      this.removeAllListeners();\n      // Shut down all tiemrs\n      var _iterator7 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _timers).keys()),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var timerId = _step7.value;\n          this._clearTimeout(timerId);\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  }, {\n    key: \"paused\",\n    get: function get() {\n      return _classPrivateFieldGet(this, _pausedState) != null;\n    },\n    set: function set(pause) {\n      if (!!pause === this.paused) {\n        return;\n      }\n      if (this.paused) {\n        this.resume();\n      } else {\n        this.pause(false);\n      }\n    }\n  }, {\n    key: \"pause\",\n    value: function pause(dropWhilePaused) {\n      _classPrivateFieldSet(this, _lastBlockNumber, -1);\n      if (_classPrivateFieldGet(this, _pausedState) != null) {\n        if (_classPrivateFieldGet(this, _pausedState) == !!dropWhilePaused) {\n          return;\n        }\n        assert(false, \"cannot change pause type; resume first\", \"UNSUPPORTED_OPERATION\", {\n          operation: \"pause\"\n        });\n      }\n      this._forEachSubscriber(function (s) {\n        return s.pause(dropWhilePaused);\n      });\n      _classPrivateFieldSet(this, _pausedState, !!dropWhilePaused);\n      var _iterator8 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _timers).values()),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var timer = _step8.value;\n          // Clear the timer\n          if (timer.timer) {\n            clearTimeout(timer.timer);\n          }\n          // Remaining time needed for when we become unpaused\n          timer.time = getTime() - timer.time;\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      if (_classPrivateFieldGet(this, _pausedState) == null) {\n        return;\n      }\n      this._forEachSubscriber(function (s) {\n        return s.resume();\n      });\n      _classPrivateFieldSet(this, _pausedState, null);\n      var _iterator9 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _timers).values()),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var timer = _step9.value;\n          // Remaining time when we were paused\n          var timeout = timer.time;\n          if (timeout < 0) {\n            timeout = 0;\n          }\n          // Start time (in cause paused, so we con compute remaininf time)\n          timer.time = getTime();\n          // Start the timer\n          setTimeout(timer.func, timeout);\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n    }\n  }]);\n  return AbstractProvider;\n}();\nfunction _perform2(_x50) {\n  return _perform4.apply(this, arguments);\n}\nfunction _perform4() {\n  _perform4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee41(req) {\n    var _this8 = this;\n    var tag, perform;\n    return _regeneratorRuntime().wrap(function _callee41$(_context41) {\n      while (1) switch (_context41.prev = _context41.next) {\n        case 0:\n          // Create a tag\n          tag = getTag(req.method, req);\n          perform = _classPrivateFieldGet(this, _performCache).get(tag);\n          if (!perform) {\n            perform = this._perform(req);\n            _classPrivateFieldGet(this, _performCache).set(tag, perform);\n            setTimeout(function () {\n              if (_classPrivateFieldGet(_this8, _performCache).get(tag) === perform) {\n                _classPrivateFieldGet(_this8, _performCache).delete(tag);\n              }\n            }, 250);\n          }\n          _context41.next = 5;\n          return perform;\n        case 5:\n          return _context41.abrupt(\"return\", _context41.sent);\n        case 6:\n        case \"end\":\n          return _context41.stop();\n      }\n    }, _callee41, this);\n  }));\n  return _perform4.apply(this, arguments);\n}\nfunction _call2(_x51, _x52, _x53) {\n  return _call4.apply(this, arguments);\n}\nfunction _call4() {\n  _call4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee42(tx, blockTag, attempt) {\n    var transaction, data, txSender, ccipArgs, ccipResult, _tx2, result;\n    return _regeneratorRuntime().wrap(function _callee42$(_context42) {\n      while (1) switch (_context42.prev = _context42.next) {\n        case 0:\n          assert(attempt < MAX_CCIP_REDIRECTS, \"CCIP read exceeded maximum redirections\", \"OFFCHAIN_FAULT\", {\n            reason: \"TOO_MANY_REDIRECTS\",\n            transaction: Object.assign({}, tx, {\n              blockTag: blockTag,\n              enableCcipRead: true\n            })\n          });\n          // This came in as a PerformActionTransaction, so to/from are safe; we can cast\n          transaction = copyRequest(tx);\n          _context42.prev = 2;\n          _context42.t0 = hexlify;\n          _context42.next = 6;\n          return this._perform({\n            method: \"call\",\n            transaction: transaction,\n            blockTag: blockTag\n          });\n        case 6:\n          _context42.t1 = _context42.sent;\n          return _context42.abrupt(\"return\", (0, _context42.t0)(_context42.t1));\n        case 10:\n          _context42.prev = 10;\n          _context42.t2 = _context42[\"catch\"](2);\n          if (!(!this.disableCcipRead && isCallException(_context42.t2) && _context42.t2.data && attempt >= 0 && blockTag === \"latest\" && transaction.to != null && dataSlice(_context42.t2.data, 0, 4) === \"0x556f1830\")) {\n            _context42.next = 37;\n            break;\n          }\n          data = _context42.t2.data;\n          _context42.next = 16;\n          return resolveAddress(transaction.to, this);\n        case 16:\n          txSender = _context42.sent;\n          try {\n            ccipArgs = parseOffchainLookup(dataSlice(_context42.t2.data, 4));\n          } catch (error) {\n            assert(false, error.message, \"OFFCHAIN_FAULT\", {\n              reason: \"BAD_DATA\",\n              transaction: transaction,\n              info: {\n                data: data\n              }\n            });\n          }\n          // Check the sender of the OffchainLookup matches the transaction\n          assert(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), \"CCIP Read sender mismatch\", \"CALL_EXCEPTION\", {\n            action: \"call\",\n            data: data,\n            reason: \"OffchainLookup\",\n            transaction: transaction,\n            invocation: null,\n            revert: {\n              signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n              name: \"OffchainLookup\",\n              args: ccipArgs.errorArgs\n            }\n          });\n          _context42.next = 21;\n          return this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);\n        case 21:\n          ccipResult = _context42.sent;\n          assert(ccipResult != null, \"CCIP Read failed to fetch data\", \"OFFCHAIN_FAULT\", {\n            reason: \"FETCH_FAILED\",\n            transaction: transaction,\n            info: {\n              data: _context42.t2.data,\n              errorArgs: ccipArgs.errorArgs\n            }\n          });\n          _tx2 = {\n            to: txSender,\n            data: concat([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])\n          };\n          this.emit(\"debug\", {\n            action: \"sendCcipReadCall\",\n            transaction: _tx2\n          });\n          _context42.prev = 25;\n          _context42.next = 28;\n          return _classPrivateMethodGet(this, _call, _call2).call(this, _tx2, blockTag, attempt + 1);\n        case 28:\n          result = _context42.sent;\n          this.emit(\"debug\", {\n            action: \"receiveCcipReadCallResult\",\n            transaction: Object.assign({}, _tx2),\n            result: result\n          });\n          return _context42.abrupt(\"return\", result);\n        case 33:\n          _context42.prev = 33;\n          _context42.t3 = _context42[\"catch\"](25);\n          this.emit(\"debug\", {\n            action: \"receiveCcipReadCallError\",\n            transaction: Object.assign({}, _tx2),\n            error: _context42.t3\n          });\n          throw _context42.t3;\n        case 37:\n          throw _context42.t2;\n        case 38:\n        case \"end\":\n          return _context42.stop();\n      }\n    }, _callee42, this, [[2, 10], [25, 33]]);\n  }));\n  return _call4.apply(this, arguments);\n}\nfunction _checkNetwork2(_x54) {\n  return _checkNetwork3.apply(this, arguments);\n}\nfunction _checkNetwork3() {\n  _checkNetwork3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee43(promise) {\n    var _yield$resolvePropert9, value;\n    return _regeneratorRuntime().wrap(function _callee43$(_context43) {\n      while (1) switch (_context43.prev = _context43.next) {\n        case 0:\n          _context43.next = 2;\n          return resolveProperties({\n            network: this.getNetwork(),\n            value: promise\n          });\n        case 2:\n          _yield$resolvePropert9 = _context43.sent;\n          value = _yield$resolvePropert9.value;\n          return _context43.abrupt(\"return\", value);\n        case 5:\n        case \"end\":\n          return _context43.stop();\n      }\n    }, _callee43, this);\n  }));\n  return _checkNetwork3.apply(this, arguments);\n}\nfunction _getAccountValue2(_x55, _x56, _x57) {\n  return _getAccountValue3.apply(this, arguments);\n}\nfunction _getAccountValue3() {\n  _getAccountValue3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee44(request, _address, _blockTag) {\n    var address, blockTag, _yield$Promise$all3, _yield$Promise$all4;\n    return _regeneratorRuntime().wrap(function _callee44$(_context44) {\n      while (1) switch (_context44.prev = _context44.next) {\n        case 0:\n          address = this._getAddress(_address);\n          blockTag = this._getBlockTag(_blockTag);\n          if (!(typeof address !== \"string\" || typeof blockTag !== \"string\")) {\n            _context44.next = 9;\n            break;\n          }\n          _context44.next = 5;\n          return Promise.all([address, blockTag]);\n        case 5:\n          _yield$Promise$all3 = _context44.sent;\n          _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 2);\n          address = _yield$Promise$all4[0];\n          blockTag = _yield$Promise$all4[1];\n        case 9:\n          _context44.next = 11;\n          return _classPrivateMethodGet(this, _checkNetwork, _checkNetwork2).call(this, _classPrivateMethodGet(this, _perform, _perform2).call(this, Object.assign(request, {\n            address: address,\n            blockTag: blockTag\n          })));\n        case 11:\n          return _context44.abrupt(\"return\", _context44.sent);\n        case 12:\n        case \"end\":\n          return _context44.stop();\n      }\n    }, _callee44, this);\n  }));\n  return _getAccountValue3.apply(this, arguments);\n}\nfunction _getBlock2(_x58, _x59) {\n  return _getBlock4.apply(this, arguments);\n}\nfunction _getBlock4() {\n  _getBlock4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee45(block, includeTransactions) {\n    var blockTag;\n    return _regeneratorRuntime().wrap(function _callee45$(_context45) {\n      while (1) switch (_context45.prev = _context45.next) {\n        case 0:\n          if (!isHexString(block, 32)) {\n            _context45.next = 4;\n            break;\n          }\n          _context45.next = 3;\n          return _classPrivateMethodGet(this, _perform, _perform2).call(this, {\n            method: \"getBlock\",\n            blockHash: block,\n            includeTransactions: includeTransactions\n          });\n        case 3:\n          return _context45.abrupt(\"return\", _context45.sent);\n        case 4:\n          blockTag = this._getBlockTag(block);\n          if (!(typeof blockTag !== \"string\")) {\n            _context45.next = 9;\n            break;\n          }\n          _context45.next = 8;\n          return blockTag;\n        case 8:\n          blockTag = _context45.sent;\n        case 9:\n          _context45.next = 11;\n          return _classPrivateMethodGet(this, _perform, _perform2).call(this, {\n            method: \"getBlock\",\n            blockTag: blockTag,\n            includeTransactions: includeTransactions\n          });\n        case 11:\n          return _context45.abrupt(\"return\", _context45.sent);\n        case 12:\n        case \"end\":\n          return _context45.stop();\n      }\n    }, _callee45, this);\n  }));\n  return _getBlock4.apply(this, arguments);\n}\nfunction _hasSub2(_x60, _x61) {\n  return _hasSub3.apply(this, arguments);\n}\nfunction _hasSub3() {\n  _hasSub3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee46(event, emitArgs) {\n    var sub;\n    return _regeneratorRuntime().wrap(function _callee46$(_context46) {\n      while (1) switch (_context46.prev = _context46.next) {\n        case 0:\n          _context46.next = 2;\n          return getSubscription(event, this);\n        case 2:\n          sub = _context46.sent;\n          if (!(sub.type === \"event\" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true)) {\n            _context46.next = 7;\n            break;\n          }\n          _context46.next = 6;\n          return getSubscription({\n            orphan: \"drop-log\",\n            log: emitArgs[0]\n          }, this);\n        case 6:\n          sub = _context46.sent;\n        case 7:\n          return _context46.abrupt(\"return\", _classPrivateFieldGet(this, _subs).get(sub.tag) || null);\n        case 8:\n        case \"end\":\n          return _context46.stop();\n      }\n    }, _callee46, this);\n  }));\n  return _hasSub3.apply(this, arguments);\n}\nfunction _getSub2(_x62) {\n  return _getSub3.apply(this, arguments);\n}\nfunction _getSub3() {\n  _getSub3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee47(event) {\n    var subscription, tag, sub, subscriber, addressableMap, nameMap;\n    return _regeneratorRuntime().wrap(function _callee47$(_context47) {\n      while (1) switch (_context47.prev = _context47.next) {\n        case 0:\n          _context47.next = 2;\n          return getSubscription(event, this);\n        case 2:\n          subscription = _context47.sent;\n          // Prevent tampering with our tag in any subclass' _getSubscriber\n          tag = subscription.tag;\n          sub = _classPrivateFieldGet(this, _subs).get(tag);\n          if (!sub) {\n            subscriber = this._getSubscriber(subscription);\n            addressableMap = new WeakMap();\n            nameMap = new Map();\n            sub = {\n              subscriber: subscriber,\n              tag: tag,\n              addressableMap: addressableMap,\n              nameMap: nameMap,\n              started: false,\n              listeners: []\n            };\n            _classPrivateFieldGet(this, _subs).set(tag, sub);\n          }\n          return _context47.abrupt(\"return\", sub);\n        case 7:\n        case \"end\":\n          return _context47.stop();\n      }\n    }, _callee47, this);\n  }));\n  return _getSub3.apply(this, arguments);\n}\nfunction _parseString(result, start) {\n  try {\n    var bytes = _parseBytes(result, start);\n    if (bytes) {\n      return toUtf8String(bytes);\n    }\n  } catch (error) {}\n  return null;\n}\nfunction _parseBytes(result, start) {\n  if (result === \"0x\") {\n    return null;\n  }\n  try {\n    var offset = getNumber(dataSlice(result, start, start + 32));\n    var length = getNumber(dataSlice(result, offset, offset + 32));\n    return dataSlice(result, offset + 32, offset + 32 + length);\n  } catch (error) {}\n  return null;\n}\nfunction numPad(value) {\n  var result = toBeArray(value);\n  if (result.length > 32) {\n    throw new Error(\"internal; should not happen\");\n  }\n  var padded = new Uint8Array(32);\n  padded.set(result, 32 - result.length);\n  return padded;\n}\nfunction bytesPad(value) {\n  if (value.length % 32 === 0) {\n    return value;\n  }\n  var result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n  result.set(value);\n  return result;\n}\nvar empty = new Uint8Array([]);\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas) {\n  var result = [];\n  var byteCount = 0;\n  // Add place-holders for pointers as we add items\n  for (var i = 0; i < datas.length; i++) {\n    result.push(empty);\n    byteCount += 32;\n  }\n  for (var _i = 0; _i < datas.length; _i++) {\n    var data = getBytes(datas[_i]);\n    // Update the bytes offset\n    result[_i] = numPad(byteCount);\n    // The length and padded value of data\n    result.push(numPad(data.length));\n    result.push(bytesPad(data));\n    byteCount += 32 + Math.ceil(data.length / 32) * 32;\n  }\n  return concat(result);\n}\nvar zeros = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\nfunction parseOffchainLookup(data) {\n  var result = {\n    sender: \"\",\n    urls: [],\n    calldata: \"\",\n    selector: \"\",\n    extraData: \"\",\n    errorArgs: []\n  };\n  assert(dataLength(data) >= 5 * 32, \"insufficient OffchainLookup data\", \"OFFCHAIN_FAULT\", {\n    reason: \"insufficient OffchainLookup data\"\n  });\n  var sender = dataSlice(data, 0, 32);\n  assert(dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12), \"corrupt OffchainLookup sender\", \"OFFCHAIN_FAULT\", {\n    reason: \"corrupt OffchainLookup sender\"\n  });\n  result.sender = dataSlice(sender, 12);\n  // Read the URLs from the response\n  try {\n    var urls = [];\n    var urlsOffset = getNumber(dataSlice(data, 32, 64));\n    var urlsLength = getNumber(dataSlice(data, urlsOffset, urlsOffset + 32));\n    var urlsData = dataSlice(data, urlsOffset + 32);\n    for (var u = 0; u < urlsLength; u++) {\n      var url = _parseString(urlsData, u * 32);\n      if (url == null) {\n        throw new Error(\"abort\");\n      }\n      urls.push(url);\n    }\n    result.urls = urls;\n  } catch (error) {\n    assert(false, \"corrupt OffchainLookup urls\", \"OFFCHAIN_FAULT\", {\n      reason: \"corrupt OffchainLookup urls\"\n    });\n  }\n  // Get the CCIP calldata to forward\n  try {\n    var calldata = _parseBytes(data, 64);\n    if (calldata == null) {\n      throw new Error(\"abort\");\n    }\n    result.calldata = calldata;\n  } catch (error) {\n    assert(false, \"corrupt OffchainLookup calldata\", \"OFFCHAIN_FAULT\", {\n      reason: \"corrupt OffchainLookup calldata\"\n    });\n  }\n  // Get the callbackSelector (bytes4)\n  assert(dataSlice(data, 100, 128) === dataSlice(zeros, 0, 28), \"corrupt OffchainLookup callbaackSelector\", \"OFFCHAIN_FAULT\", {\n    reason: \"corrupt OffchainLookup callbaackSelector\"\n  });\n  result.selector = dataSlice(data, 96, 100);\n  // Get the extra data to send back to the contract as context\n  try {\n    var extraData = _parseBytes(data, 128);\n    if (extraData == null) {\n      throw new Error(\"abort\");\n    }\n    result.extraData = extraData;\n  } catch (error) {\n    assert(false, \"corrupt OffchainLookup extraData\", \"OFFCHAIN_FAULT\", {\n      reason: \"corrupt OffchainLookup extraData\"\n    });\n  }\n  result.errorArgs = \"sender,urls,calldata,selector,extraData\".split(/,/).map(function (k) {\n    return result[k];\n  });\n  return result;\n}","map":{"version":3,"names":["getAddress","resolveAddress","ZeroHash","Contract","namehash","Transaction","concat","dataLength","dataSlice","hexlify","isHexString","getBigInt","getBytes","getNumber","isCallException","isError","makeError","assert","assertArgument","FetchRequest","toBeArray","toQuantity","defineProperties","EventPayload","resolveProperties","toUtf8String","EnsResolver","formatBlock","formatLog","formatTransactionReceipt","formatTransactionResponse","Network","copyRequest","Block","FeeData","Log","TransactionReceipt","TransactionResponse","PollingBlockSubscriber","PollingEventSubscriber","PollingOrphanSubscriber","PollingTransactionSubscriber","BN_2","BigInt","MAX_CCIP_REDIRECTS","isPromise","value","then","getTag","prefix","JSON","stringify","k","v","toString","toLowerCase","Array","isArray","keys","Object","sort","reduce","accum","key","UnmanagedSubscriber","name","_classCallCheck","_defineProperty","_createClass","start","stop","pause","dropWhilePaused","resume","copy","parse","concisify","items","from","Set","values","getSubscription","_x","_x2","_getSubscription","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee40","_event","provider","hash","event","_event2","filter","addresses","promises","addAddress","wrap","_callee40$","_context40","prev","next","Error","topics","t0","abrupt","type","tag","orphan","address","map","t","addr","push","_callee39","_callee39$","_context39","t1","sent","call","forEach","length","Promise","all","a","getTime","Date","_subs","WeakMap","_plugins","_pausedState","_networkPromise","_anyNetwork","_performCache","_lastBlockNumber","_nextTimer","_timers","_disableCcipRead","_perform","WeakSet","_call","_checkNetwork","_getAccountValue","_getBlock","_hasSub","_getSub","AbstractProvider","_network","_this","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","writable","_classPrivateFieldSet","network","resolve","setTimeout","emit","Map","get","_classPrivateFieldGet","attachPlugin","plugin","set","connect","getPlugin","_ccipReadFetch","_callee","tx","calldata","urls","sender","data","errorMessages","i","url","href","request","errorMessage","resp","result","_callee$","_context","disableCcipRead","to","replace","indexOf","body","action","index","send","bodyJson","message","statusCode","reason","transaction","info","m","join","ccipReadFetch","_x3","_x4","_x5","_wrapBlock","_wrapLog","_wrapTransactionReceipt","_wrapTransactionResponse","_detectNetwork","operation","_perform3","_callee2","req","_callee2$","_context2","method","_x6","_getBlockNumber","_callee3","blockNumber","_callee3$","_context3","_classPrivateMethodGet","_perform2","getBlockNumber","_getAddress","_getBlockTag","blockTag","b","_getFilter","blockHash","undefined","_address","fromBlock","toBlock","_iterator","_createForOfIteratorHelper","_step","s","n","done","err","e","f","_getTransactionRequest","_request","_callee4","_callee4$","_context4","_callee5","_callee5$","_context5","_callee6","_callee6$","_context6","_getNetwork","_callee7","_this2","detectNetwork","networkPromise","_yield$Promise$all","_yield$Promise$all2","expected","actual","_callee7$","_context7","error","clone","_slicedToArray","chainId","getNetwork","_getFeeData","_callee9","_this3","_yield$resolvePropert","block","gasPrice","maxFeePerGas","maxPriorityFeePerGas","_callee9$","_context9","getBlock","_callee8","_gasPrice","_callee8$","_context8","baseFeePerGas","getFeeData","_estimateGas","_callee10","_tx","_callee10$","_context10","estimateGas","_x7","_call3","_callee11","_yield$resolvePropert2","_callee11$","_context11","_checkNetwork2","_call2","enableCcipRead","_x8","_getBalance","_callee12","_callee12$","_context12","_getAccountValue2","getBalance","_x9","_x10","_getTransactionCount","_callee13","_callee13$","_context13","getTransactionCount","_x11","_x12","_getCode","_callee14","_callee14$","_context14","getCode","_x13","_x14","_getStorage","_callee15","_position","position","_callee15$","_context15","getStorage","_x15","_x16","_x17","_broadcastTransaction","_callee16","signedTx","_yield$resolvePropert3","_callee16$","_context16","signedTransaction","replaceableTransaction","broadcastTransaction","_x18","_getBlock3","_callee17","prefetchTxs","_yield$resolvePropert4","params","_callee17$","_context17","_getBlock2","_x19","_x20","_getTransaction","_callee18","_yield$resolvePropert5","_callee18$","_context18","getTransaction","_x21","_getTransactionReceipt","_callee19","_yield$resolvePropert6","_callee19$","_context19","effectiveGasPrice","getTransactionReceipt","_x22","_getTransactionResult","_callee20","_yield$resolvePropert7","_callee20$","_context20","getTransactionResult","_x23","_getLogs","_callee21","_filter","_this4","_yield$resolvePropert8","_callee21$","_context21","p","getLogs","_x24","_getProvider","_getResolver","_callee22","_callee22$","_context22","fromName","getResolver","_x25","_getAvatar","_callee23","resolver","_callee23$","_context23","getAvatar","_x26","_resolveName","_callee24","_callee24$","_context24","resolveName","_x27","_lookupAddress","_callee25","node","ensAddr","ensContract","resolverContract","check","_callee25$","_context25","substring","getEnsAddress","lookupAddress","_x28","_waitForTransaction","_callee28","_confirms","timeout","_this5","confirms","_callee28$","_context28","_ref5","_callee27","reject","timer","listener","_callee27$","_context27","_ref6","_callee26","receipt","_callee26$","_context26","clearTimeout","console","log","once","_x34","off","_x32","_x33","waitForTransaction","_x29","_x30","_x31","_waitForBlock","_callee29","_callee29$","_context29","waitForBlock","_x35","_clearTimeout","timerId","delete","_setTimeout","_func","_this$nextTimer","_this$nextTimer2","_this6","func","paused","time","_forEachSubscriber","_iterator2","_step2","sub","subscriber","_getSubscriber","_recoverSubscriber","oldSub","newSub","_iterator3","_step3","started","_on","_callee30","_callee30$","_context30","_getSub2","listeners","on","_x36","_x37","_once","_callee31","_callee31$","_context31","_x38","_x39","_emit","_callee32","_this7","_len","args","_key","count","_args32","_callee32$","_context32","_hasSub2","_ref7","payload","_x40","_listenerCount","_callee33","total","_iterator4","_step4","_callee33$","_context33","listenerCount","_x41","_listeners","_callee34","_iterator5","_step5","_listeners2","_callee34$","_context34","_ref8","_ref9","_x42","_off","_callee35","_callee35$","_context35","_ref10","splice","_x43","_x44","_removeAllListeners","_callee36","_yield$_classPrivateM","_iterator6","_step6","_step6$value","_tag","_step6$value$","_started","_subscriber","_callee36$","_context36","removeAllListeners","_x45","_addListener","_callee37","_callee37$","_context37","addListener","_x46","_x47","_removeListener","_callee38","_callee38$","_context38","removeListener","_x48","_x49","destroy","_iterator7","_step7","_iterator8","_step8","_iterator9","_step9","_x50","_perform4","_callee41","_this8","perform","_callee41$","_context41","_x51","_x52","_x53","_call4","_callee42","attempt","txSender","ccipArgs","ccipResult","_tx2","_callee42$","_context42","assign","t2","parseOffchainLookup","invocation","revert","signature","errorArgs","selector","encodeBytes","extraData","t3","_x54","_checkNetwork3","_callee43","promise","_yield$resolvePropert9","_callee43$","_context43","_x55","_x56","_x57","_getAccountValue3","_callee44","_blockTag","_yield$Promise$all3","_yield$Promise$all4","_callee44$","_context44","_x58","_x59","_getBlock4","_callee45","includeTransactions","_callee45$","_context45","_x60","_x61","_hasSub3","_callee46","emitArgs","_callee46$","_context46","removed","_x62","_getSub3","_callee47","subscription","addressableMap","nameMap","_callee47$","_context47","_parseString","bytes","_parseBytes","offset","numPad","padded","Uint8Array","bytesPad","Math","ceil","empty","datas","byteCount","zeros","urlsOffset","urlsLength","urlsData","u","split"],"sources":["C:\\Users\\Oguzhan\\Desktop\\BlockGuard\\mwallet\\node_modules\\ethers\\src.ts\\providers\\abstract-provider.ts"],"sourcesContent":["/**\n *  About Subclassing the Provider...\n *\n *  @_section: api/providers/abstract-provider: Subclassing Provider  [abstract-provider]\n */\n\n// @TODO\n// Event coalescence\n//   When we register an event with an async value (e.g. address is a Signer\n//   or ENS name), we need to add it immeidately for the Event API, but also\n//   need time to resolve the address. Upon resolving the address, we need to\n//   migrate the listener to the static event. We also need to maintain a map\n//   of Signer/ENS name to address so we can sync respond to listenerCount.\n\nimport { getAddress, resolveAddress } from \"../address/index.js\";\nimport { ZeroHash } from \"../constants/index.js\";\nimport { Contract } from \"../contract/index.js\";\nimport { namehash } from \"../hash/index.js\";\nimport { Transaction } from \"../transaction/index.js\";\nimport {\n    concat, dataLength, dataSlice, hexlify, isHexString,\n    getBigInt, getBytes, getNumber,\n    isCallException, isError, makeError, assert, assertArgument,\n    FetchRequest,\n    toBeArray, toQuantity,\n    defineProperties, EventPayload, resolveProperties,\n    toUtf8String\n} from \"../utils/index.js\";\n\nimport { EnsResolver } from \"./ens-resolver.js\";\nimport {\n    formatBlock, formatLog, formatTransactionReceipt, formatTransactionResponse\n} from \"./format.js\";\nimport { Network } from \"./network.js\";\nimport { copyRequest, Block, FeeData, Log, TransactionReceipt, TransactionResponse } from \"./provider.js\";\nimport {\n    PollingBlockSubscriber, PollingEventSubscriber, PollingOrphanSubscriber, PollingTransactionSubscriber\n} from \"./subscriber-polling.js\";\n\nimport type { Addressable, AddressLike } from \"../address/index.js\";\nimport type { BigNumberish, BytesLike } from \"../utils/index.js\";\nimport type { Listener } from \"../utils/index.js\";\n\nimport type { Networkish } from \"./network.js\";\n//import type { MaxPriorityFeePlugin } from \"./plugins-network.js\";\nimport type {\n    BlockParams, LogParams, TransactionReceiptParams,\n    TransactionResponseParams\n} from \"./formatting.js\";\n\nimport type {\n    BlockTag, EventFilter, Filter, FilterByBlockHash, OrphanFilter,\n    PreparedTransactionRequest, Provider, ProviderEvent,\n    TransactionRequest\n} from \"./provider.js\";\n\ntype Timer = ReturnType<typeof setTimeout>;\n\n\n// Constants\nconst BN_2 = BigInt(2);\n\nconst MAX_CCIP_REDIRECTS = 10;\n\nfunction isPromise<T = any>(value: any): value is Promise<T> {\n    return (value && typeof(value.then) === \"function\");\n}\n\nfunction getTag(prefix: string, value: any): string {\n    return prefix + \":\" + JSON.stringify(value, (k, v) => {\n        if (v == null) { return \"null\"; }\n        if (typeof(v) === \"bigint\") { return `bigint:${ v.toString() }`}\n        if (typeof(v) === \"string\") { return v.toLowerCase(); }\n\n        // Sort object keys\n        if (typeof(v) === \"object\" && !Array.isArray(v)) {\n            const keys = Object.keys(v);\n            keys.sort();\n            return keys.reduce((accum, key) => {\n                accum[key] = v[key];\n                return accum;\n            }, <any>{ });\n        }\n\n        return v;\n    });\n}\n\nexport type DebugEventAbstractProvider = {\n    action: \"sendCcipReadFetchRequest\",\n    request: FetchRequest\n    index: number\n    urls: Array<string>\n} | {\n    action: \"receiveCcipReadFetchResult\",\n    request: FetchRequest,\n    result: any\n} | {\n    action: \"receiveCcipReadFetchError\",\n    request: FetchRequest,\n    result: any\n} | {\n    action: \"sendCcipReadCall\",\n    transaction: { to: string, data: string }\n} | {\n    action: \"receiveCcipReadCallResult\",\n    transaction: { to: string, data: string }\n    result: string\n} | {\n    action: \"receiveCcipReadCallError\",\n    transaction: { to: string, data: string }\n    error: Error\n};\n\n\n// Only sub-classes overriding the _getSubscription method will care about this\nexport type Subscription = {\n    type: \"block\" | \"close\" | \"debug\" | \"network\" | \"pending\",\n    tag: string\n} | {\n    type: \"transaction\",\n    tag: string,\n    hash: string\n} | {\n    type: \"event\",\n    tag: string,\n    filter: EventFilter\n} | {\n    type: \"orphan\",\n    tag: string,\n    filter: OrphanFilter\n};\n\nexport interface Subscriber {\n    start(): void;\n    stop(): void;\n\n    pause(dropWhilePaused?: boolean): void;\n    resume(): void;\n\n    // Subscribers which use polling should implement this to allow\n    // Providers the ability to update underlying polling intervals\n    // If not supported, accessing this property should return undefined\n    pollingInterval?: number;\n}\n\nexport class UnmanagedSubscriber implements Subscriber {\n    name!: string;\n\n    constructor(name: string) { defineProperties<UnmanagedSubscriber>(this, { name }); }\n\n    start(): void { }\n    stop(): void { }\n\n    pause(dropWhilePaused?: boolean): void { }\n    resume(): void { }\n}\n\ntype Sub = {\n    tag: string;\n    nameMap: Map<string, string>\n    addressableMap: WeakMap<Addressable, string>;\n    listeners: Array<{ listener: Listener, once: boolean }>;\n    // @TODO: get rid of this, as it is (and has to be)\n    // tracked in subscriber\n    started: boolean;\n    subscriber: Subscriber;\n};\n\nfunction copy<T = any>(value: T): T {\n    return JSON.parse(JSON.stringify(value));\n}\n\nfunction concisify(items: Array<string>): Array<string> {\n    items = Array.from((new Set(items)).values())\n    items.sort();\n    return items;\n}\n\n\nasync function getSubscription(_event: ProviderEvent, provider: AbstractProvider): Promise<Subscription> {\n    if (_event == null) { throw new Error(\"invalid event\"); }\n\n    // Normalize topic array info an EventFilter\n    if (Array.isArray(_event)) { _event = { topics: _event }; }\n\n    if (typeof(_event) === \"string\") {\n        switch (_event) {\n            case \"block\": case \"pending\": case \"debug\": case \"network\": {\n                return { type: _event, tag: _event };\n            }\n        }\n    }\n\n    if (isHexString(_event, 32)) {\n        const hash = _event.toLowerCase();\n        return { type: \"transaction\", tag: getTag(\"tx\", { hash }), hash };\n    }\n\n    if ((<any>_event).orphan) {\n        const event = <OrphanFilter>_event;\n        // @TODO: Should lowercase and whatnot things here instead of copy...\n        return { type: \"orphan\", tag: getTag(\"orphan\", event), filter: copy(event) };\n    }\n\n    if (((<any>_event).address || (<any>_event).topics)) {\n        const event = <EventFilter>_event;\n\n        const filter: any = {\n            topics: ((event.topics || []).map((t) => {\n                if (t == null) { return null; }\n                if (Array.isArray(t)) {\n                    return concisify(t.map((t) => t.toLowerCase()));\n                }\n                return t.toLowerCase();\n            }))\n        };\n\n        if (event.address) {\n            const addresses: Array<string> = [ ];\n            const promises: Array<Promise<void>> = [ ];\n\n            const addAddress = (addr: AddressLike) => {\n                if (isHexString(addr)) {\n                    addresses.push(addr);\n                } else {\n                    promises.push((async () => {\n                        addresses.push(await resolveAddress(addr, provider));\n                    })());\n                }\n            }\n\n            if (Array.isArray(event.address)) {\n                event.address.forEach(addAddress);\n            } else {\n                addAddress(event.address);\n            }\n            if (promises.length) { await Promise.all(promises); }\n            filter.address = concisify(addresses.map((a) => a.toLowerCase()));\n        }\n\n        return { filter, tag: getTag(\"event\", filter), type: \"event\" };\n    }\n\n    assertArgument(false, \"unknown ProviderEvent\", \"event\", _event);\n}\n\nfunction getTime(): number { return (new Date()).getTime(); }\n\nexport interface AbstractProviderPlugin {\n    readonly name: string;\n    connect(provider: AbstractProvider): AbstractProviderPlugin;\n}\n\nexport type PerformActionFilter = {\n    address?: string | Array<string>;\n    topics?: Array<null | string | Array<string>>;\n    fromBlock?: BlockTag;\n    toBlock?: BlockTag;\n} | {\n    address?: string | Array<string>;\n    topics?: Array<null | string | Array<string>>;\n    blockHash?: string;\n};\n\nexport interface PerformActionTransaction extends PreparedTransactionRequest {\n    to?: string;\n    from?: string;\n}\n\nexport type PerformActionRequest = {\n    method: \"broadcastTransaction\",\n    signedTransaction: string\n} | {\n    method: \"call\",\n    transaction: PerformActionTransaction, blockTag: BlockTag\n} | {\n    method: \"chainId\"\n} | {\n    method: \"estimateGas\",\n    transaction: PerformActionTransaction\n} | {\n    method: \"getBalance\",\n    address: string, blockTag: BlockTag\n} | {\n    method: \"getBlock\",\n    blockTag: BlockTag, includeTransactions: boolean\n} | {\n    method: \"getBlock\",\n    blockHash: string, includeTransactions: boolean\n} | {\n    method: \"getBlockNumber\"\n} | {\n    method: \"getCode\",\n    address: string, blockTag: BlockTag\n} | {\n    method: \"getGasPrice\"\n} | {\n    method: \"getLogs\",\n    filter: PerformActionFilter\n} | {\n    method: \"getStorage\",\n    address: string, position: bigint, blockTag: BlockTag\n} | {\n    method: \"getTransaction\",\n    hash: string\n} | {\n    method: \"getTransactionCount\",\n    address: string, blockTag: BlockTag\n} | {\n    method: \"getTransactionReceipt\",\n    hash: string\n} | {\n    method: \"getTransactionResult\",\n    hash: string\n};\n\ntype _PerformAccountRequest = {\n    method: \"getBalance\" | \"getTransactionCount\" | \"getCode\"\n} | {\n    method: \"getStorage\", position: bigint\n}\n\ntype CcipArgs = {\n    sender: string;\n    urls: Array<string>;\n    calldata: string;\n    selector: string;\n    extraData: string;\n    errorArgs: Array<any>\n};\n\n\nexport class AbstractProvider implements Provider {\n\n    #subs: Map<string, Sub>;\n    #plugins: Map<string, AbstractProviderPlugin>;\n\n    // null=unpaused, true=paused+dropWhilePaused, false=paused\n    #pausedState: null | boolean;\n\n    #networkPromise: null | Promise<Network>;\n    readonly #anyNetwork: boolean;\n\n    #performCache: Map<string, Promise<any>>;\n\n    // The most recent block number if running an event or -1 if no \"block\" event\n    #lastBlockNumber: number;\n\n    #nextTimer: number;\n    #timers: Map<number, { timer: null | Timer, func: () => void, time: number }>;\n\n    #disableCcipRead: boolean;\n\n    // @TODO: This should be a () => Promise<Network> so network can be\n    // done when needed; or rely entirely on _detectNetwork?\n    constructor(_network?: \"any\" | Networkish) {\n\n        if (_network === \"any\") {\n            this.#anyNetwork = true;\n            this.#networkPromise = null;\n        } else if (_network) {\n            const network = Network.from(_network);\n            this.#anyNetwork = false;\n            this.#networkPromise = Promise.resolve(network);\n            setTimeout(() => { this.emit(\"network\", network, null); }, 0);\n        } else {\n            this.#anyNetwork = false;\n            this.#networkPromise = null;\n        }\n\n        this.#lastBlockNumber = -1;\n\n        this.#performCache = new Map();\n\n        this.#subs = new Map();\n        this.#plugins = new Map();\n        this.#pausedState = null;\n\n        this.#nextTimer = 1;\n        this.#timers = new Map();\n\n        this.#disableCcipRead = false;\n    }\n\n    get provider(): this { return this; }\n\n    get plugins(): Array<AbstractProviderPlugin> {\n        return Array.from(this.#plugins.values());\n    }\n\n    attachPlugin(plugin: AbstractProviderPlugin): this {\n        if (this.#plugins.get(plugin.name)) {\n            throw new Error(`cannot replace existing plugin: ${ plugin.name } `);\n        }\n        this.#plugins.set(plugin.name,  plugin.connect(this));\n        return this;\n    }\n\n    getPlugin<T extends AbstractProviderPlugin = AbstractProviderPlugin>(name: string): null | T {\n        return <T>(this.#plugins.get(name)) || null;\n    }\n\n    get disableCcipRead(): boolean { return this.#disableCcipRead; }\n    set disableCcipRead(value: boolean) { this.#disableCcipRead = !!value; }\n\n    // Shares multiple identical requests made during the same 250ms\n    async #perform<T = any>(req: PerformActionRequest): Promise<T> {\n        // Create a tag\n        const tag = getTag(req.method, req);\n\n        let perform = this.#performCache.get(tag);\n        if (!perform) {\n            perform = this._perform(req);\n            this.#performCache.set(tag, perform);\n\n            setTimeout(() => {\n                if (this.#performCache.get(tag) === perform) {\n                    this.#performCache.delete(tag);\n                }\n            }, 250);\n        }\n\n        return await perform;\n    }\n\n    async ccipReadFetch(tx: PerformActionTransaction, calldata: string, urls: Array<string>): Promise<null | string> {\n        if (this.disableCcipRead || urls.length === 0 || tx.to == null) { return null; }\n\n        const sender = tx.to.toLowerCase();\n        const data = calldata.toLowerCase();\n\n        const errorMessages: Array<string> = [ ];\n\n        for (let i = 0; i < urls.length; i++) {\n            const url = urls[i];\n\n            // URL expansion\n            const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n\n            // If no {data} is present, use POST; otherwise GET\n            //const json: string | null = (url.indexOf(\"{data}\") >= 0) ? null: JSON.stringify({ data, sender });\n\n            //const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n            //    value.status = response.statusCode;\n            //    return value;\n            //});\n            const request = new FetchRequest(href);\n            if (url.indexOf(\"{data}\") === -1) {\n                request.body = { data, sender };\n            }\n\n            this.emit(\"debug\", { action: \"sendCcipReadFetchRequest\", request, index: i, urls });\n\n            let errorMessage = \"unknown error\";\n\n            const resp = await request.send();\n            try {\n                 const result = resp.bodyJson;\n                 if (result.data) {\n                     this.emit(\"debug\", { action: \"receiveCcipReadFetchResult\", request, result });\n                     return result.data;\n                 }\n                 if (result.message) { errorMessage = result.message; }\n                 this.emit(\"debug\", { action: \"receiveCcipReadFetchError\", request, result });\n            } catch (error) { }\n\n            // 4xx indicates the result is not present; stop\n            assert(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${ errorMessage }`,\n                \"OFFCHAIN_FAULT\", { reason: \"404_MISSING_RESOURCE\", transaction: tx, info: { url, errorMessage } });\n\n            // 5xx indicates server issue; try the next url\n            errorMessages.push(errorMessage);\n        }\n\n        assert(false, `error encountered during CCIP fetch: ${ errorMessages.map((m) => JSON.stringify(m)).join(\", \") }`, \"OFFCHAIN_FAULT\", {\n            reason: \"500_SERVER_ERROR\",\n            transaction: tx, info: { urls, errorMessages }\n        });\n    }\n\n    _wrapBlock(value: BlockParams, network: Network): Block {\n        return new Block(formatBlock(value), this);\n    }\n\n    _wrapLog(value: LogParams, network: Network): Log {\n        return new Log(formatLog(value), this);\n    }\n\n    _wrapTransactionReceipt(value: TransactionReceiptParams, network: Network): TransactionReceipt {\n        return new TransactionReceipt(formatTransactionReceipt(value), this);\n    }\n\n    _wrapTransactionResponse(tx: TransactionResponseParams, network: Network): TransactionResponse {\n        return new TransactionResponse(formatTransactionResponse(tx), this);\n    }\n\n    _detectNetwork(): Promise<Network> {\n        assert(false, \"sub-classes must implement this\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_detectNetwork\"\n        });\n    }\n\n    // Sub-classes should override this and handle PerformActionRequest requests, calling\n    // the super for any unhandled actions.\n    async _perform<T = any>(req: PerformActionRequest): Promise<T> {\n        assert(false, `unsupported method: ${ req.method }`, \"UNSUPPORTED_OPERATION\", {\n            operation: req.method,\n            info: req\n        });\n    }\n\n    // State\n    async getBlockNumber(): Promise<number> {\n        const blockNumber = getNumber(await this.#perform({ method: \"getBlockNumber\" }), \"%response\");\n        if (this.#lastBlockNumber >= 0) { this.#lastBlockNumber = blockNumber; }\n        return blockNumber;\n    }\n\n    _getAddress(address: AddressLike): string | Promise<string> {\n        return resolveAddress(address, this);\n    }\n\n    _getBlockTag(blockTag?: BlockTag): string | Promise<string> {\n        if (blockTag == null) { return \"latest\"; }\n\n        switch (blockTag) {\n            case \"earliest\":\n                return \"0x0\";\n            case \"latest\": case \"pending\": case \"safe\": case \"finalized\":\n                return blockTag;\n        }\n\n\n        if (isHexString(blockTag)) {\n            if (isHexString(blockTag, 32)) { return blockTag; }\n            return toQuantity(blockTag);\n        }\n\n        if (typeof(blockTag) === \"bigint\") {\n            blockTag = getNumber(blockTag, \"blockTag\");\n        }\n\n        if (typeof(blockTag) === \"number\") {\n            if (blockTag >= 0) { return toQuantity(blockTag); }\n            if (this.#lastBlockNumber >= 0) { return toQuantity(this.#lastBlockNumber + blockTag); }\n            return this.getBlockNumber().then((b) => toQuantity(b + <number>blockTag));\n        }\n\n        assertArgument(false, \"invalid blockTag\", \"blockTag\", blockTag);\n    }\n\n    _getFilter(filter: Filter | FilterByBlockHash): PerformActionFilter | Promise<PerformActionFilter> {\n\n        // Create a canonical representation of the topics\n        const topics = (filter.topics || [ ]).map((t) => {\n            if (t == null) { return null; }\n            if (Array.isArray(t)) {\n                return concisify(t.map((t) => t.toLowerCase()));\n            }\n            return t.toLowerCase();\n        });\n\n        const blockHash = (\"blockHash\" in filter) ? filter.blockHash: undefined;\n\n        const resolve = (_address: Array<string>, fromBlock?: string, toBlock?: string) => {\n            let address: undefined | string | Array<string> = undefined;\n            switch (_address.length) {\n                case 0: break;\n                case 1:\n                    address = _address[0];\n                    break;\n                default:\n                    _address.sort();\n                    address = _address;\n            }\n\n            if (blockHash) {\n                if (fromBlock != null || toBlock != null) {\n                    throw new Error(\"invalid filter\");\n                }\n            }\n\n            const filter = <any>{ };\n            if (address) { filter.address = address; }\n            if (topics.length) { filter.topics = topics; }\n            if (fromBlock) { filter.fromBlock = fromBlock; }\n            if (toBlock) { filter.toBlock = toBlock; }\n            if (blockHash) { filter.blockHash = blockHash; }\n\n            return filter;\n        };\n\n        // Addresses could be async (ENS names or Addressables)\n        let address: Array<string | Promise<string>> = [ ];\n        if (filter.address) {\n            if (Array.isArray(filter.address)) {\n                for (const addr of filter.address) { address.push(this._getAddress(addr)); }\n            } else {\n                address.push(this._getAddress(filter.address));\n            }\n        }\n\n        let fromBlock: undefined | string | Promise<string> = undefined;\n        if (\"fromBlock\" in filter) { fromBlock = this._getBlockTag(filter.fromBlock); }\n\n        let toBlock: undefined | string | Promise<string> = undefined;\n        if (\"toBlock\" in filter) { toBlock = this._getBlockTag(filter.toBlock); }\n\n        if (address.filter((a) => (typeof(a) !== \"string\")).length ||\n            (fromBlock != null && typeof(fromBlock) !== \"string\") ||\n            (toBlock != null && typeof(toBlock) !== \"string\")) {\n\n            return Promise.all([ Promise.all(address), fromBlock, toBlock ]).then((result) => {\n                return resolve(result[0], result[1], result[2]);\n            });\n        }\n\n        return resolve(<Array<string>>address, fromBlock, toBlock);\n    }\n\n    _getTransactionRequest(_request: TransactionRequest): PerformActionTransaction | Promise<PerformActionTransaction> {\n        const request = <PerformActionTransaction>copyRequest(_request);\n\n        const promises: Array<Promise<void>> = [ ];\n        [ \"to\", \"from\" ].forEach((key) => {\n            if ((<any>request)[key] == null) { return; }\n\n            const addr = resolveAddress((<any>request)[key]);\n            if (isPromise(addr)) {\n                promises.push((async function() { (<any>request)[key] = await addr; })());\n            } else {\n                (<any>request)[key] = addr;\n            }\n        });\n\n        if (request.blockTag != null) {\n            const blockTag = this._getBlockTag(request.blockTag);\n            if (isPromise(blockTag)) {\n                promises.push((async function() { request.blockTag = await blockTag; })());\n            } else {\n                request.blockTag = blockTag;\n            }\n        }\n\n        if (promises.length) {\n            return (async function() {\n                await Promise.all(promises);\n                return request;\n            })();\n        }\n\n        return request;\n    }\n\n    async getNetwork(): Promise<Network> {\n\n        // No explicit network was set and this is our first time\n        if (this.#networkPromise == null) {\n\n            // Detect the current network (shared with all calls)\n            const detectNetwork = this._detectNetwork().then((network) => {\n                this.emit(\"network\", network, null);\n                return network;\n            }, (error) => {\n                // Reset the networkPromise on failure, so we will try again\n                if (this.#networkPromise === detectNetwork) {\n                    this.#networkPromise = null;\n                }\n                throw error;\n            });\n\n            this.#networkPromise = detectNetwork;\n            return (await detectNetwork).clone();\n        }\n\n        const networkPromise = this.#networkPromise;\n\n        const [ expected, actual ] = await Promise.all([\n            networkPromise,          // Possibly an explicit Network\n            this._detectNetwork()    // The actual connected network\n        ]);\n\n        if (expected.chainId !== actual.chainId) {\n            if (this.#anyNetwork) {\n                // The \"any\" network can change, so notify listeners\n                this.emit(\"network\", actual, expected);\n\n                // Update the network if something else hasn't already changed it\n                if (this.#networkPromise === networkPromise) {\n                    this.#networkPromise = Promise.resolve(actual);\n                }\n            } else {\n                // Otherwise, we do not allow changes to the underlying network\n                assert(false, `network changed: ${ expected.chainId } => ${ actual.chainId } `, \"NETWORK_ERROR\", {\n                    event: \"changed\"\n                });\n            }\n        }\n\n        return expected.clone();\n    }\n\n    async getFeeData(): Promise<FeeData> {\n        const { block, gasPrice } = await resolveProperties({\n            block: this.getBlock(\"latest\"),\n            gasPrice: ((async () => {\n                try {\n                    const gasPrice = await this.#perform({ method: \"getGasPrice\" });\n                    return getBigInt(gasPrice, \"%response\");\n                } catch (error) { }\n                return null\n            })())\n        });\n\n        let maxFeePerGas = null, maxPriorityFeePerGas = null;\n\n        if (block && block.baseFeePerGas) {\n            // We may want to compute this more accurately in the future,\n            // using the formula \"check if the base fee is correct\".\n            // See: https://eips.ethereum.org/EIPS/eip-1559\n            maxPriorityFeePerGas = BigInt(\"1000000000\");\n\n            // Allow a network to override their maximum priority fee per gas\n            //const priorityFeePlugin = (await this.getNetwork()).getPlugin<MaxPriorityFeePlugin>(\"org.ethers.plugins.max-priority-fee\");\n            //if (priorityFeePlugin) {\n            //    maxPriorityFeePerGas = await priorityFeePlugin.getPriorityFee(this);\n            //}\n            maxFeePerGas = (block.baseFeePerGas * BN_2) + maxPriorityFeePerGas;\n        }\n\n        return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);\n    }\n\n\n    async estimateGas(_tx: TransactionRequest): Promise<bigint> {\n        let tx = this._getTransactionRequest(_tx);\n        if (isPromise(tx)) { tx = await tx; }\n        return getBigInt(await this.#perform({\n            method: \"estimateGas\", transaction: tx\n        }), \"%response\");\n    }\n\n    async #call(tx: PerformActionTransaction, blockTag: string, attempt: number): Promise<string> {\n        assert (attempt < MAX_CCIP_REDIRECTS, \"CCIP read exceeded maximum redirections\", \"OFFCHAIN_FAULT\", {\n             reason: \"TOO_MANY_REDIRECTS\",\n             transaction: Object.assign({ }, tx, { blockTag, enableCcipRead: true })\n         });\n\n         // This came in as a PerformActionTransaction, so to/from are safe; we can cast\n         const transaction = <PerformActionTransaction>copyRequest(tx);\n\n         try {\n             return hexlify(await this._perform({ method: \"call\", transaction, blockTag }));\n\n         } catch (error) {\n             // CCIP Read OffchainLookup\n             if (!this.disableCcipRead && isCallException(error) && error.data && attempt >= 0 && blockTag === \"latest\" && transaction.to != null && dataSlice(error.data, 0, 4) === \"0x556f1830\") {\n                 const data = error.data;\n\n                 const txSender = await resolveAddress(transaction.to, this);\n\n                 // Parse the CCIP Read Arguments\n                 let ccipArgs: CcipArgs;\n                 try {\n                     ccipArgs = parseOffchainLookup(dataSlice(error.data, 4));\n                 } catch (error: any) {\n                     assert(false, error.message, \"OFFCHAIN_FAULT\", {\n                         reason: \"BAD_DATA\", transaction, info: { data } });\n                 }\n\n                 // Check the sender of the OffchainLookup matches the transaction\n                 assert(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(),\n                     \"CCIP Read sender mismatch\", \"CALL_EXCEPTION\", {\n                         action: \"call\",\n                         data,\n                         reason: \"OffchainLookup\",\n                         transaction: <any>transaction, // @TODO: populate data?\n                         invocation: null,\n                         revert: {\n                             signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                             name: \"OffchainLookup\",\n                             args: ccipArgs.errorArgs\n                         }\n                     });\n\n                 const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);\n                 assert(ccipResult != null, \"CCIP Read failed to fetch data\", \"OFFCHAIN_FAULT\", {\n                     reason: \"FETCH_FAILED\", transaction, info: { data: error.data, errorArgs: ccipArgs.errorArgs } });\n\n                 const tx = {\n                     to: txSender,\n                     data: concat([ ccipArgs.selector, encodeBytes([ ccipResult, ccipArgs.extraData ]) ])\n                 };\n\n                 this.emit(\"debug\", { action: \"sendCcipReadCall\", transaction: tx });\n                 try {\n                     const result = await this.#call(tx, blockTag, attempt + 1);\n                     this.emit(\"debug\", { action: \"receiveCcipReadCallResult\", transaction: Object.assign({ }, tx), result });\n                     return result;\n                 } catch (error) {\n                     this.emit(\"debug\", { action: \"receiveCcipReadCallError\", transaction: Object.assign({ }, tx), error });\n                     throw error;\n                 }\n             }\n\n             throw error;\n         }\n    }\n\n    async #checkNetwork<T>(promise: Promise<T>): Promise<T> {\n        const { value } = await resolveProperties({\n            network: this.getNetwork(),\n            value: promise\n        });\n        return value;\n    }\n\n    async call(_tx: TransactionRequest): Promise<string> {\n        const { tx, blockTag } = await resolveProperties({\n            tx: this._getTransactionRequest(_tx),\n            blockTag: this._getBlockTag(_tx.blockTag)\n        });\n        return await this.#checkNetwork(this.#call(tx, blockTag, _tx.enableCcipRead ? 0: -1));\n    }\n\n    // Account\n    async #getAccountValue(request: _PerformAccountRequest, _address: AddressLike, _blockTag?: BlockTag): Promise<any> {\n        let address: string | Promise<string> = this._getAddress(_address);\n        let blockTag: string | Promise<string> = this._getBlockTag(_blockTag);\n\n        if (typeof(address) !== \"string\" || typeof(blockTag) !== \"string\") {\n            [ address, blockTag ] = await Promise.all([ address, blockTag ]);\n        }\n\n        return await this.#checkNetwork(this.#perform(Object.assign(request, { address, blockTag })));\n    }\n\n    async getBalance(address: AddressLike, blockTag?: BlockTag): Promise<bigint> {\n        return getBigInt(await this.#getAccountValue({ method: \"getBalance\" }, address, blockTag), \"%response\");\n    }\n\n    async getTransactionCount(address: AddressLike, blockTag?: BlockTag): Promise<number> {\n        return getNumber(await this.#getAccountValue({ method: \"getTransactionCount\" }, address, blockTag), \"%response\");\n    }\n\n    async getCode(address: AddressLike, blockTag?: BlockTag): Promise<string> {\n        return hexlify(await this.#getAccountValue({ method: \"getCode\" }, address, blockTag));\n    }\n\n    async getStorage(address: AddressLike, _position: BigNumberish, blockTag?: BlockTag): Promise<string> {\n        const position = getBigInt(_position, \"position\");\n        return hexlify(await this.#getAccountValue({ method: \"getStorage\", position }, address, blockTag));\n    }\n\n    // Write\n    async broadcastTransaction(signedTx: string): Promise<TransactionResponse> {\n        const { blockNumber, hash, network } = await resolveProperties({\n             blockNumber: this.getBlockNumber(),\n             hash: this._perform({\n                 method: \"broadcastTransaction\",\n                 signedTransaction: signedTx\n             }),\n             network: this.getNetwork()\n        });\n\n        const tx = Transaction.from(signedTx);\n        if (tx.hash !== hash) {\n            throw new Error(\"@TODO: the returned hash did not match\");\n        }\n\n        return this._wrapTransactionResponse(<any>tx, network).replaceableTransaction(blockNumber);\n    }\n\n    async #getBlock(block: BlockTag | string, includeTransactions: boolean): Promise<any> {\n        // @TODO: Add CustomBlockPlugin check\n\n        if (isHexString(block, 32)) {\n            return await this.#perform({\n                method: \"getBlock\", blockHash: block, includeTransactions\n            });\n        }\n\n        let blockTag = this._getBlockTag(block);\n        if (typeof(blockTag) !== \"string\") { blockTag = await blockTag; }\n\n        return await this.#perform({\n            method: \"getBlock\", blockTag, includeTransactions\n        });\n    }\n\n    // Queries\n    async getBlock(block: BlockTag | string, prefetchTxs?: boolean): Promise<null | Block> {\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#getBlock(block, !!prefetchTxs)\n        });\n        if (params == null) { return null; }\n\n        return this._wrapBlock(params, network);\n    }\n\n    async getTransaction(hash: string): Promise<null | TransactionResponse> {\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getTransaction\", hash })\n        });\n        if (params == null) { return null; }\n\n        return this._wrapTransactionResponse(params, network);\n    }\n\n    async getTransactionReceipt(hash: string): Promise<null | TransactionReceipt> {\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#perform({ method: \"getTransactionReceipt\", hash })\n        });\n        if (params == null) { return null; }\n\n        // Some backends did not backfill the effectiveGasPrice into old transactions\n        // in the receipt, so we look it up manually and inject it.\n        if (params.gasPrice == null && params.effectiveGasPrice == null) {\n            const tx = await this.#perform({ method: \"getTransaction\", hash });\n            if (tx == null) { throw new Error(\"report this; could not find tx or effectiveGasPrice\"); }\n            params.effectiveGasPrice = tx.gasPrice;\n        }\n\n        return this._wrapTransactionReceipt(params, network);\n    }\n\n    async getTransactionResult(hash: string): Promise<null | string> {\n        const { result } = await resolveProperties({\n            network: this.getNetwork(),\n            result: this.#perform({ method: \"getTransactionResult\", hash })\n        });\n        if (result == null) { return null; }\n        return hexlify(result);\n    }\n\n    // Bloom-filter Queries\n    async getLogs(_filter: Filter | FilterByBlockHash): Promise<Array<Log>> {\n        let filter = this._getFilter(_filter);\n        if (isPromise(filter)) { filter = await filter; }\n\n        const { network, params } = await resolveProperties({\n            network: this.getNetwork(),\n            params: this.#perform<Array<LogParams>>({ method: \"getLogs\", filter })\n        });\n\n        return params.map((p) => this._wrapLog(p, network));\n    }\n\n    // ENS\n    _getProvider(chainId: number): AbstractProvider {\n        assert(false, \"provider cannot connect to target network\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"_getProvider()\"\n        });\n    }\n\n    async getResolver(name: string): Promise<null | EnsResolver> {\n        return await EnsResolver.fromName(this, name);\n    }\n\n    async getAvatar(name: string): Promise<null | string> {\n        const resolver = await this.getResolver(name);\n        if (resolver) { return await resolver.getAvatar(); }\n        return null;\n    }\n\n    async resolveName(name: string): Promise<null | string>{\n        const resolver = await this.getResolver(name);\n        if (resolver) { return await resolver.getAddress(); }\n        return null;\n    }\n\n    async lookupAddress(address: string): Promise<null | string> {\n        address = getAddress(address);\n        const node = namehash(address.substring(2).toLowerCase() + \".addr.reverse\");\n\n        try {\n\n            const ensAddr = await EnsResolver.getEnsAddress(this);\n            const ensContract = new Contract(ensAddr, [\n                \"function resolver(bytes32) view returns (address)\"\n            ], this);\n\n            const resolver = await ensContract.resolver(node);\n            if (resolver == null || resolver === ZeroHash) { return null; }\n\n            const resolverContract = new Contract(resolver, [\n                \"function name(bytes32) view returns (string)\"\n            ], this);\n            const name = await resolverContract.name(node);\n\n            // Failed forward resolution\n            const check = await this.resolveName(name);\n            if (check !== address) { return null; }\n\n            return name;\n        } catch (error) {\n            // No data was returned from the resolver\n            if (isError(error, \"BAD_DATA\") && error.value === \"0x\") {\n                return null;\n            }\n\n            // Something reerted\n            if (isError(error, \"CALL_EXCEPTION\")) { return null; }\n\n            throw error;\n        }\n\n        return null;\n    }\n\n    async waitForTransaction(hash: string, _confirms?: null | number, timeout?: null | number): Promise<null | TransactionReceipt> {\n        const confirms = (_confirms != null) ? _confirms: 1;\n        if (confirms === 0) { return this.getTransactionReceipt(hash); }\n\n        return new Promise(async (resolve, reject) => {\n            let timer: null | Timer = null;\n\n            const listener = (async (blockNumber: number) => {\n                try {\n                    const receipt = await this.getTransactionReceipt(hash);\n                    if (receipt != null) {\n                        if (blockNumber - receipt.blockNumber + 1 >= confirms) {\n                            resolve(receipt);\n                            //this.off(\"block\", listener);\n                            if (timer) {\n                                clearTimeout(timer);\n                                timer = null;\n                            }\n                            return;\n                        }\n                    }\n                } catch (error) {\n                    console.log(\"EEE\", error);\n                }\n                this.once(\"block\", listener);\n            });\n\n            if (timeout != null) {\n                timer = setTimeout(() => {\n                    if (timer == null) { return; }\n                    timer = null;\n                    this.off(\"block\", listener);\n                    reject(makeError(\"timeout\", \"TIMEOUT\", { reason: \"timeout\" }));\n                }, timeout);\n            }\n\n            listener(await this.getBlockNumber());\n        });\n    }\n\n    async waitForBlock(blockTag?: BlockTag): Promise<Block> {\n        assert(false, \"not implemented yet\", \"NOT_IMPLEMENTED\", {\n            operation: \"waitForBlock\"\n        });\n    }\n\n    _clearTimeout(timerId: number): void {\n        const timer = this.#timers.get(timerId);\n        if (!timer) { return; }\n        if (timer.timer) { clearTimeout(timer.timer); }\n        this.#timers.delete(timerId);\n    }\n\n    _setTimeout(_func: () => void, timeout?: number): number {\n        if (timeout == null) { timeout = 0; }\n        const timerId = this.#nextTimer++;\n        const func = () => {\n            this.#timers.delete(timerId);\n            _func();\n        };\n\n        if (this.paused) {\n            this.#timers.set(timerId, { timer: null, func, time: timeout });\n        } else {\n            const timer = setTimeout(func, timeout);\n            this.#timers.set(timerId, { timer, func, time: getTime() });\n        }\n\n        return timerId;\n    }\n\n    _forEachSubscriber(func: (s: Subscriber) => void): void {\n        for (const sub of this.#subs.values()) {\n            func(sub.subscriber);\n        }\n    }\n\n    // Event API; sub-classes should override this; any supported\n    // event filter will have been munged into an EventFilter\n    _getSubscriber(sub: Subscription): Subscriber {\n        switch (sub.type) {\n            case \"debug\":\n            case \"network\":\n                return new UnmanagedSubscriber(sub.type);\n            case \"block\":\n                return new PollingBlockSubscriber(this);\n            case \"event\":\n                return new PollingEventSubscriber(this, sub.filter);\n            case \"transaction\":\n                return new PollingTransactionSubscriber(this, sub.hash);\n            case \"orphan\":\n                return new PollingOrphanSubscriber(this, sub.filter);\n        }\n\n        throw new Error(`unsupported event: ${ sub.type }`);\n    }\n\n    _recoverSubscriber(oldSub: Subscriber, newSub: Subscriber): void {\n        for (const sub of this.#subs.values()) {\n            if (sub.subscriber === oldSub) {\n                if (sub.started) { sub.subscriber.stop(); }\n                sub.subscriber = newSub;\n                if (sub.started) { newSub.start(); }\n                if (this.#pausedState != null) { newSub.pause(this.#pausedState); }\n                break;\n            }\n        }\n    }\n\n    async #hasSub(event: ProviderEvent, emitArgs?: Array<any>): Promise<null | Sub> {\n        let sub = await getSubscription(event, this);\n        // This is a log that is removing an existing log; we actually want\n        // to emit an orphan event for the removed log\n        if (sub.type === \"event\" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {\n            sub = await getSubscription({ orphan: \"drop-log\", log: emitArgs[0] }, this);\n        }\n        return this.#subs.get(sub.tag) || null;\n    }\n\n    async #getSub(event: ProviderEvent): Promise<Sub> {\n        const subscription = await getSubscription(event, this);\n\n        // Prevent tampering with our tag in any subclass' _getSubscriber\n        const tag = subscription.tag;\n\n        let sub = this.#subs.get(tag);\n        if (!sub) {\n            const subscriber = this._getSubscriber(subscription);\n\n            const addressableMap = new WeakMap();\n            const nameMap = new Map();\n            sub = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [ ] };\n            this.#subs.set(tag, sub);\n        }\n\n        return sub;\n    }\n\n    async on(event: ProviderEvent, listener: Listener): Promise<this> {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({ listener, once: false });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState != null) { sub.subscriber.pause(this.#pausedState); }\n        }\n        return this;\n    }\n\n    async once(event: ProviderEvent, listener: Listener): Promise<this> {\n        const sub = await this.#getSub(event);\n        sub.listeners.push({ listener, once: true });\n        if (!sub.started) {\n            sub.subscriber.start();\n            sub.started = true;\n            if (this.#pausedState != null) { sub.subscriber.pause(this.#pausedState); }\n        }\n        return this;\n    }\n\n    async emit(event: ProviderEvent, ...args: Array<any>): Promise<boolean> {\n        const sub = await this.#hasSub(event, args);\n        // If there is not subscription or if a recent emit removed\n        // the last of them (which also deleted the sub) do nothing\n        if (!sub || sub.listeners.length === 0) { return false; };\n\n        const count = sub.listeners.length;\n        sub.listeners = sub.listeners.filter(({ listener, once }) => {\n            const payload = new EventPayload(this, (once ? null: listener), event);\n            try {\n                listener.call(this, ...args, payload);\n            } catch(error) { }\n            return !once;\n        });\n\n        if (sub.listeners.length === 0) {\n            if (sub.started) { sub.subscriber.stop(); }\n            this.#subs.delete(sub.tag);\n        }\n\n        return (count > 0);\n    }\n\n    async listenerCount(event?: ProviderEvent): Promise<number> {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) { return 0; }\n            return sub.listeners.length;\n        }\n\n        let total = 0;\n        for (const { listeners } of this.#subs.values()) {\n            total += listeners.length;\n        }\n        return total;\n    }\n\n    async listeners(event?: ProviderEvent): Promise<Array<Listener>> {\n        if (event) {\n            const sub = await this.#hasSub(event);\n            if (!sub) { return  [ ]; }\n            return sub.listeners.map(({ listener }) => listener);\n        }\n        let result: Array<Listener> = [ ];\n        for (const { listeners } of this.#subs.values()) {\n            result = result.concat(listeners.map(({ listener }) => listener));\n        }\n        return result;\n    }\n\n    async off(event: ProviderEvent, listener?: Listener): Promise<this> {\n        const sub = await this.#hasSub(event);\n        if (!sub) { return this; }\n\n        if (listener) {\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\n            if (index >= 0) { sub.listeners.splice(index, 1); }\n        }\n\n        if (!listener || sub.listeners.length === 0) {\n            if (sub.started) { sub.subscriber.stop(); }\n            this.#subs.delete(sub.tag);\n        }\n\n        return this;\n    }\n\n    async removeAllListeners(event?: ProviderEvent): Promise<this> {\n        if (event) {\n            const { tag, started, subscriber } = await this.#getSub(event);\n            if (started) { subscriber.stop(); }\n            this.#subs.delete(tag);\n        } else {\n            for (const [ tag, { started, subscriber } ] of this.#subs) {\n                if (started) { subscriber.stop(); }\n                this.#subs.delete(tag);\n            }\n        }\n        return this;\n    }\n\n    // Alias for \"on\"\n    async addListener(event: ProviderEvent, listener: Listener): Promise<this> {\n       return await this.on(event, listener);\n    }\n\n    // Alias for \"off\"\n    async removeListener(event: ProviderEvent, listener: Listener): Promise<this> {\n       return this.off(event, listener);\n    }\n\n    // Sub-classes should override this to shutdown any sockets, etc.\n    // but MUST call this super.shutdown.\n    destroy(): void {\n        // Stop all listeners\n        this.removeAllListeners();\n\n        // Shut down all tiemrs\n        for (const timerId of this.#timers.keys()) {\n            this._clearTimeout(timerId);\n        }\n    }\n\n    get paused(): boolean { return (this.#pausedState != null); }\n    set paused(pause: boolean) {\n        if (!!pause === this.paused) { return; }\n\n        if (this.paused) {\n            this.resume();\n        } else {\n            this.pause(false);\n        }\n    }\n\n    pause(dropWhilePaused?: boolean): void {\n        this.#lastBlockNumber = -1;\n\n        if (this.#pausedState != null) {\n            if (this.#pausedState == !!dropWhilePaused) { return; }\n            assert(false, \"cannot change pause type; resume first\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"pause\"\n            });\n        }\n\n        this._forEachSubscriber((s) => s.pause(dropWhilePaused));\n        this.#pausedState = !!dropWhilePaused;\n\n        for (const timer of this.#timers.values()) {\n            // Clear the timer\n            if (timer.timer) { clearTimeout(timer.timer); }\n\n            // Remaining time needed for when we become unpaused\n            timer.time = getTime() - timer.time;\n        }\n    }\n\n    resume(): void {\n        if (this.#pausedState == null) { return; }\n\n        this._forEachSubscriber((s) => s.resume());\n        this.#pausedState = null;\n        for (const timer of this.#timers.values()) {\n            // Remaining time when we were paused\n            let timeout = timer.time;\n            if (timeout < 0) { timeout = 0; }\n\n            // Start time (in cause paused, so we con compute remaininf time)\n            timer.time = getTime();\n\n            // Start the timer\n            setTimeout(timer.func, timeout);\n        }\n    }\n}\n\n\nfunction _parseString(result: string, start: number): null | string {\n    try {\n        const bytes = _parseBytes(result, start);\n        if (bytes) { return toUtf8String(bytes); }\n    } catch(error) { }\n    return null;\n}\n\nfunction _parseBytes(result: string, start: number): null | string {\n    if (result === \"0x\") { return null; }\n    try {\n        const offset = getNumber(dataSlice(result, start, start + 32));\n        const length = getNumber(dataSlice(result, offset, offset + 32));\n\n        return dataSlice(result, offset + 32, offset + 32 + length);\n    } catch (error) { }\n    return null;\n}\n\nfunction numPad(value: number): Uint8Array {\n    const result = toBeArray(value);\n    if (result.length > 32) { throw new Error(\"internal; should not happen\"); }\n\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\n\nfunction bytesPad(value: Uint8Array): Uint8Array {\n    if ((value.length % 32) === 0) { return value; }\n\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\n\nconst empty: Uint8Array = new Uint8Array([ ]);\n\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas: Array<BytesLike>): string {\n    const result: Array<Uint8Array> = [ ];\n\n    let byteCount = 0;\n\n    // Add place-holders for pointers as we add items\n    for (let i = 0; i < datas.length; i++) {\n        result.push(empty);\n        byteCount += 32;\n    }\n\n    for (let i = 0; i < datas.length; i++) {\n        const data = getBytes(datas[i]);\n\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n\n    return concat(result);\n}\n\nconst zeros = \"0x0000000000000000000000000000000000000000000000000000000000000000\"\nfunction parseOffchainLookup(data: string): CcipArgs {\n    const result: CcipArgs = {\n        sender: \"\", urls: [ ], calldata: \"\", selector: \"\", extraData: \"\", errorArgs: [ ]\n    };\n\n    assert(dataLength(data) >= 5 * 32, \"insufficient OffchainLookup data\", \"OFFCHAIN_FAULT\", {\n        reason: \"insufficient OffchainLookup data\"\n    });\n\n    const sender = dataSlice(data, 0, 32);\n    assert(dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12), \"corrupt OffchainLookup sender\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup sender\"\n    });\n    result.sender = dataSlice(sender, 12);\n\n    // Read the URLs from the response\n    try {\n        const urls: Array<string> = [];\n        const urlsOffset = getNumber(dataSlice(data, 32, 64));\n        const urlsLength = getNumber(dataSlice(data, urlsOffset, urlsOffset + 32));\n        const urlsData = dataSlice(data, urlsOffset + 32);\n        for (let u = 0; u < urlsLength; u++) {\n            const url = _parseString(urlsData, u * 32);\n            if (url == null) { throw new Error(\"abort\"); }\n            urls.push(url);\n        }\n        result.urls = urls;\n    } catch (error) {\n        assert(false, \"corrupt OffchainLookup urls\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup urls\"\n        });\n    }\n\n    // Get the CCIP calldata to forward\n    try {\n        const calldata = _parseBytes(data, 64);\n        if (calldata == null) { throw new Error(\"abort\"); }\n        result.calldata = calldata;\n    } catch (error) {\n        assert(false, \"corrupt OffchainLookup calldata\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup calldata\"\n        });\n    }\n\n    // Get the callbackSelector (bytes4)\n    assert(dataSlice(data, 100, 128) === dataSlice(zeros, 0, 28), \"corrupt OffchainLookup callbaackSelector\", \"OFFCHAIN_FAULT\", {\n        reason: \"corrupt OffchainLookup callbaackSelector\"\n    });\n    result.selector = dataSlice(data, 96, 100);\n\n    // Get the extra data to send back to the contract as context\n    try {\n        const extraData = _parseBytes(data, 128);\n        if (extraData == null) { throw new Error(\"abort\"); }\n        result.extraData = extraData;\n    } catch (error) {\n        assert(false, \"corrupt OffchainLookup extraData\", \"OFFCHAIN_FAULT\", {\n            reason: \"corrupt OffchainLookup extraData\"\n        });\n    }\n\n    result.errorArgs = \"sender,urls,calldata,selector,extraData\".split(/,/).map((k) => (<any>result)[k])\n\n    return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}