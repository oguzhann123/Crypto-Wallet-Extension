{"ast":null,"code":"import _slicedToArray from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classPrivateMethodInitSpec from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateMethodGet from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateMethodGet.js\";\nimport _classPrivateFieldGet from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nimport _classPrivateFieldSet from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\nimport _createClass from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _defineProperty from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n/**\n *  About Interface\n *\n *  @_subsection api/abi:Interfaces  [interfaces]\n */\nimport { keccak256 } from \"../crypto/index.js\";\nimport { id } from \"../hash/index.js\";\nimport { concat, dataSlice, getBigInt, getBytes, getBytesCopy, hexlify, zeroPadValue, isHexString, defineProperties, assertArgument, toBeHex, assert } from \"../utils/index.js\";\nimport { AbiCoder } from \"./abi-coder.js\";\nimport { checkResultErrors, Result } from \"./coders/abstract-coder.js\";\nimport { ConstructorFragment, ErrorFragment, EventFragment, Fragment, FunctionFragment, ParamType } from \"./fragments.js\";\nimport { Typed } from \"./typed.js\";\nexport { checkResultErrors, Result };\nexport var LogDescription = /*#__PURE__*/_createClass(function LogDescription(fragment, topic, args) {\n  _classCallCheck(this, LogDescription);\n  _defineProperty(this, \"fragment\", void 0);\n  _defineProperty(this, \"name\", void 0);\n  _defineProperty(this, \"signature\", void 0);\n  _defineProperty(this, \"topic\", void 0);\n  _defineProperty(this, \"args\", void 0);\n  var name = fragment.name,\n    signature = fragment.format();\n  defineProperties(this, {\n    fragment: fragment,\n    name: name,\n    signature: signature,\n    topic: topic,\n    args: args\n  });\n});\nexport var TransactionDescription = /*#__PURE__*/_createClass(function TransactionDescription(fragment, selector, args, value) {\n  _classCallCheck(this, TransactionDescription);\n  _defineProperty(this, \"fragment\", void 0);\n  _defineProperty(this, \"name\", void 0);\n  _defineProperty(this, \"args\", void 0);\n  _defineProperty(this, \"signature\", void 0);\n  _defineProperty(this, \"selector\", void 0);\n  _defineProperty(this, \"value\", void 0);\n  var name = fragment.name,\n    signature = fragment.format();\n  defineProperties(this, {\n    fragment: fragment,\n    name: name,\n    args: args,\n    signature: signature,\n    selector: selector,\n    value: value\n  });\n});\nexport var ErrorDescription = /*#__PURE__*/_createClass(function ErrorDescription(fragment, selector, args) {\n  _classCallCheck(this, ErrorDescription);\n  _defineProperty(this, \"fragment\", void 0);\n  _defineProperty(this, \"name\", void 0);\n  _defineProperty(this, \"args\", void 0);\n  _defineProperty(this, \"signature\", void 0);\n  _defineProperty(this, \"selector\", void 0);\n  var name = fragment.name,\n    signature = fragment.format();\n  defineProperties(this, {\n    fragment: fragment,\n    name: name,\n    args: args,\n    signature: signature,\n    selector: selector\n  });\n});\nexport var Indexed = /*#__PURE__*/function () {\n  function Indexed(hash) {\n    _classCallCheck(this, Indexed);\n    _defineProperty(this, \"hash\", void 0);\n    _defineProperty(this, \"_isIndexed\", void 0);\n    defineProperties(this, {\n      hash: hash,\n      _isIndexed: true\n    });\n  }\n  _createClass(Indexed, null, [{\n    key: \"isIndexed\",\n    value: function isIndexed(value) {\n      return !!(value && value._isIndexed);\n    }\n  }]);\n  return Indexed;\n}();\n// https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require\nvar PanicReasons = {\n  \"0\": \"generic panic\",\n  \"1\": \"assert(false)\",\n  \"17\": \"arithmetic overflow\",\n  \"18\": \"division or modulo by zero\",\n  \"33\": \"enum overflow\",\n  \"34\": \"invalid encoded storage byte array accessed\",\n  \"49\": \"out-of-bounds array access; popping on an empty array\",\n  \"50\": \"out-of-bounds access of an array or bytesN\",\n  \"65\": \"out of memory\",\n  \"81\": \"uninitialized function\"\n};\nvar BuiltinErrors = {\n  \"0x08c379a0\": {\n    signature: \"Error(string)\",\n    name: \"Error\",\n    inputs: [\"string\"],\n    reason: function reason(message) {\n      return \"reverted with reason string \".concat(JSON.stringify(message));\n    }\n  },\n  \"0x4e487b71\": {\n    signature: \"Panic(uint256)\",\n    name: \"Panic\",\n    inputs: [\"uint256\"],\n    reason: function reason(code) {\n      var reason = \"unknown panic code\";\n      if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {\n        reason = PanicReasons[code.toString()];\n      }\n      return \"reverted with panic code 0x\".concat(code.toString(16), \" (\").concat(reason, \")\");\n    }\n  }\n};\n/**\n *  An Interface abstracts many of the low-level details for\n *  encoding and decoding the data on the blockchain.\n *\n *  An ABI provides information on how to encode data to send to\n *  a Contract, how to decode the results and events and how to\n *  interpret revert errors.\n *\n *  The ABI can be specified by [any supported format](InterfaceAbi).\n */\nvar _errors = /*#__PURE__*/new WeakMap();\nvar _events = /*#__PURE__*/new WeakMap();\nvar _functions = /*#__PURE__*/new WeakMap();\nvar _abiCoder = /*#__PURE__*/new WeakMap();\nvar _getFunction = /*#__PURE__*/new WeakSet();\nvar _getEvent = /*#__PURE__*/new WeakSet();\nexport var Interface = /*#__PURE__*/function () {\n  /**\n   *  Create a new Interface for the %%fragments%%.\n   */\n  function Interface(fragments) {\n    var _this = this;\n    _classCallCheck(this, Interface);\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    _classPrivateMethodInitSpec(this, _getEvent);\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    _classPrivateMethodInitSpec(this, _getFunction);\n    /**\n     *  All the Contract ABI members (i.e. methods, events, errors, etc).\n     */\n    _defineProperty(this, \"fragments\", void 0);\n    /**\n     *  The Contract constructor.\n     */\n    _defineProperty(this, \"deploy\", void 0);\n    /**\n     *  The Fallback method, if any.\n     */\n    _defineProperty(this, \"fallback\", void 0);\n    /**\n     *  If receiving ether is supported.\n     */\n    _defineProperty(this, \"receive\", void 0);\n    _classPrivateFieldInitSpec(this, _errors, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _events, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _functions, {\n      writable: true,\n      value: void 0\n    });\n    //    #structs: Map<string, StructFragment>;\n    _classPrivateFieldInitSpec(this, _abiCoder, {\n      writable: true,\n      value: void 0\n    });\n    var abi = [];\n    if (typeof fragments === \"string\") {\n      abi = JSON.parse(fragments);\n    } else {\n      abi = fragments;\n    }\n    _classPrivateFieldSet(this, _functions, new Map());\n    _classPrivateFieldSet(this, _errors, new Map());\n    _classPrivateFieldSet(this, _events, new Map());\n    //        this.#structs = new Map();\n    var frags = [];\n    var _iterator = _createForOfIteratorHelper(abi),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var a = _step.value;\n        try {\n          frags.push(Fragment.from(a));\n        } catch (error) {\n          console.log(\"EE\", error);\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    defineProperties(this, {\n      fragments: Object.freeze(frags)\n    });\n    var fallback = null;\n    var receive = false;\n    _classPrivateFieldSet(this, _abiCoder, this.getAbiCoder());\n    // Add all fragments by their signature\n    this.fragments.forEach(function (fragment, index) {\n      var bucket;\n      switch (fragment.type) {\n        case \"constructor\":\n          if (_this.deploy) {\n            console.log(\"duplicate definition - constructor\");\n            return;\n          }\n          //checkNames(fragment, \"input\", fragment.inputs);\n          defineProperties(_this, {\n            deploy: fragment\n          });\n          return;\n        case \"fallback\":\n          if (fragment.inputs.length === 0) {\n            receive = true;\n          } else {\n            assertArgument(!fallback || fragment.payable !== fallback.payable, \"conflicting fallback fragments\", \"fragments[\".concat(index, \"]\"), fragment);\n            fallback = fragment;\n            receive = fallback.payable;\n          }\n          return;\n        case \"function\":\n          //checkNames(fragment, \"input\", fragment.inputs);\n          //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n          bucket = _classPrivateFieldGet(_this, _functions);\n          break;\n        case \"event\":\n          //checkNames(fragment, \"input\", fragment.inputs);\n          bucket = _classPrivateFieldGet(_this, _events);\n          break;\n        case \"error\":\n          bucket = _classPrivateFieldGet(_this, _errors);\n          break;\n        default:\n          return;\n      }\n      // Two identical entries; ignore it\n      var signature = fragment.format();\n      if (bucket.has(signature)) {\n        return;\n      }\n      bucket.set(signature, fragment);\n    });\n    // If we do not have a constructor add a default\n    if (!this.deploy) {\n      defineProperties(this, {\n        deploy: ConstructorFragment.from(\"constructor()\")\n      });\n    }\n    defineProperties(this, {\n      fallback: fallback,\n      receive: receive\n    });\n  }\n  /**\n   *  Returns the entire Human-Readable ABI, as an array of\n   *  signatures, optionally as %%minimal%% strings, which\n   *  removes parameter names and unneceesary spaces.\n   */\n  _createClass(Interface, [{\n    key: \"format\",\n    value: function format(minimal) {\n      var format = minimal ? \"minimal\" : \"full\";\n      var abi = this.fragments.map(function (f) {\n        return f.format(format);\n      });\n      return abi;\n    }\n    /**\n     *  Return the JSON-encoded ABI. This is the format Solidiy\n     *  returns.\n     */\n  }, {\n    key: \"formatJson\",\n    value: function formatJson() {\n      var abi = this.fragments.map(function (f) {\n        return f.format(\"json\");\n      });\n      // We need to re-bundle the JSON fragments a bit\n      return JSON.stringify(abi.map(function (j) {\n        return JSON.parse(j);\n      }));\n    }\n    /**\n     *  The ABI coder that will be used to encode and decode binary\n     *  data.\n     */\n  }, {\n    key: \"getAbiCoder\",\n    value: function getAbiCoder() {\n      return AbiCoder.defaultAbiCoder();\n    }\n  }, {\n    key: \"getFunctionName\",\n    value:\n    /**\n     *  Get the function name for %%key%%, which may be a function selector,\n     *  function name or function signature that belongs to the ABI.\n     */\n    function getFunctionName(key) {\n      var fragment = _classPrivateMethodGet(this, _getFunction, _getFunction2).call(this, key, null, false);\n      assertArgument(fragment, \"no matching function\", \"key\", key);\n      return fragment.name;\n    }\n    /**\n     *  Returns true if %%key%% (a function selector, function name or\n     *  function signature) is present in the ABI.\n     *\n     *  In the case of a function name, the name may be ambiguous, so\n     *  accessing the [[FunctionFragment]] may require refinement.\n     */\n  }, {\n    key: \"hasFunction\",\n    value: function hasFunction(key) {\n      return !!_classPrivateMethodGet(this, _getFunction, _getFunction2).call(this, key, null, false);\n    }\n    /**\n     *  Get the [[FunctionFragment]] for %%key%%, which may be a function\n     *  selector, function name or function signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple functions match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single function in\n     *  the ABI, this will throw.\n     */\n  }, {\n    key: \"getFunction\",\n    value: function getFunction(key, values) {\n      return _classPrivateMethodGet(this, _getFunction, _getFunction2).call(this, key, values || null, true);\n    }\n    /**\n     *  Iterate over all functions, calling %%callback%%, sorted by their name.\n     */\n  }, {\n    key: \"forEachFunction\",\n    value: function forEachFunction(callback) {\n      var names = Array.from(_classPrivateFieldGet(this, _functions).keys());\n      names.sort(function (a, b) {\n        return a.localeCompare(b);\n      });\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        callback(_classPrivateFieldGet(this, _functions).get(name), i);\n      }\n    }\n  }, {\n    key: \"getEventName\",\n    value:\n    /**\n     *  Get the event name for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     */\n    function getEventName(key) {\n      var fragment = _classPrivateMethodGet(this, _getEvent, _getEvent2).call(this, key, null, false);\n      assertArgument(fragment, \"no matching event\", \"key\", key);\n      return fragment.name;\n    }\n    /**\n     *  Returns true if %%key%% (an event topic hash, event name or\n     *  event signature) is present in the ABI.\n     *\n     *  In the case of an event name, the name may be ambiguous, so\n     *  accessing the [[EventFragment]] may require refinement.\n     */\n  }, {\n    key: \"hasEvent\",\n    value: function hasEvent(key) {\n      return !!_classPrivateMethodGet(this, _getEvent, _getEvent2).call(this, key, null, false);\n    }\n    /**\n     *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple events match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single event in\n     *  the ABI, this will throw.\n     */\n  }, {\n    key: \"getEvent\",\n    value: function getEvent(key, values) {\n      return _classPrivateMethodGet(this, _getEvent, _getEvent2).call(this, key, values || null, true);\n    }\n    /**\n     *  Iterate over all events, calling %%callback%%, sorted by their name.\n     */\n  }, {\n    key: \"forEachEvent\",\n    value: function forEachEvent(callback) {\n      var names = Array.from(_classPrivateFieldGet(this, _events).keys());\n      names.sort(function (a, b) {\n        return a.localeCompare(b);\n      });\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        callback(_classPrivateFieldGet(this, _events).get(name), i);\n      }\n    }\n    /**\n     *  Get the [[ErrorFragment]] for %%key%%, which may be an error\n     *  selector, error name or error signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple errors match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single error in\n     *  the ABI, this will throw.\n     */\n  }, {\n    key: \"getError\",\n    value: function getError(key, values) {\n      if (isHexString(key)) {\n        var selector = key.toLowerCase();\n        if (BuiltinErrors[selector]) {\n          return ErrorFragment.from(BuiltinErrors[selector].signature);\n        }\n        var _iterator2 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _errors).values()),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var fragment = _step2.value;\n            if (selector === fragment.selector) {\n              return fragment;\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        return null;\n      }\n      // It is a bare name, look up the function (will return null if ambiguous)\n      if (key.indexOf(\"(\") === -1) {\n        var matching = [];\n        var _iterator3 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _errors)),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _step3$value = _slicedToArray(_step3.value, 2),\n              name = _step3$value[0],\n              _fragment = _step3$value[1];\n            if (name.split(\"(\" /* fix:) */)[0] === key) {\n              matching.push(_fragment);\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n        if (matching.length === 0) {\n          if (key === \"Error\") {\n            return ErrorFragment.from(\"error Error(string)\");\n          }\n          if (key === \"Panic\") {\n            return ErrorFragment.from(\"error Panic(uint256)\");\n          }\n          return null;\n        } else if (matching.length > 1) {\n          var matchStr = matching.map(function (m) {\n            return JSON.stringify(m.format());\n          }).join(\", \");\n          assertArgument(false, \"ambiguous error description (i.e. \".concat(matchStr, \")\"), \"name\", key);\n        }\n        return matching[0];\n      }\n      // Normalize the signature and lookup the function\n      key = ErrorFragment.from(key).format();\n      if (key === \"Error(string)\") {\n        return ErrorFragment.from(\"error Error(string)\");\n      }\n      if (key === \"Panic(uint256)\") {\n        return ErrorFragment.from(\"error Panic(uint256)\");\n      }\n      var result = _classPrivateFieldGet(this, _errors).get(key);\n      if (result) {\n        return result;\n      }\n      return null;\n    }\n    /**\n     *  Iterate over all errors, calling %%callback%%, sorted by their name.\n     */\n  }, {\n    key: \"forEachError\",\n    value: function forEachError(callback) {\n      var names = Array.from(_classPrivateFieldGet(this, _errors).keys());\n      names.sort(function (a, b) {\n        return a.localeCompare(b);\n      });\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        callback(_classPrivateFieldGet(this, _errors).get(name), i);\n      }\n    }\n    // Get the 4-byte selector used by Solidity to identify a function\n    /*\n    getSelector(fragment: ErrorFragment | FunctionFragment): string {\n    if (typeof(fragment) === \"string\") {\n        const matches: Array<Fragment> = [ ];\n         try { matches.push(this.getFunction(fragment)); } catch (error) { }\n        try { matches.push(this.getError(<string>fragment)); } catch (_) { }\n         if (matches.length === 0) {\n            logger.throwArgumentError(\"unknown fragment\", \"key\", fragment);\n        } else if (matches.length > 1) {\n            logger.throwArgumentError(\"ambiguous fragment matches function and error\", \"key\", fragment);\n        }\n         fragment = matches[0];\n    }\n     return dataSlice(id(fragment.format()), 0, 4);\n    }\n    */\n    // Get the 32-byte topic hash used by Solidity to identify an event\n    /*\n    getEventTopic(fragment: EventFragment): string {\n        //if (typeof(fragment) === \"string\") { fragment = this.getEvent(eventFragment); }\n        return id(fragment.format());\n    }\n    */\n  }, {\n    key: \"_decodeParams\",\n    value: function _decodeParams(params, data) {\n      return _classPrivateFieldGet(this, _abiCoder).decode(params, data);\n    }\n  }, {\n    key: \"_encodeParams\",\n    value: function _encodeParams(params, values) {\n      return _classPrivateFieldGet(this, _abiCoder).encode(params, values);\n    }\n    /**\n     *  Encodes a ``tx.data`` object for deploying the Contract with\n     *  the %%values%% as the constructor arguments.\n     */\n  }, {\n    key: \"encodeDeploy\",\n    value: function encodeDeploy(values) {\n      return this._encodeParams(this.deploy.inputs, values || []);\n    }\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified error (see [[getError]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */\n  }, {\n    key: \"decodeErrorResult\",\n    value: function decodeErrorResult(fragment, data) {\n      if (typeof fragment === \"string\") {\n        var f = this.getError(fragment);\n        assertArgument(f, \"unknown error\", \"fragment\", fragment);\n        fragment = f;\n      }\n      assertArgument(dataSlice(data, 0, 4) === fragment.selector, \"data signature does not match error \".concat(fragment.name, \".\"), \"data\", data);\n      return this._decodeParams(fragment.inputs, dataSlice(data, 4));\n    }\n    /**\n     *  Encodes the transaction revert data for a call result that\n     *  reverted from the the Contract with the sepcified %%error%%\n     *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */\n  }, {\n    key: \"encodeErrorResult\",\n    value: function encodeErrorResult(fragment, values) {\n      if (typeof fragment === \"string\") {\n        var f = this.getError(fragment);\n        assertArgument(f, \"unknown error\", \"fragment\", fragment);\n        fragment = f;\n      }\n      return concat([fragment.selector, this._encodeParams(fragment.inputs, values || [])]);\n    }\n    /**\n     *  Decodes the %%data%% from a transaction ``tx.data`` for\n     *  the function specified (see [[getFunction]] for valid values\n     *  for %%fragment%%).\n     *\n     *  Most developers should prefer the [[parseTransaction]] method\n     *  instead, which will automatically detect the fragment.\n     */\n  }, {\n    key: \"decodeFunctionData\",\n    value: function decodeFunctionData(fragment, data) {\n      if (typeof fragment === \"string\") {\n        var f = this.getFunction(fragment);\n        assertArgument(f, \"unknown function\", \"fragment\", fragment);\n        fragment = f;\n      }\n      assertArgument(dataSlice(data, 0, 4) === fragment.selector, \"data signature does not match function \".concat(fragment.name, \".\"), \"data\", data);\n      return this._decodeParams(fragment.inputs, dataSlice(data, 4));\n    }\n    /**\n     *  Encodes the ``tx.data`` for a transaction that calls the function\n     *  specified (see [[getFunction]] for valid values for %%fragment%%) with\n     *  the %%values%%.\n     */\n  }, {\n    key: \"encodeFunctionData\",\n    value: function encodeFunctionData(fragment, values) {\n      if (typeof fragment === \"string\") {\n        var f = this.getFunction(fragment);\n        assertArgument(f, \"unknown function\", \"fragment\", fragment);\n        fragment = f;\n      }\n      return concat([fragment.selector, this._encodeParams(fragment.inputs, values || [])]);\n    }\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */\n  }, {\n    key: \"decodeFunctionResult\",\n    value: function decodeFunctionResult(fragment, data) {\n      if (typeof fragment === \"string\") {\n        var f = this.getFunction(fragment);\n        assertArgument(f, \"unknown function\", \"fragment\", fragment);\n        fragment = f;\n      }\n      var message = \"invalid length for result data\";\n      var bytes = getBytesCopy(data);\n      if (bytes.length % 32 === 0) {\n        try {\n          return _classPrivateFieldGet(this, _abiCoder).decode(fragment.outputs, bytes);\n        } catch (error) {\n          message = \"could not decode result data\";\n        }\n      }\n      // Call returned data with no error, but the data is junk\n      assert(false, message, \"BAD_DATA\", {\n        value: hexlify(bytes),\n        info: {\n          method: fragment.name,\n          signature: fragment.format()\n        }\n      });\n    }\n  }, {\n    key: \"makeError\",\n    value: function makeError(_data, tx) {\n      var data = getBytes(_data, \"data\");\n      var error = AbiCoder.getBuiltinCallException(\"call\", tx, data);\n      // Not a built-in error; try finding a custom error\n      var customPrefix = \"execution reverted (unknown custom error)\";\n      if (error.message.startsWith(customPrefix)) {\n        var selector = hexlify(data.slice(0, 4));\n        var ef = this.getError(selector);\n        if (ef) {\n          try {\n            var args = _classPrivateFieldGet(this, _abiCoder).decode(ef.inputs, data.slice(4));\n            error.revert = {\n              name: ef.name,\n              signature: ef.format(),\n              args: args\n            };\n            error.reason = error.revert.signature;\n            error.message = \"execution reverted: \".concat(error.reason);\n          } catch (e) {\n            error.message = \"execution reverted (coult not decode custom error)\";\n          }\n        }\n      }\n      // Add the invocation, if available\n      var parsed = this.parseTransaction(tx);\n      if (parsed) {\n        error.invocation = {\n          method: parsed.name,\n          signature: parsed.signature,\n          args: parsed.args\n        };\n      }\n      return error;\n    }\n    /**\n     *  Encodes the result data (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values\n     *  for %%fragment%%) with %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */\n  }, {\n    key: \"encodeFunctionResult\",\n    value: function encodeFunctionResult(fragment, values) {\n      if (typeof fragment === \"string\") {\n        var f = this.getFunction(fragment);\n        assertArgument(f, \"unknown function\", \"fragment\", fragment);\n        fragment = f;\n      }\n      return hexlify(_classPrivateFieldGet(this, _abiCoder).encode(fragment.outputs, values || []));\n    }\n    /*\n        spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {\n            const promises: Array<Promise<>> = [ ];\n            const process = function(type: ParamType, value: any): any {\n                if (type.baseType === \"array\") {\n                    return descend(type.child\n                }\n                if (type. === \"address\") {\n                }\n            };\n    \n            const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {\n                if (inputs.length !== values.length) { throw new Error(\"length mismatch\"); }\n                \n            };\n    \n            const result: Array<any> = [ ];\n            values.forEach((value, index) => {\n                if (value == null) {\n                    topics.push(null);\n                } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                    logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n                } else if (Array.isArray(value)) {\n                    topics.push(value.map((value) => encodeTopic(param, value)));\n                } else {\n                    topics.push(encodeTopic(param, value));\n                }\n            });\n        }\n    */\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n  }, {\n    key: \"encodeFilterTopics\",\n    value: function encodeFilterTopics(fragment, values) {\n      var _this2 = this;\n      if (typeof fragment === \"string\") {\n        var f = this.getEvent(fragment);\n        assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n        fragment = f;\n      }\n      assert(values.length <= fragment.inputs.length, \"too many arguments for \".concat(fragment.format()), \"UNEXPECTED_ARGUMENT\", {\n        count: values.length,\n        expectedCount: fragment.inputs.length\n      });\n      var topics = [];\n      if (!fragment.anonymous) {\n        topics.push(fragment.topicHash);\n      }\n      // @TODO: Use the coders for this; to properly support tuples, etc.\n      var encodeTopic = function encodeTopic(param, value) {\n        if (param.type === \"string\") {\n          return id(value);\n        } else if (param.type === \"bytes\") {\n          return keccak256(hexlify(value));\n        }\n        if (param.type === \"bool\" && typeof value === \"boolean\") {\n          value = value ? \"0x01\" : \"0x00\";\n        }\n        if (param.type.match(/^u?int/)) {\n          value = toBeHex(value);\n        }\n        // Check addresses are valid\n        if (param.type === \"address\") {\n          _classPrivateFieldGet(_this2, _abiCoder).encode([\"address\"], [value]);\n        }\n        return zeroPadValue(hexlify(value), 32);\n        //@TOOD should probably be return toHex(value, 32)\n      };\n\n      values.forEach(function (value, index) {\n        var param = fragment.inputs[index];\n        if (!param.indexed) {\n          assertArgument(value == null, \"cannot filter non-indexed parameters; must be null\", \"contract.\" + param.name, value);\n          return;\n        }\n        if (value == null) {\n          topics.push(null);\n        } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n          assertArgument(false, \"filtering with tuples or arrays not supported\", \"contract.\" + param.name, value);\n        } else if (Array.isArray(value)) {\n          topics.push(value.map(function (value) {\n            return encodeTopic(param, value);\n          }));\n        } else {\n          topics.push(encodeTopic(param, value));\n        }\n      });\n      // Trim off trailing nulls\n      while (topics.length && topics[topics.length - 1] === null) {\n        topics.pop();\n      }\n      return topics;\n    }\n  }, {\n    key: \"encodeEventLog\",\n    value: function encodeEventLog(fragment, values) {\n      var _this3 = this;\n      if (typeof fragment === \"string\") {\n        var f = this.getEvent(fragment);\n        assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n        fragment = f;\n      }\n      var topics = [];\n      var dataTypes = [];\n      var dataValues = [];\n      if (!fragment.anonymous) {\n        topics.push(fragment.topicHash);\n      }\n      assertArgument(values.length === fragment.inputs.length, \"event arguments/values mismatch\", \"values\", values);\n      fragment.inputs.forEach(function (param, index) {\n        var value = values[index];\n        if (param.indexed) {\n          if (param.type === \"string\") {\n            topics.push(id(value));\n          } else if (param.type === \"bytes\") {\n            topics.push(keccak256(value));\n          } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n            // @TODO\n            throw new Error(\"not implemented\");\n          } else {\n            topics.push(_classPrivateFieldGet(_this3, _abiCoder).encode([param.type], [value]));\n          }\n        } else {\n          dataTypes.push(param);\n          dataValues.push(value);\n        }\n      });\n      return {\n        data: _classPrivateFieldGet(this, _abiCoder).encode(dataTypes, dataValues),\n        topics: topics\n      };\n    }\n    // Decode a filter for the event and the search criteria\n  }, {\n    key: \"decodeEventLog\",\n    value: function decodeEventLog(fragment, data, topics) {\n      if (typeof fragment === \"string\") {\n        var f = this.getEvent(fragment);\n        assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n        fragment = f;\n      }\n      if (topics != null && !fragment.anonymous) {\n        var eventTopic = fragment.topicHash;\n        assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic, \"fragment/topic mismatch\", \"topics[0]\", topics[0]);\n        topics = topics.slice(1);\n      }\n      var indexed = [];\n      var nonIndexed = [];\n      var dynamic = [];\n      fragment.inputs.forEach(function (param, index) {\n        if (param.indexed) {\n          if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n            indexed.push(ParamType.from({\n              type: \"bytes32\",\n              name: param.name\n            }));\n            dynamic.push(true);\n          } else {\n            indexed.push(param);\n            dynamic.push(false);\n          }\n        } else {\n          nonIndexed.push(param);\n          dynamic.push(false);\n        }\n      });\n      var resultIndexed = topics != null ? _classPrivateFieldGet(this, _abiCoder).decode(indexed, concat(topics)) : null;\n      var resultNonIndexed = _classPrivateFieldGet(this, _abiCoder).decode(nonIndexed, data, true);\n      //const result: (Array<any> & { [ key: string ]: any }) = [ ];\n      var values = [];\n      var keys = [];\n      var nonIndexedIndex = 0,\n        indexedIndex = 0;\n      fragment.inputs.forEach(function (param, index) {\n        var value = null;\n        if (param.indexed) {\n          if (resultIndexed == null) {\n            value = new Indexed(null);\n          } else if (dynamic[index]) {\n            value = new Indexed(resultIndexed[indexedIndex++]);\n          } else {\n            try {\n              value = resultIndexed[indexedIndex++];\n            } catch (error) {\n              value = error;\n            }\n          }\n        } else {\n          try {\n            value = resultNonIndexed[nonIndexedIndex++];\n          } catch (error) {\n            value = error;\n          }\n        }\n        values.push(value);\n        keys.push(param.name || null);\n      });\n      return Result.fromItems(values, keys);\n    }\n    /**\n     *  Parses a transaction, finding the matching function and extracts\n     *  the parameter values along with other useful function details.\n     *\n     *  If the matching function cannot be found, return null.\n     */\n  }, {\n    key: \"parseTransaction\",\n    value: function parseTransaction(tx) {\n      var data = getBytes(tx.data, \"tx.data\");\n      var value = getBigInt(tx.value != null ? tx.value : 0, \"tx.value\");\n      var fragment = this.getFunction(hexlify(data.slice(0, 4)));\n      if (!fragment) {\n        return null;\n      }\n      var args = _classPrivateFieldGet(this, _abiCoder).decode(fragment.inputs, data.slice(4));\n      return new TransactionDescription(fragment, fragment.selector, args, value);\n    }\n  }, {\n    key: \"parseCallResult\",\n    value: function parseCallResult(data) {\n      throw new Error(\"@TODO\");\n    }\n    /**\n     *  Parses a receipt log, finding the matching event and extracts\n     *  the parameter values along with other useful event details.\n     *\n     *  If the matching event cannot be found, returns null.\n     */\n  }, {\n    key: \"parseLog\",\n    value: function parseLog(log) {\n      var fragment = this.getEvent(log.topics[0]);\n      if (!fragment || fragment.anonymous) {\n        return null;\n      }\n      // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n      //        Probably not, because just because it is the only event in the ABI does\n      //        not mean we have the full ABI; maybe just a fragment?\n      return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));\n    }\n    /**\n     *  Parses a revert data, finding the matching error and extracts\n     *  the parameter values along with other useful error details.\n     *\n     *  If the matching event cannot be found, returns null.\n     */\n  }, {\n    key: \"parseError\",\n    value: function parseError(data) {\n      var hexData = hexlify(data);\n      var fragment = this.getError(dataSlice(hexData, 0, 4));\n      if (!fragment) {\n        return null;\n      }\n      var args = _classPrivateFieldGet(this, _abiCoder).decode(fragment.inputs, dataSlice(hexData, 4));\n      return new ErrorDescription(fragment, fragment.selector, args);\n    }\n    /**\n     *  Creates a new [[Interface]] from the ABI %%value%%.\n     *\n     *  The %%value%% may be provided as an existing [[Interface]] object,\n     *  a JSON-encoded ABI or any Human-Readable ABI format.\n     */\n  }], [{\n    key: \"from\",\n    value: function from(value) {\n      // Already an Interface, which is immutable\n      if (value instanceof Interface) {\n        return value;\n      }\n      // JSON\n      if (typeof value === \"string\") {\n        return new Interface(JSON.parse(value));\n      }\n      // Maybe an interface from an older version, or from a symlinked copy\n      if (typeof value.format === \"function\") {\n        return new Interface(value.format(\"json\"));\n      }\n      // Array of fragments\n      return new Interface(value);\n    }\n  }]);\n  return Interface;\n}();\nfunction _getFunction2(key, values, forceUnique) {\n  // Selector\n  if (isHexString(key)) {\n    var selector = key.toLowerCase();\n    var _iterator4 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _functions).values()),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var fragment = _step4.value;\n        if (selector === fragment.selector) {\n          return fragment;\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n    return null;\n  }\n  // It is a bare name, look up the function (will return null if ambiguous)\n  if (key.indexOf(\"(\") === -1) {\n    var matching = [];\n    var _iterator5 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _functions)),\n      _step5;\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var _step5$value = _slicedToArray(_step5.value, 2),\n          name = _step5$value[0],\n          _fragment2 = _step5$value[1];\n        if (name.split(\"(\" /* fix:) */)[0] === key) {\n          matching.push(_fragment2);\n        }\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n    if (values) {\n      var lastValue = values.length > 0 ? values[values.length - 1] : null;\n      var valueLength = values.length;\n      var allowOptions = true;\n      if (Typed.isTyped(lastValue) && lastValue.type === \"overrides\") {\n        allowOptions = false;\n        valueLength--;\n      }\n      // Remove all matches that don't have a compatible length. The args\n      // may contain an overrides, so the match may have n or n - 1 parameters\n      for (var i = matching.length - 1; i >= 0; i--) {\n        var inputs = matching[i].inputs.length;\n        if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {\n          matching.splice(i, 1);\n        }\n      }\n      // Remove all matches that don't match the Typed signature\n      for (var _i = matching.length - 1; _i >= 0; _i--) {\n        var _inputs = matching[_i].inputs;\n        for (var j = 0; j < values.length; j++) {\n          // Not a typed value\n          if (!Typed.isTyped(values[j])) {\n            continue;\n          }\n          // We are past the inputs\n          if (j >= _inputs.length) {\n            if (values[j].type === \"overrides\") {\n              continue;\n            }\n            matching.splice(_i, 1);\n            break;\n          }\n          // Make sure the value type matches the input type\n          if (values[j].type !== _inputs[j].baseType) {\n            matching.splice(_i, 1);\n            break;\n          }\n        }\n      }\n    }\n    // We found a single matching signature with an overrides, but the\n    // last value is something that cannot possibly be an options\n    if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {\n      var lastArg = values[values.length - 1];\n      if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== \"object\") {\n        matching.splice(0, 1);\n      }\n    }\n    if (matching.length === 0) {\n      return null;\n    }\n    if (matching.length > 1 && forceUnique) {\n      var matchStr = matching.map(function (m) {\n        return JSON.stringify(m.format());\n      }).join(\", \");\n      assertArgument(false, \"ambiguous function description (i.e. matches \".concat(matchStr, \")\"), \"key\", key);\n    }\n    return matching[0];\n  }\n  // Normalize the signature and lookup the function\n  var result = _classPrivateFieldGet(this, _functions).get(FunctionFragment.from(key).format());\n  if (result) {\n    return result;\n  }\n  return null;\n}\nfunction _getEvent2(key, values, forceUnique) {\n  // EventTopic\n  if (isHexString(key)) {\n    var eventTopic = key.toLowerCase();\n    var _iterator6 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _events).values()),\n      _step6;\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var fragment = _step6.value;\n        if (eventTopic === fragment.topicHash) {\n          return fragment;\n        }\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n    return null;\n  }\n  // It is a bare name, look up the function (will return null if ambiguous)\n  if (key.indexOf(\"(\") === -1) {\n    var matching = [];\n    var _iterator7 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _events)),\n      _step7;\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var _step7$value = _slicedToArray(_step7.value, 2),\n          name = _step7$value[0],\n          _fragment3 = _step7$value[1];\n        if (name.split(\"(\" /* fix:) */)[0] === key) {\n          matching.push(_fragment3);\n        }\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n    if (values) {\n      // Remove all matches that don't have a compatible length.\n      for (var i = matching.length - 1; i >= 0; i--) {\n        if (matching[i].inputs.length < values.length) {\n          matching.splice(i, 1);\n        }\n      }\n      // Remove all matches that don't match the Typed signature\n      for (var _i2 = matching.length - 1; _i2 >= 0; _i2--) {\n        var inputs = matching[_i2].inputs;\n        for (var j = 0; j < values.length; j++) {\n          // Not a typed value\n          if (!Typed.isTyped(values[j])) {\n            continue;\n          }\n          // Make sure the value type matches the input type\n          if (values[j].type !== inputs[j].baseType) {\n            matching.splice(_i2, 1);\n            break;\n          }\n        }\n      }\n    }\n    if (matching.length === 0) {\n      return null;\n    }\n    if (matching.length > 1 && forceUnique) {\n      var matchStr = matching.map(function (m) {\n        return JSON.stringify(m.format());\n      }).join(\", \");\n      assertArgument(false, \"ambiguous event description (i.e. matches \".concat(matchStr, \")\"), \"key\", key);\n    }\n    return matching[0];\n  }\n  // Normalize the signature and lookup the function\n  var result = _classPrivateFieldGet(this, _events).get(EventFragment.from(key).format());\n  if (result) {\n    return result;\n  }\n  return null;\n}","map":{"version":3,"names":["keccak256","id","concat","dataSlice","getBigInt","getBytes","getBytesCopy","hexlify","zeroPadValue","isHexString","defineProperties","assertArgument","toBeHex","assert","AbiCoder","checkResultErrors","Result","ConstructorFragment","ErrorFragment","EventFragment","Fragment","FunctionFragment","ParamType","Typed","LogDescription","_createClass","fragment","topic","args","_classCallCheck","_defineProperty","name","signature","format","TransactionDescription","selector","value","ErrorDescription","Indexed","hash","_isIndexed","key","isIndexed","PanicReasons","BuiltinErrors","inputs","reason","message","JSON","stringify","code","toString","_errors","WeakMap","_events","_functions","_abiCoder","_getFunction","WeakSet","_getEvent","Interface","fragments","_this","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","writable","abi","parse","_classPrivateFieldSet","Map","frags","_iterator","_createForOfIteratorHelper","_step","s","n","done","a","push","from","error","console","log","err","e","f","Object","freeze","fallback","receive","getAbiCoder","forEach","index","bucket","type","deploy","length","payable","_classPrivateFieldGet","has","set","minimal","map","formatJson","j","defaultAbiCoder","getFunctionName","_classPrivateMethodGet","_getFunction2","call","hasFunction","getFunction","values","forEachFunction","callback","names","Array","keys","sort","b","localeCompare","i","get","getEventName","_getEvent2","hasEvent","getEvent","forEachEvent","getError","toLowerCase","_iterator2","_step2","indexOf","matching","_iterator3","_step3","_step3$value","_slicedToArray","split","matchStr","m","join","result","forEachError","_decodeParams","params","data","decode","_encodeParams","encode","encodeDeploy","decodeErrorResult","encodeErrorResult","decodeFunctionData","encodeFunctionData","decodeFunctionResult","bytes","outputs","info","method","makeError","_data","tx","getBuiltinCallException","customPrefix","startsWith","slice","ef","revert","parsed","parseTransaction","invocation","encodeFunctionResult","encodeFilterTopics","_this2","count","expectedCount","topics","anonymous","topicHash","encodeTopic","param","match","indexed","baseType","isArray","pop","encodeEventLog","_this3","dataTypes","dataValues","Error","decodeEventLog","eventTopic","nonIndexed","dynamic","resultIndexed","resultNonIndexed","nonIndexedIndex","indexedIndex","fromItems","parseCallResult","parseLog","parseError","hexData","forceUnique","_iterator4","_step4","_iterator5","_step5","_step5$value","lastValue","valueLength","allowOptions","isTyped","splice","lastArg","_iterator6","_step6","_iterator7","_step7","_step7$value"],"sources":["C:\\Users\\Oguzhan\\Desktop\\BlockGuard\\mwallet\\node_modules\\ethers\\src.ts\\abi\\interface.ts"],"sourcesContent":["/**\n *  About Interface\n *\n *  @_subsection api/abi:Interfaces  [interfaces]\n */\n\nimport { keccak256 } from \"../crypto/index.js\"\nimport { id } from \"../hash/index.js\"\nimport {\n    concat, dataSlice, getBigInt, getBytes, getBytesCopy,\n    hexlify, zeroPadValue, isHexString, defineProperties, assertArgument, toBeHex,\n    assert\n} from \"../utils/index.js\";\n\nimport { AbiCoder } from \"./abi-coder.js\";\nimport { checkResultErrors, Result } from \"./coders/abstract-coder.js\";\nimport {\n    ConstructorFragment, ErrorFragment, EventFragment, FallbackFragment,\n    Fragment, FunctionFragment, ParamType\n} from \"./fragments.js\";\nimport { Typed } from \"./typed.js\";\n\nimport type { BigNumberish, BytesLike, CallExceptionError, CallExceptionTransaction } from \"../utils/index.js\";\n\nimport type { JsonFragment } from \"./fragments.js\";\n\n\nexport { checkResultErrors, Result };\n\nexport class LogDescription {\n    readonly fragment!: EventFragment;\n    readonly name!: string;\n    readonly signature!: string;\n    readonly topic!: string;\n    readonly args!: Result\n\n    constructor(fragment: EventFragment, topic: string, args: Result) {\n        const name = fragment.name, signature = fragment.format();\n        defineProperties<LogDescription>(this, {\n            fragment, name, signature, topic, args\n        });\n    }\n}\n\nexport class TransactionDescription {\n    readonly fragment!: FunctionFragment;\n    readonly name!: string;\n    readonly args!: Result;\n    readonly signature!: string;\n    readonly selector!: string;\n    readonly value!: bigint;\n\n    constructor(fragment: FunctionFragment, selector: string, args: Result, value: bigint) {\n        const name = fragment.name, signature = fragment.format();\n        defineProperties<TransactionDescription>(this, {\n            fragment, name, args, signature, selector, value\n        });\n    }\n}\n\nexport class ErrorDescription {\n    readonly fragment!: ErrorFragment;\n    readonly name!: string;\n    readonly args!: Result;\n    readonly signature!: string;\n    readonly selector!: string;\n\n    constructor(fragment: ErrorFragment, selector: string, args: Result) {\n        const name = fragment.name, signature = fragment.format();\n        defineProperties<ErrorDescription>(this, {\n            fragment, name, args, signature, selector\n        });\n    }\n}\n\nexport class Indexed {\n    readonly hash!: null | string;\n    readonly _isIndexed!: boolean;\n\n    static isIndexed(value: any): value is Indexed {\n        return !!(value && value._isIndexed);\n    }\n\n    constructor(hash: null | string) {\n        defineProperties<Indexed>(this, { hash, _isIndexed: true })\n    }\n}\n\ntype ErrorInfo = {\n    signature: string,\n    inputs: Array<string>,\n    name: string,\n    reason: (...args: Array<any>) => string;\n};\n\n// https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require\nconst PanicReasons: Record<string, string> = {\n    \"0\": \"generic panic\",\n    \"1\": \"assert(false)\",\n    \"17\": \"arithmetic overflow\",\n    \"18\": \"division or modulo by zero\",\n    \"33\": \"enum overflow\",\n    \"34\": \"invalid encoded storage byte array accessed\",\n    \"49\": \"out-of-bounds array access; popping on an empty array\",\n    \"50\": \"out-of-bounds access of an array or bytesN\",\n    \"65\": \"out of memory\",\n    \"81\": \"uninitialized function\",\n}\n\nconst BuiltinErrors: Record<string, ErrorInfo> = {\n    \"0x08c379a0\": {\n        signature: \"Error(string)\",\n        name: \"Error\",\n        inputs: [ \"string\" ],\n        reason: (message: string) => {\n            return `reverted with reason string ${ JSON.stringify(message) }`;\n        }\n    },\n    \"0x4e487b71\": {\n        signature: \"Panic(uint256)\",\n        name: \"Panic\",\n        inputs: [ \"uint256\" ],\n        reason: (code: bigint) => {\n            let reason = \"unknown panic code\";\n            if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {\n                reason = PanicReasons[code.toString()];\n            }\n            return `reverted with panic code 0x${ code.toString(16) } (${ reason })`;\n        }\n    }\n}\n\n/*\nfunction wrapAccessError(property: string, error: Error): Error {\n    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${ property }`);\n    (<any>wrap).error = error;\n    return wrap;\n}\n*/\n/*\nfunction checkNames(fragment: Fragment, type: \"input\" | \"output\", params: Array<ParamType>): void {\n    params.reduce((accum, param) => {\n        if (param.name) {\n            if (accum[param.name]) {\n                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format(\"full\") }`, \"fragment\", fragment);\n            }\n            accum[param.name] = true;\n        }\n        return accum;\n    }, <{ [ name: string ]: boolean }>{ });\n}\n*/\n\n/**\n *  @TODO\n */\nexport type InterfaceAbi = string | ReadonlyArray<Fragment | JsonFragment | string>;\n\n/**\n *  An Interface abstracts many of the low-level details for\n *  encoding and decoding the data on the blockchain.\n *\n *  An ABI provides information on how to encode data to send to\n *  a Contract, how to decode the results and events and how to\n *  interpret revert errors.\n *\n *  The ABI can be specified by [any supported format](InterfaceAbi).\n */\nexport class Interface {\n\n    /**\n     *  All the Contract ABI members (i.e. methods, events, errors, etc).\n     */\n    readonly fragments!: ReadonlyArray<Fragment>;\n\n    /**\n     *  The Contract constructor.\n     */\n    readonly deploy!: ConstructorFragment;\n\n    /**\n     *  The Fallback method, if any.\n     */\n    readonly fallback!: null | FallbackFragment;\n\n    /**\n     *  If receiving ether is supported.\n     */\n    readonly receive!: boolean;\n\n    #errors: Map<string, ErrorFragment>;\n    #events: Map<string, EventFragment>;\n    #functions: Map<string, FunctionFragment>;\n//    #structs: Map<string, StructFragment>;\n\n    #abiCoder: AbiCoder;\n\n    /**\n     *  Create a new Interface for the %%fragments%%.\n     */\n    constructor(fragments: InterfaceAbi) {\n        let abi: ReadonlyArray<Fragment | JsonFragment | string> = [ ];\n        if (typeof(fragments) === \"string\") {\n            abi = JSON.parse(fragments);\n        } else {\n            abi = fragments;\n        }\n\n        this.#functions = new Map();\n        this.#errors = new Map();\n        this.#events = new Map();\n//        this.#structs = new Map();\n\n\n        const frags: Array<Fragment> = [ ];\n        for (const a of abi) {\n            try {\n                frags.push(Fragment.from(a));\n            } catch (error) {\n                console.log(\"EE\", error);\n            }\n        }\n\n        defineProperties<Interface>(this, {\n            fragments: Object.freeze(frags)\n        });\n\n        let fallback: null | FallbackFragment = null;\n        let receive = false;\n\n        this.#abiCoder = this.getAbiCoder();\n\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment, index) => {\n            let bucket: Map<string, Fragment>;\n            switch (fragment.type) {\n                case \"constructor\":\n                    if (this.deploy) {\n                        console.log(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    defineProperties<Interface>(this, { deploy: <ConstructorFragment>fragment });\n                    return;\n\n                case \"fallback\":\n                    if (fragment.inputs.length === 0) {\n                        receive = true;\n                    } else {\n                        assertArgument(!fallback || (<FallbackFragment>fragment).payable !== fallback.payable,\n                            \"conflicting fallback fragments\", `fragments[${ index }]`, fragment);\n                        fallback = <FallbackFragment>fragment;\n                        receive = fallback.payable;\n                    }\n                    return;\n\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.#functions;\n                    break;\n\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.#events;\n                    break;\n\n                case \"error\":\n                    bucket = this.#errors;\n                    break;\n\n                default:\n                    return;\n            }\n\n            // Two identical entries; ignore it\n            const signature = fragment.format();\n            if (bucket.has(signature)) { return; }\n\n            bucket.set(signature, fragment);\n        });\n\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            defineProperties<Interface>(this, {\n                deploy: ConstructorFragment.from(\"constructor()\")\n            });\n        }\n\n        defineProperties<Interface>(this, { fallback, receive });\n    }\n\n    /**\n     *  Returns the entire Human-Readable ABI, as an array of\n     *  signatures, optionally as %%minimal%% strings, which\n     *  removes parameter names and unneceesary spaces.\n     */\n    format(minimal?: boolean): Array<string> {\n        const format = (minimal ? \"minimal\": \"full\");\n        const abi = this.fragments.map((f) => f.format(format));\n        return abi;\n    }\n\n    /**\n     *  Return the JSON-encoded ABI. This is the format Solidiy\n     *  returns.\n     */\n    formatJson(): string {\n        const abi = this.fragments.map((f) => f.format(\"json\"));\n\n        // We need to re-bundle the JSON fragments a bit\n        return JSON.stringify(abi.map((j) => JSON.parse(j)));\n    }\n\n    /**\n     *  The ABI coder that will be used to encode and decode binary\n     *  data.\n     */\n    getAbiCoder(): AbiCoder {\n        return AbiCoder.defaultAbiCoder();\n    }\n\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    #getFunction(key: string, values: null | Array<any | Typed>, forceUnique: boolean): null | FunctionFragment {\n\n        // Selector\n        if (isHexString(key)) {\n            const selector = key.toLowerCase();\n            for (const fragment of this.#functions.values()) {\n                if (selector === fragment.selector) { return fragment; }\n            }\n            return null;\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching: Array<FunctionFragment> = [ ];\n            for (const [ name, fragment ] of this.#functions) {\n                if (name.split(\"(\"/* fix:) */)[0] === key) { matching.push(fragment); }\n            }\n\n            if (values) {\n                const lastValue = (values.length > 0) ? values[values.length - 1]: null;\n\n                let valueLength = values.length;\n                let allowOptions = true;\n                if (Typed.isTyped(lastValue) && lastValue.type === \"overrides\") {\n                    allowOptions = false;\n                    valueLength--;\n                }\n\n                // Remove all matches that don't have a compatible length. The args\n                // may contain an overrides, so the match may have n or n - 1 parameters\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    const inputs = matching[i].inputs.length;\n                    if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {\n                        matching.splice(i, 1);\n                    }\n                }\n\n                // Remove all matches that don't match the Typed signature\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    const inputs = matching[i].inputs;\n                    for (let j = 0; j < values.length; j++) {\n                        // Not a typed value\n                        if (!Typed.isTyped(values[j])) { continue; }\n\n                        // We are past the inputs\n                        if (j >= inputs.length) {\n                            if (values[j].type === \"overrides\") { continue; }\n                            matching.splice(i, 1);\n                            break;\n                        }\n\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n\n            // We found a single matching signature with an overrides, but the\n            // last value is something that cannot possibly be an options\n            if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {\n                const lastArg = values[values.length - 1];\n                if (lastArg == null || Array.isArray(lastArg) || typeof(lastArg) !== \"object\") {\n                    matching.splice(0, 1);\n                }\n            }\n\n            if (matching.length === 0) { return null; }\n\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\n                assertArgument(false, `ambiguous function description (i.e. matches ${ matchStr })`, \"key\", key);\n            }\n\n            return matching[0];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.#functions.get(FunctionFragment.from(key).format());\n        if (result) { return result; }\n\n        return null;\n    }\n\n    /**\n     *  Get the function name for %%key%%, which may be a function selector,\n     *  function name or function signature that belongs to the ABI.\n     */\n    getFunctionName(key: string): string {\n        const fragment = this.#getFunction(key, null, false);\n        assertArgument(fragment, \"no matching function\", \"key\", key);\n        return fragment.name;\n    }\n\n    /**\n     *  Returns true if %%key%% (a function selector, function name or\n     *  function signature) is present in the ABI.\n     *\n     *  In the case of a function name, the name may be ambiguous, so\n     *  accessing the [[FunctionFragment]] may require refinement.\n     */\n    hasFunction(key: string): boolean {\n        return !!this.#getFunction(key, null, false);\n    }\n\n    /**\n     *  Get the [[FunctionFragment]] for %%key%%, which may be a function\n     *  selector, function name or function signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple functions match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single function in\n     *  the ABI, this will throw.\n     */\n    getFunction(key: string, values?: Array<any | Typed>): null | FunctionFragment {\n        return this.#getFunction(key, values || null, true);\n    }\n\n    /**\n     *  Iterate over all functions, calling %%callback%%, sorted by their name.\n     */\n    forEachFunction(callback: (func: FunctionFragment, index: number) => void): void {\n        const names = Array.from(this.#functions.keys());\n        names.sort((a, b) => a.localeCompare(b));\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            callback(<FunctionFragment>(this.#functions.get(name)), i);\n        }\n    }\n\n\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    #getEvent(key: string, values: null | Array<null | any | Typed>, forceUnique: boolean): null | EventFragment {\n\n        // EventTopic\n        if (isHexString(key)) {\n            const eventTopic = key.toLowerCase();\n            for (const fragment of this.#events.values()) {\n                if (eventTopic === fragment.topicHash) { return fragment; }\n            }\n            return null;\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [ ];\n            for (const [ name, fragment ] of this.#events) {\n                if (name.split(\"(\"/* fix:) */)[0] === key) { matching.push(fragment); }\n            }\n\n            if (values) {\n                // Remove all matches that don't have a compatible length.\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    if (matching[i].inputs.length < values.length) {\n                        matching.splice(i, 1);\n                    }\n                }\n\n                // Remove all matches that don't match the Typed signature\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    const inputs = matching[i].inputs;\n                    for (let j = 0; j < values.length; j++) {\n                        // Not a typed value\n                        if (!Typed.isTyped(values[j])) { continue; }\n\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n\n            if (matching.length === 0) { return null; }\n\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\n                assertArgument(false, `ambiguous event description (i.e. matches ${ matchStr })`, \"key\", key);\n            }\n\n            return matching[0];\n        }\n\n        // Normalize the signature and lookup the function\n        const result = this.#events.get(EventFragment.from(key).format());\n        if (result) { return result; }\n\n        return null;\n    }\n\n    /**\n     *  Get the event name for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     */\n    getEventName(key: string): string {\n        const fragment = this.#getEvent(key, null, false);\n        assertArgument(fragment, \"no matching event\", \"key\", key);\n\n        return fragment.name;\n    }\n\n    /**\n     *  Returns true if %%key%% (an event topic hash, event name or\n     *  event signature) is present in the ABI.\n     *\n     *  In the case of an event name, the name may be ambiguous, so\n     *  accessing the [[EventFragment]] may require refinement.\n     */\n    hasEvent(key: string): boolean {\n        return !!this.#getEvent(key, null, false);\n    }\n\n    /**\n     *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple events match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single event in\n     *  the ABI, this will throw.\n     */\n    getEvent(key: string, values?: Array<any | Typed>): null | EventFragment {\n        return this.#getEvent(key, values || null, true)\n    }\n\n    /**\n     *  Iterate over all events, calling %%callback%%, sorted by their name.\n     */\n    forEachEvent(callback: (func: EventFragment, index: number) => void): void {\n        const names = Array.from(this.#events.keys());\n        names.sort((a, b) => a.localeCompare(b));\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            callback(<EventFragment>(this.#events.get(name)), i);\n        }\n    }\n\n    /**\n     *  Get the [[ErrorFragment]] for %%key%%, which may be an error\n     *  selector, error name or error signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple errors match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single error in\n     *  the ABI, this will throw.\n     */\n    getError(key: string, values?: Array<any | Typed>): null | ErrorFragment {\n        if (isHexString(key)) {\n            const selector = key.toLowerCase();\n\n            if (BuiltinErrors[selector]) {\n                return ErrorFragment.from(BuiltinErrors[selector].signature);\n            }\n\n            for (const fragment of this.#errors.values()) {\n                if (selector === fragment.selector) { return fragment; }\n            }\n\n            return null;\n        }\n\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [ ];\n            for (const [ name, fragment ] of this.#errors) {\n                if (name.split(\"(\"/* fix:) */)[0] === key) { matching.push(fragment); }\n            }\n\n            if (matching.length === 0) {\n                if (key === \"Error\") { return ErrorFragment.from(\"error Error(string)\"); }\n                if (key === \"Panic\") { return ErrorFragment.from(\"error Panic(uint256)\"); }\n                return null;\n            } else if (matching.length > 1) {\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\n                assertArgument(false, `ambiguous error description (i.e. ${ matchStr })`, \"name\", key);\n            }\n\n            return matching[0];\n        }\n\n        // Normalize the signature and lookup the function\n        key = ErrorFragment.from(key).format()\n        if (key === \"Error(string)\") { return ErrorFragment.from(\"error Error(string)\"); }\n        if (key === \"Panic(uint256)\") { return ErrorFragment.from(\"error Panic(uint256)\"); }\n\n        const result = this.#errors.get(key);\n        if (result) { return result; }\n\n        return null;\n    }\n\n    /**\n     *  Iterate over all errors, calling %%callback%%, sorted by their name.\n     */\n    forEachError(callback: (func: ErrorFragment, index: number) => void): void {\n        const names = Array.from(this.#errors.keys());\n        names.sort((a, b) => a.localeCompare(b));\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            callback(<ErrorFragment>(this.#errors.get(name)), i);\n        }\n    }\n\n    // Get the 4-byte selector used by Solidity to identify a function\n        /*\n    getSelector(fragment: ErrorFragment | FunctionFragment): string {\n        if (typeof(fragment) === \"string\") {\n            const matches: Array<Fragment> = [ ];\n\n            try { matches.push(this.getFunction(fragment)); } catch (error) { }\n            try { matches.push(this.getError(<string>fragment)); } catch (_) { }\n\n            if (matches.length === 0) {\n                logger.throwArgumentError(\"unknown fragment\", \"key\", fragment);\n            } else if (matches.length > 1) {\n                logger.throwArgumentError(\"ambiguous fragment matches function and error\", \"key\", fragment);\n            }\n\n            fragment = matches[0];\n        }\n\n        return dataSlice(id(fragment.format()), 0, 4);\n    }\n        */\n\n    // Get the 32-byte topic hash used by Solidity to identify an event\n    /*\n    getEventTopic(fragment: EventFragment): string {\n        //if (typeof(fragment) === \"string\") { fragment = this.getEvent(eventFragment); }\n        return id(fragment.format());\n    }\n    */\n\n\n    _decodeParams(params: ReadonlyArray<ParamType>, data: BytesLike): Result {\n        return this.#abiCoder.decode(params, data)\n    }\n\n    _encodeParams(params: ReadonlyArray<ParamType>, values: ReadonlyArray<any>): string {\n        return this.#abiCoder.encode(params, values)\n    }\n\n    /**\n     *  Encodes a ``tx.data`` object for deploying the Contract with\n     *  the %%values%% as the constructor arguments.\n     */\n    encodeDeploy(values?: ReadonlyArray<any>): string {\n        return this._encodeParams(this.deploy.inputs, values || [ ]);\n    }\n\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified error (see [[getError]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */\n    decodeErrorResult(fragment: ErrorFragment | string, data: BytesLike): Result {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getError(fragment);\n            assertArgument(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n\n        assertArgument(dataSlice(data, 0, 4) === fragment.selector,\n            `data signature does not match error ${ fragment.name }.`, \"data\", data);\n\n        return this._decodeParams(fragment.inputs, dataSlice(data, 4));\n    }\n\n    /**\n     *  Encodes the transaction revert data for a call result that\n     *  reverted from the the Contract with the sepcified %%error%%\n     *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */\n    encodeErrorResult(fragment: ErrorFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getError(fragment);\n            assertArgument(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n\n        return concat([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [ ])\n        ]);\n    }\n\n    /**\n     *  Decodes the %%data%% from a transaction ``tx.data`` for\n     *  the function specified (see [[getFunction]] for valid values\n     *  for %%fragment%%).\n     *\n     *  Most developers should prefer the [[parseTransaction]] method\n     *  instead, which will automatically detect the fragment.\n     */\n    decodeFunctionData(fragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            assertArgument(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n\n        assertArgument(dataSlice(data, 0, 4) === fragment.selector,\n            `data signature does not match function ${ fragment.name }.`, \"data\", data);\n\n        return this._decodeParams(fragment.inputs, dataSlice(data, 4));\n    }\n\n    /**\n     *  Encodes the ``tx.data`` for a transaction that calls the function\n     *  specified (see [[getFunction]] for valid values for %%fragment%%) with\n     *  the %%values%%.\n     */\n    encodeFunctionData(fragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            assertArgument(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n\n        return concat([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [ ])\n        ]);\n    }\n\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */\n    decodeFunctionResult(fragment: FunctionFragment | string, data: BytesLike): Result {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            assertArgument(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n\n        let message = \"invalid length for result data\";\n\n        const bytes = getBytesCopy(data);\n        if ((bytes.length % 32) === 0) {\n            try {\n                return this.#abiCoder.decode(fragment.outputs, bytes);\n            } catch (error) {\n                message = \"could not decode result data\";\n            }\n        }\n\n        // Call returned data with no error, but the data is junk\n        assert(false, message, \"BAD_DATA\", {\n            value: hexlify(bytes),\n            info: { method: fragment.name, signature: fragment.format() }\n        });\n    }\n\n    makeError(_data: BytesLike, tx: CallExceptionTransaction): CallExceptionError {\n        const data = getBytes(_data, \"data\");\n\n        const error = AbiCoder.getBuiltinCallException(\"call\", tx, data);\n\n        // Not a built-in error; try finding a custom error\n        const customPrefix = \"execution reverted (unknown custom error)\";\n        if (error.message.startsWith(customPrefix)) {\n            const selector = hexlify(data.slice(0, 4));\n\n            const ef = this.getError(selector);\n            if (ef) {\n                try {\n                    const args = this.#abiCoder.decode(ef.inputs, data.slice(4));\n                    error.revert = {\n                        name: ef.name, signature: ef.format(), args\n                    };\n                    error.reason = error.revert.signature;\n                    error.message = `execution reverted: ${ error.reason }`\n                 } catch (e) {\n                    error.message = `execution reverted (coult not decode custom error)`\n                }\n            }\n        }\n\n        // Add the invocation, if available\n        const parsed = this.parseTransaction(tx);\n        if (parsed) {\n            error.invocation = {\n                method: parsed.name,\n                signature: parsed.signature,\n                args: parsed.args\n            };\n        }\n\n        return error;\n    }\n\n    /**\n     *  Encodes the result data (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values\n     *  for %%fragment%%) with %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */\n    encodeFunctionResult(fragment: FunctionFragment | string, values?: ReadonlyArray<any>): string {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            assertArgument(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return hexlify(this.#abiCoder.encode(fragment.outputs, values || [ ]));\n    }\n/*\n    spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {\n        const promises: Array<Promise<>> = [ ];\n        const process = function(type: ParamType, value: any): any {\n            if (type.baseType === \"array\") {\n                return descend(type.child\n            }\n            if (type. === \"address\") {\n            }\n        };\n\n        const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {\n            if (inputs.length !== values.length) { throw new Error(\"length mismatch\"); }\n            \n        };\n\n        const result: Array<any> = [ ];\n        values.forEach((value, index) => {\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n    }\n*/\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(fragment: EventFragment | string, values: ReadonlyArray<any>): Array<null | string | Array<string>> {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getEvent(fragment);\n            assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n\n        assert(values.length <= fragment.inputs.length, `too many arguments for ${ fragment.format() }`,\n            \"UNEXPECTED_ARGUMENT\", { count: values.length, expectedCount: fragment.inputs.length })\n\n        const topics: Array<null | string | Array<string>> = [];\n        if (!fragment.anonymous) { topics.push(fragment.topicHash); }\n\n        // @TODO: Use the coders for this; to properly support tuples, etc.\n        const encodeTopic = (param: ParamType, value: any): string => {\n            if (param.type === \"string\") {\n                 return id(value);\n            } else if (param.type === \"bytes\") {\n                 return keccak256(hexlify(value));\n            }\n\n            if (param.type === \"bool\" && typeof(value) === \"boolean\") {\n                value = (value ? \"0x01\": \"0x00\");\n            }\n\n            if (param.type.match(/^u?int/)) {\n                value = toBeHex(value);\n            }\n\n            // Check addresses are valid\n            if (param.type === \"address\") { this.#abiCoder.encode( [ \"address\" ], [ value ]); }\n            return zeroPadValue(hexlify(value), 32);\n            //@TOOD should probably be return toHex(value, 32)\n        };\n\n        values.forEach((value, index) => {\n\n            const param = (<EventFragment>fragment).inputs[index];\n\n            if (!param.indexed) {\n                assertArgument(value == null,\n                    \"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\n                return;\n            }\n\n            if (value == null) {\n                topics.push(null);\n            } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                assertArgument(false, \"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            } else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            } else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n\n        // Trim off trailing nulls\n        while (topics.length && topics[topics.length - 1] === null) {\n            topics.pop();\n        }\n\n        return topics;\n    }\n\n    encodeEventLog(fragment: EventFragment | string, values: ReadonlyArray<any>): { data: string, topics: Array<string> } {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getEvent(fragment);\n            assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n\n        const topics: Array<string> = [ ];\n\n        const dataTypes: Array<ParamType> = [ ];\n        const dataValues: Array<string> = [ ];\n\n        if (!fragment.anonymous) {\n            topics.push(fragment.topicHash);\n        }\n\n        assertArgument(values.length === fragment.inputs.length,\n            \"event arguments/values mismatch\", \"values\", values);\n\n        fragment.inputs.forEach((param, index) => {\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push(id(value))\n                } else if (param.type === \"bytes\") {\n                    topics.push(keccak256(value))\n                } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                } else {\n                    topics.push(this.#abiCoder.encode([ param.type] , [ value ]));\n                }\n            } else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n\n        return {\n            data: this.#abiCoder.encode(dataTypes , dataValues),\n            topics: topics\n        };\n    }\n\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(fragment: EventFragment | string, data: BytesLike, topics?: ReadonlyArray<string>): Result {\n        if (typeof(fragment) === \"string\") {\n            const f = this.getEvent(fragment);\n            assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n\n        if (topics != null && !fragment.anonymous) {\n            const eventTopic = fragment.topicHash;\n            assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic,\n                \"fragment/topic mismatch\", \"topics[0]\", topics[0]);\n            topics = topics.slice(1);\n        }\n\n        const indexed: Array<ParamType> = [];\n        const nonIndexed: Array<ParamType> = [];\n        const dynamic: Array<boolean> = [];\n\n        fragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(ParamType.from({ type: \"bytes32\", name: param.name }));\n                    dynamic.push(true);\n                } else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            } else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n\n        const resultIndexed = (topics != null) ? this.#abiCoder.decode(indexed, concat(topics)): null;\n        const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true);\n\n        //const result: (Array<any> & { [ key: string ]: any }) = [ ];\n        const values: Array<any> = [ ];\n        const keys: Array<null | string> = [ ];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        fragment.inputs.forEach((param, index) => {\n            let value = null;\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    value = new Indexed(null);\n\n                } else if (dynamic[index]) {\n                    value = new Indexed(resultIndexed[indexedIndex++]);\n\n                } else {\n                    try {\n                        value = resultIndexed[indexedIndex++];\n                    } catch (error) {\n                        value = error;\n                    }\n                }\n            } else {\n                try {\n                    value = resultNonIndexed[nonIndexedIndex++];\n                } catch (error) {\n                    value = error;\n                }\n            }\n\n            values.push(value);\n            keys.push(param.name || null);\n        });\n\n        return Result.fromItems(values, keys);\n    }\n\n    /**\n     *  Parses a transaction, finding the matching function and extracts\n     *  the parameter values along with other useful function details.\n     *\n     *  If the matching function cannot be found, return null.\n     */\n    parseTransaction(tx: { data: string, value?: BigNumberish }): null | TransactionDescription {\n        const data = getBytes(tx.data, \"tx.data\");\n        const value = getBigInt((tx.value != null) ? tx.value: 0, \"tx.value\");\n\n        const fragment = this.getFunction(hexlify(data.slice(0, 4)));\n\n        if (!fragment) { return null; }\n\n        const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));\n        return new TransactionDescription(fragment, fragment.selector, args, value);\n    }\n\n    parseCallResult(data: BytesLike): Result {\n        throw new Error(\"@TODO\");\n    }\n\n    /**\n     *  Parses a receipt log, finding the matching event and extracts\n     *  the parameter values along with other useful event details.\n     *\n     *  If the matching event cannot be found, returns null.\n     */\n    parseLog(log: { topics: Array<string>, data: string}): null | LogDescription {\n        const fragment = this.getEvent(log.topics[0]);\n\n        if (!fragment || fragment.anonymous) { return null; }\n\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n\n\n       return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));\n    }\n\n    /**\n     *  Parses a revert data, finding the matching error and extracts\n     *  the parameter values along with other useful error details.\n     *\n     *  If the matching event cannot be found, returns null.\n     */\n    parseError(data: BytesLike): null | ErrorDescription {\n        const hexData = hexlify(data);\n\n        const fragment = this.getError(dataSlice(hexData, 0, 4));\n\n        if (!fragment) { return null; }\n\n        const args = this.#abiCoder.decode(fragment.inputs, dataSlice(hexData, 4));\n        return new ErrorDescription(fragment, fragment.selector, args);\n    }\n\n    /**\n     *  Creates a new [[Interface]] from the ABI %%value%%.\n     *\n     *  The %%value%% may be provided as an existing [[Interface]] object,\n     *  a JSON-encoded ABI or any Human-Readable ABI format.\n     */\n    static from(value: InterfaceAbi | Interface): Interface {\n        // Already an Interface, which is immutable\n        if (value instanceof Interface) { return value; }\n\n        // JSON\n        if (typeof(value) === \"string\") { return new Interface(JSON.parse(value)); }\n\n        // Maybe an interface from an older version, or from a symlinked copy\n        if (typeof((<any>value).format) === \"function\") {\n            return new Interface((<any>value).format(\"json\"));\n        }\n\n        // Array of fragments\n        return new Interface(value);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}