{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _get from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _assertThisInitialized from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _regeneratorRuntime from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classPrivateFieldInitSpec from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldSet from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\nimport _classPrivateFieldGet from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\n/**\n *  Generic long-lived socket provider.\n *\n *  Sub-classing notes\n *  - a sub-class MUST call the `_start()` method once connected\n *  - a sub-class MUST override the `_write(string)` method\n *  - a sub-class MUST call `_processMessage(string)` for each message\n *\n *  @_subsection: api/providers/abstract-provider\n */\nimport { UnmanagedSubscriber } from \"./abstract-provider.js\";\nimport { assert, assertArgument } from \"../utils/index.js\";\nimport { JsonRpcApiProvider } from \"./provider-jsonrpc.js\";\nvar _provider = /*#__PURE__*/new WeakMap();\nvar _filter = /*#__PURE__*/new WeakMap();\nvar _filterId = /*#__PURE__*/new WeakMap();\nvar _paused = /*#__PURE__*/new WeakMap();\nvar _emitPromise = /*#__PURE__*/new WeakMap();\nexport var SocketSubscriber = /*#__PURE__*/function () {\n  function SocketSubscriber(provider, filter) {\n    _classCallCheck(this, SocketSubscriber);\n    _classPrivateFieldInitSpec(this, _provider, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _filter, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _filterId, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _paused, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _emitPromise, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _provider, provider);\n    _classPrivateFieldSet(this, _filter, JSON.stringify(filter));\n    _classPrivateFieldSet(this, _filterId, null);\n    _classPrivateFieldSet(this, _paused, null);\n    _classPrivateFieldSet(this, _emitPromise, null);\n  }\n  _createClass(SocketSubscriber, [{\n    key: \"filter\",\n    get: function get() {\n      return JSON.parse(_classPrivateFieldGet(this, _filter));\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      var _this = this;\n      _classPrivateFieldSet(this, _filterId, _classPrivateFieldGet(this, _provider).send(\"eth_subscribe\", this.filter).then(function (filterId) {\n        ;\n        _classPrivateFieldGet(_this, _provider)._register(filterId, _this);\n        return filterId;\n      }));\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var _this2 = this;\n      _classPrivateFieldGet(this, _filterId).then(function (filterId) {\n        _classPrivateFieldGet(_this2, _provider).send(\"eth_unsubscribe\", [filterId]);\n      });\n      _classPrivateFieldSet(this, _filterId, null);\n    }\n    // @TODO: pause should trap the current blockNumber, unsub, and on resume use getLogs\n    //        and resume\n  }, {\n    key: \"pause\",\n    value: function pause(dropWhilePaused) {\n      assert(dropWhilePaused, \"preserve logs while paused not supported by SocketSubscriber yet\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"pause(false)\"\n      });\n      _classPrivateFieldSet(this, _paused, !!dropWhilePaused);\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      _classPrivateFieldSet(this, _paused, null);\n    }\n  }, {\n    key: \"_handleMessage\",\n    value: function _handleMessage(message) {\n      var _this3 = this;\n      if (_classPrivateFieldGet(this, _filterId) == null) {\n        return;\n      }\n      if (_classPrivateFieldGet(this, _paused) === null) {\n        var emitPromise = _classPrivateFieldGet(this, _emitPromise);\n        if (emitPromise == null) {\n          emitPromise = this._emit(_classPrivateFieldGet(this, _provider), message);\n        } else {\n          emitPromise = emitPromise.then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n            return _regeneratorRuntime().wrap(function _callee$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return _this3._emit(_classPrivateFieldGet(_this3, _provider), message);\n                case 2:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _callee);\n          })));\n        }\n        _classPrivateFieldSet(this, _emitPromise, emitPromise.then(function () {\n          if (_classPrivateFieldGet(_this3, _emitPromise) === emitPromise) {\n            _classPrivateFieldSet(_this3, _emitPromise, null);\n          }\n        }));\n      }\n    }\n  }, {\n    key: \"_emit\",\n    value: function () {\n      var _emit2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(provider, message) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              throw new Error(\"sub-classes must implemente this; _emit\");\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n      function _emit(_x, _x2) {\n        return _emit2.apply(this, arguments);\n      }\n      return _emit;\n    }()\n  }]);\n  return SocketSubscriber;\n}();\nexport var SocketBlockSubscriber = /*#__PURE__*/function (_SocketSubscriber) {\n  _inherits(SocketBlockSubscriber, _SocketSubscriber);\n  var _super = _createSuper(SocketBlockSubscriber);\n  function SocketBlockSubscriber(provider) {\n    _classCallCheck(this, SocketBlockSubscriber);\n    return _super.call(this, provider, [\"newHeads\"]);\n  }\n  _createClass(SocketBlockSubscriber, [{\n    key: \"_emit\",\n    value: function () {\n      var _emit3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(provider, message) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              provider.emit(\"block\", parseInt(message.number));\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3);\n      }));\n      function _emit(_x3, _x4) {\n        return _emit3.apply(this, arguments);\n      }\n      return _emit;\n    }()\n  }]);\n  return SocketBlockSubscriber;\n}(SocketSubscriber);\nexport var SocketPendingSubscriber = /*#__PURE__*/function (_SocketSubscriber2) {\n  _inherits(SocketPendingSubscriber, _SocketSubscriber2);\n  var _super2 = _createSuper(SocketPendingSubscriber);\n  function SocketPendingSubscriber(provider) {\n    _classCallCheck(this, SocketPendingSubscriber);\n    return _super2.call(this, provider, [\"newPendingTransactions\"]);\n  }\n  _createClass(SocketPendingSubscriber, [{\n    key: \"_emit\",\n    value: function () {\n      var _emit4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(provider, message) {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              provider.emit(\"pending\", message);\n            case 1:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4);\n      }));\n      function _emit(_x5, _x6) {\n        return _emit4.apply(this, arguments);\n      }\n      return _emit;\n    }()\n  }]);\n  return SocketPendingSubscriber;\n}(SocketSubscriber);\nvar _logFilter = /*#__PURE__*/new WeakMap();\nexport var SocketEventSubscriber = /*#__PURE__*/function (_SocketSubscriber3) {\n  _inherits(SocketEventSubscriber, _SocketSubscriber3);\n  var _super3 = _createSuper(SocketEventSubscriber);\n  function SocketEventSubscriber(provider, filter) {\n    var _this4;\n    _classCallCheck(this, SocketEventSubscriber);\n    _this4 = _super3.call(this, provider, [\"logs\", filter]);\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this4), _logFilter, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(_assertThisInitialized(_this4), _logFilter, JSON.stringify(filter));\n    return _this4;\n  }\n  _createClass(SocketEventSubscriber, [{\n    key: \"logFilter\",\n    get: function get() {\n      return JSON.parse(_classPrivateFieldGet(this, _logFilter));\n    }\n  }, {\n    key: \"_emit\",\n    value: function () {\n      var _emit5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(provider, message) {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              provider.emit(this.logFilter, provider._wrapLog(message, provider._network));\n            case 1:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function _emit(_x7, _x8) {\n        return _emit5.apply(this, arguments);\n      }\n      return _emit;\n    }()\n  }]);\n  return SocketEventSubscriber;\n}(SocketSubscriber);\n/**\n *  SocketProvider...\n *\n */\nvar _callbacks = /*#__PURE__*/new WeakMap();\nvar _subs = /*#__PURE__*/new WeakMap();\nvar _pending = /*#__PURE__*/new WeakMap();\nexport var SocketProvider = /*#__PURE__*/function (_JsonRpcApiProvider) {\n  _inherits(SocketProvider, _JsonRpcApiProvider);\n  var _super4 = _createSuper(SocketProvider);\n  function SocketProvider(network) {\n    var _this5;\n    _classCallCheck(this, SocketProvider);\n    _this5 = _super4.call(this, network, {\n      batchMaxCount: 1\n    });\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this5), _callbacks, {\n      writable: true,\n      value: void 0\n    });\n    // Maps each filterId to its subscriber\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this5), _subs, {\n      writable: true,\n      value: void 0\n    });\n    // If any events come in before a subscriber has finished\n    // registering, queue them\n    _classPrivateFieldInitSpec(_assertThisInitialized(_this5), _pending, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(_assertThisInitialized(_this5), _callbacks, new Map());\n    _classPrivateFieldSet(_assertThisInitialized(_this5), _subs, new Map());\n    _classPrivateFieldSet(_assertThisInitialized(_this5), _pending, new Map());\n    return _this5;\n  }\n  // This value is only valid after _start has been called\n  /*\n  get _network(): Network {\n      if (this.#network == null) {\n          throw new Error(\"this shouldn't happen\");\n      }\n      return this.#network.clone();\n  }\n  */\n  _createClass(SocketProvider, [{\n    key: \"_getSubscriber\",\n    value: function _getSubscriber(sub) {\n      switch (sub.type) {\n        case \"close\":\n          return new UnmanagedSubscriber(\"close\");\n        case \"block\":\n          return new SocketBlockSubscriber(this);\n        case \"pending\":\n          return new SocketPendingSubscriber(this);\n        case \"event\":\n          return new SocketEventSubscriber(this, sub.filter);\n        case \"orphan\":\n          // Handled auto-matically within AbstractProvider\n          // when the log.removed = true\n          if (sub.filter.orphan === \"drop-log\") {\n            return new UnmanagedSubscriber(\"drop-log\");\n          }\n      }\n      return _get(_getPrototypeOf(SocketProvider.prototype), \"_getSubscriber\", this).call(this, sub);\n    }\n  }, {\n    key: \"_register\",\n    value: function _register(filterId, subscriber) {\n      _classPrivateFieldGet(this, _subs).set(filterId, subscriber);\n      var pending = _classPrivateFieldGet(this, _pending).get(filterId);\n      if (pending) {\n        var _iterator = _createForOfIteratorHelper(pending),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var message = _step.value;\n            subscriber._handleMessage(message);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        _classPrivateFieldGet(this, _pending).delete(filterId);\n      }\n    }\n  }, {\n    key: \"_send\",\n    value: function () {\n      var _send2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(payload) {\n        var _this6 = this;\n        var promise;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              // WebSocket provider doesn't accept batches\n              assertArgument(!Array.isArray(payload), \"WebSocket does not support batch send\", \"payload\", payload);\n              // @TODO: stringify payloads here and store to prevent mutations\n              // Prepare a promise to respond to\n              promise = new Promise(function (resolve, reject) {\n                _classPrivateFieldGet(_this6, _callbacks).set(payload.id, {\n                  payload: payload,\n                  resolve: resolve,\n                  reject: reject\n                });\n              }); // Wait until the socket is connected before writing to it\n              _context6.next = 4;\n              return this._waitUntilReady();\n            case 4:\n              _context6.next = 6;\n              return this._write(JSON.stringify(payload));\n            case 6:\n              _context6.next = 8;\n              return promise;\n            case 8:\n              _context6.t0 = _context6.sent;\n              return _context6.abrupt(\"return\", [_context6.t0]);\n            case 10:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function _send(_x9) {\n        return _send2.apply(this, arguments);\n      }\n      return _send;\n    }() // Sub-classes must call this once they are connected\n    /*\n    async _start(): Promise<void> {\n        if (this.#ready) { return; }\n         for (const { payload } of this.#callbacks.values()) {\n            await this._write(JSON.stringify(payload));\n        }\n         this.#ready = (async function() {\n            await super._start();\n        })();\n    }\n    */\n    // Sub-classes must call this for each message\n  }, {\n    key: \"_processMessage\",\n    value: function () {\n      var _processMessage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(message) {\n        var result, callback, filterId, subscriber, pending;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              result = JSON.parse(message);\n              if (!(\"id\" in result)) {\n                _context7.next = 10;\n                break;\n              }\n              callback = _classPrivateFieldGet(this, _callbacks).get(result.id);\n              if (!(callback == null)) {\n                _context7.next = 6;\n                break;\n              }\n              console.log(\"Weird... Response for not a thing we sent\");\n              return _context7.abrupt(\"return\");\n            case 6:\n              _classPrivateFieldGet(this, _callbacks).delete(result.id);\n              callback.resolve(result);\n              /*\n                          if (\"error\" in result) {\n                              const { message, code, data } = result.error;\n                              const error = makeError(message || \"unkonwn error\", \"SERVER_ERROR\", {\n                                  request: `ws:${ JSON.stringify(callback.payload) }`,\n                                  info: { code, data }\n                              });\n                              callback.reject(error);\n                          } else {\n                              callback.resolve(result.result);\n                          }\n              */\n              _context7.next = 11;\n              break;\n            case 10:\n              if (result.method === \"eth_subscription\") {\n                filterId = result.params.subscription;\n                subscriber = _classPrivateFieldGet(this, _subs).get(filterId);\n                if (subscriber) {\n                  subscriber._handleMessage(result.params.result);\n                } else {\n                  pending = _classPrivateFieldGet(this, _pending).get(filterId);\n                  if (pending == null) {\n                    pending = [];\n                    _classPrivateFieldGet(this, _pending).set(filterId, pending);\n                  }\n                  pending.push(result.params.result);\n                }\n              }\n            case 11:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function _processMessage(_x10) {\n        return _processMessage2.apply(this, arguments);\n      }\n      return _processMessage;\n    }()\n  }, {\n    key: \"_write\",\n    value: function () {\n      var _write2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(message) {\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              throw new Error(\"sub-classes must override this\");\n            case 1:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8);\n      }));\n      function _write(_x11) {\n        return _write2.apply(this, arguments);\n      }\n      return _write;\n    }()\n  }]);\n  return SocketProvider;\n}(JsonRpcApiProvider);","map":{"version":3,"names":["UnmanagedSubscriber","assert","assertArgument","JsonRpcApiProvider","_provider","WeakMap","_filter","_filterId","_paused","_emitPromise","SocketSubscriber","provider","filter","_classCallCheck","_classPrivateFieldInitSpec","writable","value","_classPrivateFieldSet","JSON","stringify","_createClass","key","get","parse","_classPrivateFieldGet","start","_this","send","then","filterId","_register","stop","_this2","pause","dropWhilePaused","operation","resume","_handleMessage","message","_this3","emitPromise","_emit","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","_emit2","_callee2","_callee2$","_context2","Error","_x","_x2","apply","arguments","SocketBlockSubscriber","_SocketSubscriber","_inherits","_super","_createSuper","call","_emit3","_callee3","_callee3$","_context3","emit","parseInt","number","_x3","_x4","SocketPendingSubscriber","_SocketSubscriber2","_super2","_emit4","_callee4","_callee4$","_context4","_x5","_x6","_logFilter","SocketEventSubscriber","_SocketSubscriber3","_super3","_this4","_assertThisInitialized","_emit5","_callee5","_callee5$","_context5","logFilter","_wrapLog","_network","_x7","_x8","_callbacks","_subs","_pending","SocketProvider","_JsonRpcApiProvider","_super4","network","_this5","batchMaxCount","Map","_getSubscriber","sub","type","orphan","_get","_getPrototypeOf","prototype","subscriber","set","pending","_iterator","_createForOfIteratorHelper","_step","s","n","done","err","e","f","delete","_send2","_callee6","payload","_this6","promise","_callee6$","_context6","Array","isArray","Promise","resolve","reject","id","_waitUntilReady","_write","t0","sent","abrupt","_send","_x9","_processMessage2","_callee7","result","callback","_callee7$","_context7","console","log","method","params","subscription","push","_processMessage","_x10","_write2","_callee8","_callee8$","_context8","_x11"],"sources":["C:\\Users\\Oguzhan\\Desktop\\BlockGuard\\mwallet\\node_modules\\ethers\\src.ts\\providers\\provider-socket.ts"],"sourcesContent":["/**\n *  Generic long-lived socket provider.\n *\n *  Sub-classing notes\n *  - a sub-class MUST call the `_start()` method once connected\n *  - a sub-class MUST override the `_write(string)` method\n *  - a sub-class MUST call `_processMessage(string)` for each message\n *\n *  @_subsection: api/providers/abstract-provider\n */\n\nimport { UnmanagedSubscriber } from \"./abstract-provider.js\";\nimport { assert, assertArgument } from \"../utils/index.js\";\nimport { JsonRpcApiProvider } from \"./provider-jsonrpc.js\";\n\nimport type { Subscriber, Subscription } from \"./abstract-provider.js\";\nimport type { EventFilter } from \"./provider.js\";\nimport type { JsonRpcError, JsonRpcPayload, JsonRpcResult } from \"./provider-jsonrpc.js\";\nimport type { Networkish } from \"./network.js\";\n\n\ntype JsonRpcSubscription = {\n    method: string,\n    params: {\n        result: any,\n        subscription: string\n    }\n};\n\nexport class SocketSubscriber implements Subscriber {\n    #provider: SocketProvider;\n\n    #filter: string;\n    get filter(): Array<any> { return JSON.parse(this.#filter); }\n\n    #filterId: null | Promise<string |number>;\n    #paused: null | boolean;\n\n    #emitPromise: null | Promise<void>;\n\n    constructor(provider: SocketProvider, filter: Array<any>) {\n        this.#provider = provider;\n        this.#filter = JSON.stringify(filter);\n        this.#filterId = null;\n        this.#paused = null;\n        this.#emitPromise = null;\n    }\n\n    start(): void {\n        this.#filterId = this.#provider.send(\"eth_subscribe\", this.filter).then((filterId) => {;\n            this.#provider._register(filterId, this);\n            return filterId;\n        });\n    }\n\n    stop(): void {\n        (<Promise<number>>(this.#filterId)).then((filterId) => {\n            this.#provider.send(\"eth_unsubscribe\", [ filterId ]);\n        });\n        this.#filterId = null;\n    }\n\n    // @TODO: pause should trap the current blockNumber, unsub, and on resume use getLogs\n    //        and resume\n    pause(dropWhilePaused?: boolean): void {\n        assert(dropWhilePaused, \"preserve logs while paused not supported by SocketSubscriber yet\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"pause(false)\" });\n        this.#paused = !!dropWhilePaused;\n    }\n\n    resume(): void {\n        this.#paused = null;\n    }\n\n    _handleMessage(message: any): void {\n        if (this.#filterId == null) { return; }\n        if (this.#paused === null) {\n            let emitPromise: null | Promise<void> = this.#emitPromise;\n            if (emitPromise == null) {\n                emitPromise = this._emit(this.#provider, message);\n            } else {\n                emitPromise = emitPromise.then(async () => {\n                    await this._emit(this.#provider, message);\n                });\n            }\n            this.#emitPromise = emitPromise.then(() => {\n                if (this.#emitPromise === emitPromise) {\n                    this.#emitPromise = null;\n                }\n            });\n        }\n    }\n\n    async _emit(provider: SocketProvider, message: any): Promise<void> {\n        throw new Error(\"sub-classes must implemente this; _emit\");\n    }\n}\n\nexport class SocketBlockSubscriber extends SocketSubscriber {\n    constructor(provider: SocketProvider) {\n        super(provider, [ \"newHeads\" ]);\n    }\n\n    async _emit(provider: SocketProvider, message: any): Promise<void> {\n        provider.emit(\"block\", parseInt(message.number));\n    }\n}\n\nexport class SocketPendingSubscriber extends SocketSubscriber {\n    constructor(provider: SocketProvider) {\n        super(provider, [ \"newPendingTransactions\" ]);\n    }\n\n    async _emit(provider: SocketProvider, message: any): Promise<void> {\n        provider.emit(\"pending\", message);\n    }\n}\n\nexport class SocketEventSubscriber extends SocketSubscriber {\n    #logFilter: string;\n    get logFilter(): EventFilter { return JSON.parse(this.#logFilter); }\n\n    constructor(provider: SocketProvider, filter: EventFilter) {\n        super(provider, [ \"logs\", filter ]);\n        this.#logFilter = JSON.stringify(filter);\n    }\n\n    async _emit(provider: SocketProvider, message: any): Promise<void> {\n        provider.emit(this.logFilter, provider._wrapLog(message, provider._network));\n    }\n}\n\n/**\n *  SocketProvider...\n *\n */\nexport class SocketProvider extends JsonRpcApiProvider {\n    #callbacks: Map<number, { payload: JsonRpcPayload, resolve: (r: any) => void, reject: (e: Error) => void }>;\n\n    // Maps each filterId to its subscriber\n    #subs: Map<number | string, SocketSubscriber>;\n\n    // If any events come in before a subscriber has finished\n    // registering, queue them\n    #pending: Map<number | string, Array<any>>;\n\n    constructor(network?: Networkish) {\n        super(network, { batchMaxCount: 1 });\n        this.#callbacks = new Map();\n        this.#subs = new Map();\n        this.#pending = new Map();\n    }\n\n    // This value is only valid after _start has been called\n    /*\n    get _network(): Network {\n        if (this.#network == null) {\n            throw new Error(\"this shouldn't happen\");\n        }\n        return this.#network.clone();\n    }\n    */\n\n    _getSubscriber(sub: Subscription): Subscriber {\n        switch (sub.type) {\n            case \"close\":\n                return new UnmanagedSubscriber(\"close\");\n            case \"block\":\n                return new SocketBlockSubscriber(this);\n            case \"pending\":\n                return new SocketPendingSubscriber(this);\n            case \"event\":\n                return new SocketEventSubscriber(this, sub.filter);\n            case \"orphan\":\n                // Handled auto-matically within AbstractProvider\n                // when the log.removed = true\n                if (sub.filter.orphan === \"drop-log\") {\n                    return new UnmanagedSubscriber(\"drop-log\");\n                }\n        }\n        return super._getSubscriber(sub);\n    }\n\n    _register(filterId: number | string, subscriber: SocketSubscriber): void {\n        this.#subs.set(filterId, subscriber);\n        const pending = this.#pending.get(filterId);\n        if (pending) {\n            for (const message of pending) {\n                subscriber._handleMessage(message);\n            }\n            this.#pending.delete(filterId);\n        }\n    }\n\n    async _send(payload: JsonRpcPayload | Array<JsonRpcPayload>): Promise<Array<JsonRpcResult | JsonRpcError>> {\n        // WebSocket provider doesn't accept batches\n        assertArgument(!Array.isArray(payload), \"WebSocket does not support batch send\", \"payload\", payload);\n\n        // @TODO: stringify payloads here and store to prevent mutations\n\n        // Prepare a promise to respond to\n        const promise = new Promise((resolve, reject) => {\n            this.#callbacks.set(payload.id, { payload, resolve, reject });\n        });\n\n        // Wait until the socket is connected before writing to it\n        await this._waitUntilReady();\n\n        // Write the request to the socket\n        await this._write(JSON.stringify(payload));\n\n        return <Array<JsonRpcResult | JsonRpcError>>[ await promise ];\n    }\n\n    // Sub-classes must call this once they are connected\n    /*\n    async _start(): Promise<void> {\n        if (this.#ready) { return; }\n\n        for (const { payload } of this.#callbacks.values()) {\n            await this._write(JSON.stringify(payload));\n        }\n\n        this.#ready = (async function() {\n            await super._start();\n        })();\n    }\n    */\n\n    // Sub-classes must call this for each message\n    async _processMessage(message: string): Promise<void> {\n        const result = <JsonRpcResult | JsonRpcError | JsonRpcSubscription>(JSON.parse(message));\n\n        if (\"id\" in result) {\n            const callback = this.#callbacks.get(result.id);\n            if (callback == null) {\n                console.log(\"Weird... Response for not a thing we sent\");\n                return;\n            }\n            this.#callbacks.delete(result.id);\n\n            callback.resolve(result);\n\n/*\n            if (\"error\" in result) {\n                const { message, code, data } = result.error;\n                const error = makeError(message || \"unkonwn error\", \"SERVER_ERROR\", {\n                    request: `ws:${ JSON.stringify(callback.payload) }`,\n                    info: { code, data }\n                });\n                callback.reject(error);\n            } else {\n                callback.resolve(result.result);\n            }\n*/\n        } else if (result.method === \"eth_subscription\") {\n            const filterId = result.params.subscription;\n            const subscriber = this.#subs.get(filterId);\n            if (subscriber) {\n                subscriber._handleMessage(result.params.result);\n            } else {\n                let pending = this.#pending.get(filterId);\n                if (pending == null) {\n                    pending = [ ];\n                    this.#pending.set(filterId, pending);\n                }\n                pending.push(result.params.result);\n            }\n        }\n    }\n\n    async _write(message: string): Promise<void> {\n        throw new Error(\"sub-classes must override this\");\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}