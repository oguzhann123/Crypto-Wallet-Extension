{"ast":null,"code":"import _inherits from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _createForOfIteratorHelper from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classPrivateFieldInitSpec from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldGet from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet.js\";\nimport _classPrivateFieldSet from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet.js\";\nimport { Interface, Typed } from \"../abi/index.js\";\nimport { resolveAddress } from \"../address/index.js\";\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nimport { copyRequest, Log } from \"../providers/provider.js\";\nimport { defineProperties, isCallException, isHexString, resolveProperties, makeError, assert, assertArgument } from \"../utils/index.js\";\nimport { ContractEventPayload, ContractUnknownEventPayload, ContractTransactionResponse, EventLog } from \"./wrappers.js\";\nvar BN_0 = BigInt(0);\nfunction canCall(value) {\n  return value && typeof value.call === \"function\";\n}\nfunction canEstimate(value) {\n  return value && typeof value.estimateGas === \"function\";\n}\nfunction canResolve(value) {\n  return value && typeof value.resolveName === \"function\";\n}\nfunction canSend(value) {\n  return value && typeof value.sendTransaction === \"function\";\n}\nvar _filter = /*#__PURE__*/new WeakMap();\nvar PreparedTopicFilter = /*#__PURE__*/function () {\n  function PreparedTopicFilter(contract, fragment, args) {\n    _classCallCheck(this, PreparedTopicFilter);\n    _classPrivateFieldInitSpec(this, _filter, {\n      writable: true,\n      value: void 0\n    });\n    _defineProperty(this, \"fragment\", void 0);\n    defineProperties(this, {\n      fragment: fragment\n    });\n    if (fragment.inputs.length < args.length) {\n      throw new Error(\"too many arguments\");\n    }\n    // Recursively descend into args and resolve any addresses\n    var runner = getRunner(contract.runner, \"resolveName\");\n    var resolver = canResolve(runner) ? runner : null;\n    _classPrivateFieldSet(this, _filter, _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var resolvedArgs;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return Promise.all(fragment.inputs.map(function (param, index) {\n              var arg = args[index];\n              if (arg == null) {\n                return null;\n              }\n              return param.walkAsync(args[index], function (type, value) {\n                if (type === \"address\") {\n                  return resolveAddress(value, resolver);\n                }\n                return value;\n              });\n            }));\n          case 2:\n            resolvedArgs = _context.sent;\n            return _context.abrupt(\"return\", contract.interface.encodeFilterTopics(fragment, resolvedArgs));\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }))());\n  }\n  _createClass(PreparedTopicFilter, [{\n    key: \"getTopicFilter\",\n    value: function getTopicFilter() {\n      return _classPrivateFieldGet(this, _filter);\n    }\n  }]);\n  return PreparedTopicFilter;\n}(); // A = Arguments passed in as a tuple\n// R = The result type of the call (i.e. if only one return type,\n//     the qualified type, otherwise Result)\n// D = The type the default call will return (i.e. R for view/pure,\n//     TransactionResponse otherwise)\n//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {\nfunction getRunner(value, feature) {\n  if (value == null) {\n    return null;\n  }\n  if (typeof value[feature] === \"function\") {\n    return value;\n  }\n  if (value.provider && typeof value.provider[feature] === \"function\") {\n    return value.provider;\n  }\n  return null;\n}\nfunction getProvider(value) {\n  if (value == null) {\n    return null;\n  }\n  return value.provider || null;\n}\n/**\n *  @_ignore:\n */\nexport function copyOverrides(_x, _x2) {\n  return _copyOverrides.apply(this, arguments);\n}\n/**\n *  @_ignore:\n */\nfunction _copyOverrides() {\n  _copyOverrides = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28(arg, allowed) {\n    var overrides;\n    return _regeneratorRuntime().wrap(function _callee28$(_context28) {\n      while (1) switch (_context28.prev = _context28.next) {\n        case 0:\n          // Create a shallow copy (we'll deep-ify anything needed during normalizing)\n          overrides = copyRequest(Typed.dereference(arg, \"overrides\"));\n          assertArgument(overrides.to == null || (allowed || []).indexOf(\"to\") >= 0, \"cannot override to\", \"overrides.to\", overrides.to);\n          assertArgument(overrides.data == null || (allowed || []).indexOf(\"data\") >= 0, \"cannot override data\", \"overrides.data\", overrides.data);\n          // Resolve any from\n          if (!overrides.from) {\n            _context28.next = 7;\n            break;\n          }\n          _context28.next = 6;\n          return resolveAddress(overrides.from);\n        case 6:\n          overrides.from = _context28.sent;\n        case 7:\n          return _context28.abrupt(\"return\", overrides);\n        case 8:\n        case \"end\":\n          return _context28.stop();\n      }\n    }, _callee28);\n  }));\n  return _copyOverrides.apply(this, arguments);\n}\nexport function resolveArgs(_x3, _x4, _x5) {\n  return _resolveArgs.apply(this, arguments);\n}\nfunction _resolveArgs() {\n  _resolveArgs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee29(_runner, inputs, args) {\n    var runner, resolver;\n    return _regeneratorRuntime().wrap(function _callee29$(_context29) {\n      while (1) switch (_context29.prev = _context29.next) {\n        case 0:\n          // Recursively descend into args and resolve any addresses\n          runner = getRunner(_runner, \"resolveName\");\n          resolver = canResolve(runner) ? runner : null;\n          _context29.next = 4;\n          return Promise.all(inputs.map(function (param, index) {\n            return param.walkAsync(args[index], function (type, value) {\n              value = Typed.dereference(value, type);\n              if (type === \"address\") {\n                return resolveAddress(value, resolver);\n              }\n              return value;\n            });\n          }));\n        case 4:\n          return _context29.abrupt(\"return\", _context29.sent);\n        case 5:\n        case \"end\":\n          return _context29.stop();\n      }\n    }, _callee29);\n  }));\n  return _resolveArgs.apply(this, arguments);\n}\nfunction buildWrappedFallback(contract) {\n  var populateTransaction = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(overrides) {\n      var tx, iface, payable;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return copyOverrides(overrides, [\"data\"]);\n          case 2:\n            tx = _context2.sent;\n            _context2.next = 5;\n            return contract.getAddress();\n          case 5:\n            tx.to = _context2.sent;\n            iface = contract.interface; // Only allow payable contracts to set non-zero value\n            payable = iface.receive || iface.fallback && iface.fallback.payable;\n            assertArgument(payable || (tx.value || BN_0) === BN_0, \"cannot send value to non-payable contract\", \"overrides.value\", tx.value);\n            // Only allow fallback contracts to set non-empty data\n            assertArgument(iface.fallback || (tx.data || \"0x\") === \"0x\", \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n            return _context2.abrupt(\"return\", tx);\n          case 11:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }));\n    return function populateTransaction(_x6) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  var staticCall = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(overrides) {\n      var runner, tx;\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            runner = getRunner(contract.runner, \"call\");\n            assert(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", {\n              operation: \"call\"\n            });\n            _context3.next = 4;\n            return populateTransaction(overrides);\n          case 4:\n            tx = _context3.sent;\n            _context3.prev = 5;\n            _context3.next = 8;\n            return runner.call(tx);\n          case 8:\n            return _context3.abrupt(\"return\", _context3.sent);\n          case 11:\n            _context3.prev = 11;\n            _context3.t0 = _context3[\"catch\"](5);\n            if (!(isCallException(_context3.t0) && _context3.t0.data)) {\n              _context3.next = 15;\n              break;\n            }\n            throw contract.interface.makeError(_context3.t0.data, tx);\n          case 15:\n            throw _context3.t0;\n          case 16:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, _callee3, null, [[5, 11]]);\n    }));\n    return function staticCall(_x7) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  var send = /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(overrides) {\n      var runner, tx, provider;\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            runner = contract.runner;\n            assert(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n              operation: \"sendTransaction\"\n            });\n            _context4.t0 = runner;\n            _context4.next = 5;\n            return populateTransaction(overrides);\n          case 5:\n            _context4.t1 = _context4.sent;\n            _context4.next = 8;\n            return _context4.t0.sendTransaction.call(_context4.t0, _context4.t1);\n          case 8:\n            tx = _context4.sent;\n            provider = getProvider(contract.runner); // @TODO: the provider can be null; make a custom dummy provider that will throw a\n            // meaningful error\n            return _context4.abrupt(\"return\", new ContractTransactionResponse(contract.interface, provider, tx));\n          case 11:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4);\n    }));\n    return function send(_x8) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n  var estimateGas = /*#__PURE__*/function () {\n    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(overrides) {\n      var runner;\n      return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            runner = getRunner(contract.runner, \"estimateGas\");\n            assert(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", {\n              operation: \"estimateGas\"\n            });\n            _context5.t0 = runner;\n            _context5.next = 5;\n            return populateTransaction(overrides);\n          case 5:\n            _context5.t1 = _context5.sent;\n            _context5.next = 8;\n            return _context5.t0.estimateGas.call(_context5.t0, _context5.t1);\n          case 8:\n            return _context5.abrupt(\"return\", _context5.sent);\n          case 9:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, _callee5);\n    }));\n    return function estimateGas(_x9) {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n  var method = /*#__PURE__*/function () {\n    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(overrides) {\n      return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n        while (1) switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.next = 2;\n            return send(overrides);\n          case 2:\n            return _context6.abrupt(\"return\", _context6.sent);\n          case 3:\n          case \"end\":\n            return _context6.stop();\n        }\n      }, _callee6);\n    }));\n    return function method(_x10) {\n      return _ref6.apply(this, arguments);\n    };\n  }();\n  defineProperties(method, {\n    _contract: contract,\n    estimateGas: estimateGas,\n    populateTransaction: populateTransaction,\n    send: send,\n    staticCall: staticCall\n  });\n  return method;\n}\nfunction buildWrappedMethod(contract, key) {\n  var getFragment = function getFragment() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    var fragment = contract.interface.getFunction(key, args);\n    assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"fragment\"\n    });\n    return fragment;\n  };\n  var populateTransaction = /*#__PURE__*/function () {\n    var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n      var _len2,\n        args,\n        _key2,\n        fragment,\n        overrides,\n        resolvedArgs,\n        _args7 = arguments;\n      return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n        while (1) switch (_context7.prev = _context7.next) {\n          case 0:\n            for (_len2 = _args7.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              args[_key2] = _args7[_key2];\n            }\n            fragment = getFragment.apply(void 0, args); // If an overrides was passed in, copy it and normalize the values\n            overrides = {};\n            if (!(fragment.inputs.length + 1 === args.length)) {\n              _context7.next = 7;\n              break;\n            }\n            _context7.next = 6;\n            return copyOverrides(args.pop());\n          case 6:\n            overrides = _context7.sent;\n          case 7:\n            if (!(fragment.inputs.length !== args.length)) {\n              _context7.next = 9;\n              break;\n            }\n            throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");\n          case 9:\n            _context7.next = 11;\n            return resolveArgs(contract.runner, fragment.inputs, args);\n          case 11:\n            resolvedArgs = _context7.sent;\n            _context7.t0 = Object;\n            _context7.t1 = {};\n            _context7.t2 = overrides;\n            _context7.next = 17;\n            return resolveProperties({\n              to: contract.getAddress(),\n              data: contract.interface.encodeFunctionData(fragment, resolvedArgs)\n            });\n          case 17:\n            _context7.t3 = _context7.sent;\n            return _context7.abrupt(\"return\", _context7.t0.assign.call(_context7.t0, _context7.t1, _context7.t2, _context7.t3));\n          case 19:\n          case \"end\":\n            return _context7.stop();\n        }\n      }, _callee7);\n    }));\n    return function populateTransaction() {\n      return _ref7.apply(this, arguments);\n    };\n  }();\n  var staticCall = /*#__PURE__*/function () {\n    var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n      var result,\n        _args8 = arguments;\n      return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n        while (1) switch (_context8.prev = _context8.next) {\n          case 0:\n            _context8.next = 2;\n            return staticCallResult.apply(void 0, _args8);\n          case 2:\n            result = _context8.sent;\n            if (!(result.length === 1)) {\n              _context8.next = 5;\n              break;\n            }\n            return _context8.abrupt(\"return\", result[0]);\n          case 5:\n            return _context8.abrupt(\"return\", result);\n          case 6:\n          case \"end\":\n            return _context8.stop();\n        }\n      }, _callee8);\n    }));\n    return function staticCall() {\n      return _ref8.apply(this, arguments);\n    };\n  }();\n  var send = /*#__PURE__*/function () {\n    var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n      var runner,\n        tx,\n        provider,\n        _args9 = arguments;\n      return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n        while (1) switch (_context9.prev = _context9.next) {\n          case 0:\n            runner = contract.runner;\n            assert(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n              operation: \"sendTransaction\"\n            });\n            _context9.t0 = runner;\n            _context9.next = 5;\n            return populateTransaction.apply(void 0, _args9);\n          case 5:\n            _context9.t1 = _context9.sent;\n            _context9.next = 8;\n            return _context9.t0.sendTransaction.call(_context9.t0, _context9.t1);\n          case 8:\n            tx = _context9.sent;\n            provider = getProvider(contract.runner); // @TODO: the provider can be null; make a custom dummy provider that will throw a\n            // meaningful error\n            return _context9.abrupt(\"return\", new ContractTransactionResponse(contract.interface, provider, tx));\n          case 11:\n          case \"end\":\n            return _context9.stop();\n        }\n      }, _callee9);\n    }));\n    return function send() {\n      return _ref9.apply(this, arguments);\n    };\n  }();\n  var estimateGas = /*#__PURE__*/function () {\n    var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n      var runner,\n        _args10 = arguments;\n      return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n        while (1) switch (_context10.prev = _context10.next) {\n          case 0:\n            runner = getRunner(contract.runner, \"estimateGas\");\n            assert(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", {\n              operation: \"estimateGas\"\n            });\n            _context10.t0 = runner;\n            _context10.next = 5;\n            return populateTransaction.apply(void 0, _args10);\n          case 5:\n            _context10.t1 = _context10.sent;\n            _context10.next = 8;\n            return _context10.t0.estimateGas.call(_context10.t0, _context10.t1);\n          case 8:\n            return _context10.abrupt(\"return\", _context10.sent);\n          case 9:\n          case \"end\":\n            return _context10.stop();\n        }\n      }, _callee10);\n    }));\n    return function estimateGas() {\n      return _ref10.apply(this, arguments);\n    };\n  }();\n  var staticCallResult = /*#__PURE__*/function () {\n    var _ref11 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n      var runner,\n        tx,\n        result,\n        fragment,\n        _args11 = arguments;\n      return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n        while (1) switch (_context11.prev = _context11.next) {\n          case 0:\n            runner = getRunner(contract.runner, \"call\");\n            assert(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", {\n              operation: \"call\"\n            });\n            _context11.next = 4;\n            return populateTransaction.apply(void 0, _args11);\n          case 4:\n            tx = _context11.sent;\n            result = \"0x\";\n            _context11.prev = 6;\n            _context11.next = 9;\n            return runner.call(tx);\n          case 9:\n            result = _context11.sent;\n            _context11.next = 17;\n            break;\n          case 12:\n            _context11.prev = 12;\n            _context11.t0 = _context11[\"catch\"](6);\n            if (!(isCallException(_context11.t0) && _context11.t0.data)) {\n              _context11.next = 16;\n              break;\n            }\n            throw contract.interface.makeError(_context11.t0.data, tx);\n          case 16:\n            throw _context11.t0;\n          case 17:\n            fragment = getFragment.apply(void 0, _args11);\n            return _context11.abrupt(\"return\", contract.interface.decodeFunctionResult(fragment, result));\n          case 19:\n          case \"end\":\n            return _context11.stop();\n        }\n      }, _callee11, null, [[6, 12]]);\n    }));\n    return function staticCallResult() {\n      return _ref11.apply(this, arguments);\n    };\n  }();\n  var method = /*#__PURE__*/function () {\n    var _ref12 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n      var fragment,\n        _args12 = arguments;\n      return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n        while (1) switch (_context12.prev = _context12.next) {\n          case 0:\n            fragment = getFragment.apply(void 0, _args12);\n            if (!fragment.constant) {\n              _context12.next = 5;\n              break;\n            }\n            _context12.next = 4;\n            return staticCall.apply(void 0, _args12);\n          case 4:\n            return _context12.abrupt(\"return\", _context12.sent);\n          case 5:\n            _context12.next = 7;\n            return send.apply(void 0, _args12);\n          case 7:\n            return _context12.abrupt(\"return\", _context12.sent);\n          case 8:\n          case \"end\":\n            return _context12.stop();\n        }\n      }, _callee12);\n    }));\n    return function method() {\n      return _ref12.apply(this, arguments);\n    };\n  }();\n  defineProperties(method, {\n    name: contract.interface.getFunctionName(key),\n    _contract: contract,\n    _key: key,\n    getFragment: getFragment,\n    estimateGas: estimateGas,\n    populateTransaction: populateTransaction,\n    send: send,\n    staticCall: staticCall,\n    staticCallResult: staticCallResult\n  });\n  // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n  Object.defineProperty(method, \"fragment\", {\n    configurable: false,\n    enumerable: true,\n    get: function get() {\n      var fragment = contract.interface.getFunction(key);\n      assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"fragment\"\n      });\n      return fragment;\n    }\n  });\n  return method;\n}\nfunction buildWrappedEvent(contract, key) {\n  var getFragment = function getFragment() {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    var fragment = contract.interface.getEvent(key, args);\n    assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"fragment\"\n    });\n    return fragment;\n  };\n  var method = function method() {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    return new PreparedTopicFilter(contract, getFragment.apply(void 0, args), args);\n  };\n  defineProperties(method, {\n    name: contract.interface.getEventName(key),\n    _contract: contract,\n    _key: key,\n    getFragment: getFragment\n  });\n  // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n  Object.defineProperty(method, \"fragment\", {\n    configurable: false,\n    enumerable: true,\n    get: function get() {\n      var fragment = contract.interface.getEvent(key);\n      assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"fragment\"\n      });\n      return fragment;\n    }\n  });\n  return method;\n}\n// The combination of TypeScrype, Private Fields and Proxies makes\n// the world go boom; so we hide variables with some trickery keeping\n// a symbol attached to each BaseContract which its sub-class (even\n// via a Proxy) can reach and use to look up its internal values.\nvar internal = Symbol.for(\"_ethersInternal_contract\");\nvar internalValues = new WeakMap();\nfunction setInternal(contract, values) {\n  internalValues.set(contract[internal], values);\n}\nfunction getInternal(contract) {\n  return internalValues.get(contract[internal]);\n}\nfunction isDeferred(value) {\n  return value && typeof value === \"object\" && \"getTopicFilter\" in value && typeof value.getTopicFilter === \"function\" && value.fragment;\n}\nfunction getSubInfo(_x11, _x12) {\n  return _getSubInfo.apply(this, arguments);\n}\nfunction _getSubInfo() {\n  _getSubInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee30(contract, event) {\n    var topics, fragment, topicHashify, tag;\n    return _regeneratorRuntime().wrap(function _callee30$(_context30) {\n      while (1) switch (_context30.prev = _context30.next) {\n        case 0:\n          fragment = null; // Convert named events to topicHash and get the fragment for\n          // events which need deconstructing.\n          if (!Array.isArray(event)) {\n            _context30.next = 6;\n            break;\n          }\n          topicHashify = function topicHashify(name) {\n            if (isHexString(name, 32)) {\n              return name;\n            }\n            var fragment = contract.interface.getEvent(name);\n            assertArgument(fragment, \"unknown fragment\", \"name\", name);\n            return fragment.topicHash;\n          }; // Array of Topics and Names; e.g. `[ \"0x1234...89ab\", \"Transfer(address)\" ]`\n          topics = event.map(function (e) {\n            if (e == null) {\n              return null;\n            }\n            if (Array.isArray(e)) {\n              return e.map(topicHashify);\n            }\n            return topicHashify(e);\n          });\n          _context30.next = 21;\n          break;\n        case 6:\n          if (!(event === \"*\")) {\n            _context30.next = 10;\n            break;\n          }\n          topics = [null];\n          _context30.next = 21;\n          break;\n        case 10:\n          if (!(typeof event === \"string\")) {\n            _context30.next = 14;\n            break;\n          }\n          if (isHexString(event, 32)) {\n            // Topic Hash\n            topics = [event];\n          } else {\n            // Name or Signature; e.g. `\"Transfer\", `\"Transfer(address)\"`\n            fragment = contract.interface.getEvent(event);\n            assertArgument(fragment, \"unknown fragment\", \"event\", event);\n            topics = [fragment.topicHash];\n          }\n          _context30.next = 21;\n          break;\n        case 14:\n          if (!isDeferred(event)) {\n            _context30.next = 20;\n            break;\n          }\n          _context30.next = 17;\n          return event.getTopicFilter();\n        case 17:\n          topics = _context30.sent;\n          _context30.next = 21;\n          break;\n        case 20:\n          if (\"fragment\" in event) {\n            // ContractEvent; e.g. `contract.filter.Transfer`\n            fragment = event.fragment;\n            topics = [fragment.topicHash];\n          } else {\n            assertArgument(false, \"unknown event name\", \"event\", event);\n          }\n        case 21:\n          // Normalize topics and sort TopicSets\n          topics = topics.map(function (t) {\n            if (t == null) {\n              return null;\n            }\n            if (Array.isArray(t)) {\n              var items = Array.from(new Set(t.map(function (t) {\n                return t.toLowerCase();\n              })).values());\n              if (items.length === 1) {\n                return items[0];\n              }\n              items.sort();\n              return items;\n            }\n            return t.toLowerCase();\n          });\n          tag = topics.map(function (t) {\n            if (t == null) {\n              return \"null\";\n            }\n            if (Array.isArray(t)) {\n              return t.join(\"|\");\n            }\n            return t;\n          }).join(\"&\");\n          return _context30.abrupt(\"return\", {\n            fragment: fragment,\n            tag: tag,\n            topics: topics\n          });\n        case 24:\n        case \"end\":\n          return _context30.stop();\n      }\n    }, _callee30);\n  }));\n  return _getSubInfo.apply(this, arguments);\n}\nfunction hasSub(_x13, _x14) {\n  return _hasSub.apply(this, arguments);\n}\nfunction _hasSub() {\n  _hasSub = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee31(contract, event) {\n    var _getInternal5, subs;\n    return _regeneratorRuntime().wrap(function _callee31$(_context31) {\n      while (1) switch (_context31.prev = _context31.next) {\n        case 0:\n          _getInternal5 = getInternal(contract), subs = _getInternal5.subs;\n          _context31.t1 = subs;\n          _context31.next = 4;\n          return getSubInfo(contract, event);\n        case 4:\n          _context31.t2 = _context31.sent.tag;\n          _context31.t0 = _context31.t1.get.call(_context31.t1, _context31.t2);\n          if (_context31.t0) {\n            _context31.next = 8;\n            break;\n          }\n          _context31.t0 = null;\n        case 8:\n          return _context31.abrupt(\"return\", _context31.t0);\n        case 9:\n        case \"end\":\n          return _context31.stop();\n      }\n    }, _callee31);\n  }));\n  return _hasSub.apply(this, arguments);\n}\nfunction getSub(_x15, _x16, _x17) {\n  return _getSub.apply(this, arguments);\n} // We use this to ensure one emit resolves before firing the next to\n// ensure correct ordering (note this cannot throw and just adds the\n// notice to the event queu using setTimeout).\nfunction _getSub() {\n  _getSub = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee33(contract, operation, event) {\n    var provider, _yield$getSubInfo2, fragment, tag, topics, _getInternal6, addr, subs, sub, address, filter, listener, starting, start, stop;\n    return _regeneratorRuntime().wrap(function _callee33$(_context33) {\n      while (1) switch (_context33.prev = _context33.next) {\n        case 0:\n          // Make sure our runner can actually subscribe to events\n          provider = getProvider(contract.runner);\n          assert(provider, \"contract runner does not support subscribing\", \"UNSUPPORTED_OPERATION\", {\n            operation: operation\n          });\n          _context33.next = 4;\n          return getSubInfo(contract, event);\n        case 4:\n          _yield$getSubInfo2 = _context33.sent;\n          fragment = _yield$getSubInfo2.fragment;\n          tag = _yield$getSubInfo2.tag;\n          topics = _yield$getSubInfo2.topics;\n          _getInternal6 = getInternal(contract), addr = _getInternal6.addr, subs = _getInternal6.subs;\n          sub = subs.get(tag);\n          if (!sub) {\n            address = addr ? addr : contract;\n            filter = {\n              address: address,\n              topics: topics\n            };\n            listener = function listener(log) {\n              var foundFragment = fragment;\n              if (foundFragment == null) {\n                try {\n                  foundFragment = contract.interface.getEvent(log.topics[0]);\n                } catch (error) {}\n              }\n              // If fragment is null, we do not deconstruct the args to emit\n              if (foundFragment) {\n                var _foundFragment = foundFragment;\n                var _args32 = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];\n                _emit4(contract, event, _args32, function (listener) {\n                  return new ContractEventPayload(contract, listener, event, _foundFragment, log);\n                });\n              } else {\n                _emit4(contract, event, [], function (listener) {\n                  return new ContractUnknownEventPayload(contract, listener, event, log);\n                });\n              }\n            };\n            starting = [];\n            start = function start() {\n              if (starting.length) {\n                return;\n              }\n              starting.push(provider.on(filter, listener));\n            };\n            stop = /*#__PURE__*/function () {\n              var _ref17 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee32() {\n                var started;\n                return _regeneratorRuntime().wrap(function _callee32$(_context32) {\n                  while (1) switch (_context32.prev = _context32.next) {\n                    case 0:\n                      if (!(starting.length == 0)) {\n                        _context32.next = 2;\n                        break;\n                      }\n                      return _context32.abrupt(\"return\");\n                    case 2:\n                      started = starting;\n                      starting = [];\n                      _context32.next = 6;\n                      return Promise.all(started);\n                    case 6:\n                      provider.off(filter, listener);\n                    case 7:\n                    case \"end\":\n                      return _context32.stop();\n                  }\n                }, _callee32);\n              }));\n              return function stop() {\n                return _ref17.apply(this, arguments);\n              };\n            }();\n            sub = {\n              tag: tag,\n              listeners: [],\n              start: start,\n              stop: stop\n            };\n            subs.set(tag, sub);\n          }\n          return _context33.abrupt(\"return\", sub);\n        case 12:\n        case \"end\":\n          return _context33.stop();\n      }\n    }, _callee33);\n  }));\n  return _getSub.apply(this, arguments);\n}\nvar lastEmit = Promise.resolve();\nfunction _emit(_x18, _x19, _x20, _x21) {\n  return _emit2.apply(this, arguments);\n}\nfunction _emit2() {\n  _emit2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee34(contract, event, args, payloadFunc) {\n    var sub, count;\n    return _regeneratorRuntime().wrap(function _callee34$(_context34) {\n      while (1) switch (_context34.prev = _context34.next) {\n        case 0:\n          _context34.next = 2;\n          return lastEmit;\n        case 2:\n          _context34.next = 4;\n          return hasSub(contract, event);\n        case 4:\n          sub = _context34.sent;\n          if (sub) {\n            _context34.next = 7;\n            break;\n          }\n          return _context34.abrupt(\"return\", false);\n        case 7:\n          count = sub.listeners.length;\n          sub.listeners = sub.listeners.filter(function (_ref18) {\n            var listener = _ref18.listener,\n              once = _ref18.once;\n            var passArgs = Array.from(args);\n            if (payloadFunc) {\n              passArgs.push(payloadFunc(once ? null : listener));\n            }\n            try {\n              listener.call.apply(listener, [contract].concat(passArgs));\n            } catch (error) {}\n            return !once;\n          });\n          return _context34.abrupt(\"return\", count > 0);\n        case 10:\n        case \"end\":\n          return _context34.stop();\n      }\n    }, _callee34);\n  }));\n  return _emit2.apply(this, arguments);\n}\nfunction _emit4(_x22, _x23, _x24, _x25) {\n  return _emit3.apply(this, arguments);\n}\nfunction _emit3() {\n  _emit3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee35(contract, event, args, payloadFunc) {\n    var resultPromise;\n    return _regeneratorRuntime().wrap(function _callee35$(_context35) {\n      while (1) switch (_context35.prev = _context35.next) {\n        case 0:\n          _context35.prev = 0;\n          _context35.next = 3;\n          return lastEmit;\n        case 3:\n          _context35.next = 7;\n          break;\n        case 5:\n          _context35.prev = 5;\n          _context35.t0 = _context35[\"catch\"](0);\n        case 7:\n          resultPromise = _emit(contract, event, args, payloadFunc);\n          lastEmit = resultPromise;\n          _context35.next = 11;\n          return resultPromise;\n        case 11:\n          return _context35.abrupt(\"return\", _context35.sent);\n        case 12:\n        case \"end\":\n          return _context35.stop();\n      }\n    }, _callee35, null, [[0, 5]]);\n  }));\n  return _emit3.apply(this, arguments);\n}\nvar passProperties = [\"then\"];\nexport var BaseContract = /*#__PURE__*/function () {\n  function BaseContract(target, abi, runner, _deployTx) {\n    var _this = this;\n    _classCallCheck(this, BaseContract);\n    _defineProperty(this, \"target\", void 0);\n    _defineProperty(this, \"interface\", void 0);\n    _defineProperty(this, \"runner\", void 0);\n    _defineProperty(this, \"filters\", void 0);\n    _defineProperty(this, internal, void 0);\n    _defineProperty(this, \"fallback\", void 0);\n    if (runner == null) {\n      runner = null;\n    }\n    var iface = Interface.from(abi);\n    defineProperties(this, {\n      target: target,\n      runner: runner,\n      interface: iface\n    });\n    Object.defineProperty(this, internal, {\n      value: {}\n    });\n    var addrPromise;\n    var addr = null;\n    var deployTx = null;\n    if (_deployTx) {\n      var provider = getProvider(runner);\n      // @TODO: the provider can be null; make a custom dummy provider that will throw a\n      // meaningful error\n      deployTx = new ContractTransactionResponse(this.interface, provider, _deployTx);\n    }\n    var subs = new Map();\n    // Resolve the target as the address\n    if (typeof target === \"string\") {\n      if (isHexString(target)) {\n        addr = target;\n        addrPromise = Promise.resolve(target);\n      } else {\n        var resolver = getRunner(runner, \"resolveName\");\n        if (!canResolve(resolver)) {\n          throw makeError(\"contract runner does not support name resolution\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"resolveName\"\n          });\n        }\n        addrPromise = resolver.resolveName(target).then(function (addr) {\n          if (addr == null) {\n            throw new Error(\"TODO\");\n          }\n          getInternal(_this).addr = addr;\n          return addr;\n        });\n      }\n    } else {\n      addrPromise = target.getAddress().then(function (addr) {\n        if (addr == null) {\n          throw new Error(\"TODO\");\n        }\n        getInternal(_this).addr = addr;\n        return addr;\n      });\n    }\n    // Set our private values\n    setInternal(this, {\n      addrPromise: addrPromise,\n      addr: addr,\n      deployTx: deployTx,\n      subs: subs\n    });\n    // Add the event filters\n    var filters = new Proxy({}, {\n      get: function get(target, _prop, receiver) {\n        // Pass important checks (like `then` for Promise) through\n        if (passProperties.indexOf(_prop) >= 0) {\n          return Reflect.get(target, _prop, receiver);\n        }\n        var prop = String(_prop);\n        var result = _this.getEvent(prop);\n        if (result) {\n          return result;\n        }\n        throw new Error(\"unknown contract event: \".concat(prop));\n      },\n      has: function has(target, prop) {\n        // Pass important checks (like `then` for Promise) through\n        if (passProperties.indexOf(prop) >= 0) {\n          return Reflect.has(target, prop);\n        }\n        return Reflect.has(target, prop) || _this.interface.hasEvent(String(prop));\n      }\n    });\n    defineProperties(this, {\n      filters: filters\n    });\n    defineProperties(this, {\n      fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null\n    });\n    // Return a Proxy that will respond to functions\n    return new Proxy(this, {\n      get: function get(target, _prop, receiver) {\n        if (_prop in target || passProperties.indexOf(_prop) >= 0) {\n          return Reflect.get(target, _prop, receiver);\n        }\n        var prop = String(_prop);\n        var result = target.getFunction(prop);\n        if (result) {\n          return result;\n        }\n        throw new Error(\"unknown contract method: \".concat(prop));\n      },\n      has: function has(target, prop) {\n        if (prop in target || passProperties.indexOf(prop) >= 0) {\n          return Reflect.has(target, prop);\n        }\n        return target.interface.hasFunction(String(prop));\n      }\n    });\n  }\n  _createClass(BaseContract, [{\n    key: \"connect\",\n    value: function connect(runner) {\n      return new BaseContract(this.target, this.interface, runner);\n    }\n  }, {\n    key: \"getAddress\",\n    value: function () {\n      var _getAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              _context13.next = 2;\n              return getInternal(this).addrPromise;\n            case 2:\n              return _context13.abrupt(\"return\", _context13.sent);\n            case 3:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, this);\n      }));\n      function getAddress() {\n        return _getAddress.apply(this, arguments);\n      }\n      return getAddress;\n    }()\n  }, {\n    key: \"getDeployedCode\",\n    value: function () {\n      var _getDeployedCode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n        var provider, code;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              provider = getProvider(this.runner);\n              assert(provider, \"runner does not support .provider\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"getDeployedCode\"\n              });\n              _context14.t0 = provider;\n              _context14.next = 5;\n              return this.getAddress();\n            case 5:\n              _context14.t1 = _context14.sent;\n              _context14.next = 8;\n              return _context14.t0.getCode.call(_context14.t0, _context14.t1);\n            case 8:\n              code = _context14.sent;\n              if (!(code === \"0x\")) {\n                _context14.next = 11;\n                break;\n              }\n              return _context14.abrupt(\"return\", null);\n            case 11:\n              return _context14.abrupt(\"return\", code);\n            case 12:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, _callee14, this);\n      }));\n      function getDeployedCode() {\n        return _getDeployedCode.apply(this, arguments);\n      }\n      return getDeployedCode;\n    }()\n  }, {\n    key: \"waitForDeployment\",\n    value: function () {\n      var _waitForDeployment = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {\n        var _this2 = this;\n        var deployTx, code, provider;\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) switch (_context16.prev = _context16.next) {\n            case 0:\n              // We have the deployement transaction; just use that (throws if deployement fails)\n              deployTx = this.deploymentTransaction();\n              if (!deployTx) {\n                _context16.next = 5;\n                break;\n              }\n              _context16.next = 4;\n              return deployTx.wait();\n            case 4:\n              return _context16.abrupt(\"return\", this);\n            case 5:\n              _context16.next = 7;\n              return this.getDeployedCode();\n            case 7:\n              code = _context16.sent;\n              if (!(code != null)) {\n                _context16.next = 10;\n                break;\n              }\n              return _context16.abrupt(\"return\", this);\n            case 10:\n              // Make sure we can subscribe to a provider event\n              provider = getProvider(this.runner);\n              assert(provider != null, \"contract runner does not support .provider\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"waitForDeployment\"\n              });\n              return _context16.abrupt(\"return\", new Promise(function (resolve, reject) {\n                var checkCode = /*#__PURE__*/function () {\n                  var _ref13 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {\n                    var _code;\n                    return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n                      while (1) switch (_context15.prev = _context15.next) {\n                        case 0:\n                          _context15.prev = 0;\n                          _context15.next = 3;\n                          return _this2.getDeployedCode();\n                        case 3:\n                          _code = _context15.sent;\n                          if (!(_code != null)) {\n                            _context15.next = 6;\n                            break;\n                          }\n                          return _context15.abrupt(\"return\", resolve(_this2));\n                        case 6:\n                          provider.once(\"block\", checkCode);\n                          _context15.next = 12;\n                          break;\n                        case 9:\n                          _context15.prev = 9;\n                          _context15.t0 = _context15[\"catch\"](0);\n                          reject(_context15.t0);\n                        case 12:\n                        case \"end\":\n                          return _context15.stop();\n                      }\n                    }, _callee15, null, [[0, 9]]);\n                  }));\n                  return function checkCode() {\n                    return _ref13.apply(this, arguments);\n                  };\n                }();\n                checkCode();\n              }));\n            case 13:\n            case \"end\":\n              return _context16.stop();\n          }\n        }, _callee16, this);\n      }));\n      function waitForDeployment() {\n        return _waitForDeployment.apply(this, arguments);\n      }\n      return waitForDeployment;\n    }()\n  }, {\n    key: \"deploymentTransaction\",\n    value: function deploymentTransaction() {\n      return getInternal(this).deployTx;\n    }\n  }, {\n    key: \"getFunction\",\n    value: function getFunction(key) {\n      if (typeof key !== \"string\") {\n        key = key.format();\n      }\n      var func = buildWrappedMethod(this, key);\n      return func;\n    }\n  }, {\n    key: \"getEvent\",\n    value: function getEvent(key) {\n      if (typeof key !== \"string\") {\n        key = key.format();\n      }\n      return buildWrappedEvent(this, key);\n    }\n  }, {\n    key: \"queryTransaction\",\n    value: function () {\n      var _queryTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(hash) {\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              throw new Error(\"@TODO\");\n            case 1:\n            case \"end\":\n              return _context17.stop();\n          }\n        }, _callee17);\n      }));\n      function queryTransaction(_x26) {\n        return _queryTransaction.apply(this, arguments);\n      }\n      return queryTransaction;\n    }()\n  }, {\n    key: \"queryFilter\",\n    value: function () {\n      var _queryFilter = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(event, fromBlock, toBlock) {\n        var _this3 = this;\n        var _getInternal, addr, addrPromise, address, _yield$getSubInfo, fragment, topics, filter, provider;\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) switch (_context18.prev = _context18.next) {\n            case 0:\n              if (fromBlock == null) {\n                fromBlock = 0;\n              }\n              if (toBlock == null) {\n                toBlock = \"latest\";\n              }\n              _getInternal = getInternal(this), addr = _getInternal.addr, addrPromise = _getInternal.addrPromise;\n              if (!addr) {\n                _context18.next = 7;\n                break;\n              }\n              _context18.t0 = addr;\n              _context18.next = 10;\n              break;\n            case 7:\n              _context18.next = 9;\n              return addrPromise;\n            case 9:\n              _context18.t0 = _context18.sent;\n            case 10:\n              address = _context18.t0;\n              _context18.next = 13;\n              return getSubInfo(this, event);\n            case 13:\n              _yield$getSubInfo = _context18.sent;\n              fragment = _yield$getSubInfo.fragment;\n              topics = _yield$getSubInfo.topics;\n              filter = {\n                address: address,\n                topics: topics,\n                fromBlock: fromBlock,\n                toBlock: toBlock\n              };\n              provider = getProvider(this.runner);\n              assert(provider, \"contract runner does not have a provider\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"queryFilter\"\n              });\n              _context18.next = 21;\n              return provider.getLogs(filter);\n            case 21:\n              return _context18.abrupt(\"return\", _context18.sent.map(function (log) {\n                var foundFragment = fragment;\n                if (foundFragment == null) {\n                  try {\n                    foundFragment = _this3.interface.getEvent(log.topics[0]);\n                  } catch (error) {}\n                }\n                if (foundFragment) {\n                  return new EventLog(log, _this3.interface, foundFragment);\n                } else {\n                  return new Log(log, provider);\n                }\n              }));\n            case 22:\n            case \"end\":\n              return _context18.stop();\n          }\n        }, _callee18, this);\n      }));\n      function queryFilter(_x27, _x28, _x29) {\n        return _queryFilter.apply(this, arguments);\n      }\n      return queryFilter;\n    }()\n  }, {\n    key: \"on\",\n    value: function () {\n      var _on = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(event, listener) {\n        var sub;\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) switch (_context19.prev = _context19.next) {\n            case 0:\n              _context19.next = 2;\n              return getSub(this, \"on\", event);\n            case 2:\n              sub = _context19.sent;\n              sub.listeners.push({\n                listener: listener,\n                once: false\n              });\n              sub.start();\n              return _context19.abrupt(\"return\", this);\n            case 6:\n            case \"end\":\n              return _context19.stop();\n          }\n        }, _callee19, this);\n      }));\n      function on(_x30, _x31) {\n        return _on.apply(this, arguments);\n      }\n      return on;\n    }()\n  }, {\n    key: \"once\",\n    value: function () {\n      var _once = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(event, listener) {\n        var sub;\n        return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n          while (1) switch (_context20.prev = _context20.next) {\n            case 0:\n              _context20.next = 2;\n              return getSub(this, \"once\", event);\n            case 2:\n              sub = _context20.sent;\n              sub.listeners.push({\n                listener: listener,\n                once: true\n              });\n              sub.start();\n              return _context20.abrupt(\"return\", this);\n            case 6:\n            case \"end\":\n              return _context20.stop();\n          }\n        }, _callee20, this);\n      }));\n      function once(_x32, _x33) {\n        return _once.apply(this, arguments);\n      }\n      return once;\n    }()\n  }, {\n    key: \"emit\",\n    value: function () {\n      var _emit5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(event) {\n        var _len5,\n          args,\n          _key5,\n          _args21 = arguments;\n        return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n          while (1) switch (_context21.prev = _context21.next) {\n            case 0:\n              for (_len5 = _args21.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n                args[_key5 - 1] = _args21[_key5];\n              }\n              _context21.next = 3;\n              return _emit4(this, event, args, null);\n            case 3:\n              return _context21.abrupt(\"return\", _context21.sent);\n            case 4:\n            case \"end\":\n              return _context21.stop();\n          }\n        }, _callee21, this);\n      }));\n      function emit(_x34) {\n        return _emit5.apply(this, arguments);\n      }\n      return emit;\n    }()\n  }, {\n    key: \"listenerCount\",\n    value: function () {\n      var _listenerCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(event) {\n        var sub, _getInternal2, subs, total, _iterator, _step, listeners;\n        return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n          while (1) switch (_context22.prev = _context22.next) {\n            case 0:\n              if (!event) {\n                _context22.next = 7;\n                break;\n              }\n              _context22.next = 3;\n              return hasSub(this, event);\n            case 3:\n              sub = _context22.sent;\n              if (sub) {\n                _context22.next = 6;\n                break;\n              }\n              return _context22.abrupt(\"return\", 0);\n            case 6:\n              return _context22.abrupt(\"return\", sub.listeners.length);\n            case 7:\n              _getInternal2 = getInternal(this), subs = _getInternal2.subs;\n              total = 0;\n              _iterator = _createForOfIteratorHelper(subs.values());\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  listeners = _step.value.listeners;\n                  total += listeners.length;\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n              return _context22.abrupt(\"return\", total);\n            case 12:\n            case \"end\":\n              return _context22.stop();\n          }\n        }, _callee22, this);\n      }));\n      function listenerCount(_x35) {\n        return _listenerCount.apply(this, arguments);\n      }\n      return listenerCount;\n    }()\n  }, {\n    key: \"listeners\",\n    value: function () {\n      var _listeners = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(event) {\n        var sub, _getInternal3, subs, result, _iterator2, _step2, _listeners2;\n        return _regeneratorRuntime().wrap(function _callee23$(_context23) {\n          while (1) switch (_context23.prev = _context23.next) {\n            case 0:\n              if (!event) {\n                _context23.next = 7;\n                break;\n              }\n              _context23.next = 3;\n              return hasSub(this, event);\n            case 3:\n              sub = _context23.sent;\n              if (sub) {\n                _context23.next = 6;\n                break;\n              }\n              return _context23.abrupt(\"return\", []);\n            case 6:\n              return _context23.abrupt(\"return\", sub.listeners.map(function (_ref14) {\n                var listener = _ref14.listener;\n                return listener;\n              }));\n            case 7:\n              _getInternal3 = getInternal(this), subs = _getInternal3.subs;\n              result = [];\n              _iterator2 = _createForOfIteratorHelper(subs.values());\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  _listeners2 = _step2.value.listeners;\n                  result = result.concat(_listeners2.map(function (_ref15) {\n                    var listener = _ref15.listener;\n                    return listener;\n                  }));\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n              return _context23.abrupt(\"return\", result);\n            case 12:\n            case \"end\":\n              return _context23.stop();\n          }\n        }, _callee23, this);\n      }));\n      function listeners(_x36) {\n        return _listeners.apply(this, arguments);\n      }\n      return listeners;\n    }()\n  }, {\n    key: \"off\",\n    value: function () {\n      var _off = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(event, listener) {\n        var sub, index;\n        return _regeneratorRuntime().wrap(function _callee24$(_context24) {\n          while (1) switch (_context24.prev = _context24.next) {\n            case 0:\n              _context24.next = 2;\n              return hasSub(this, event);\n            case 2:\n              sub = _context24.sent;\n              if (sub) {\n                _context24.next = 5;\n                break;\n              }\n              return _context24.abrupt(\"return\", this);\n            case 5:\n              if (listener) {\n                index = sub.listeners.map(function (_ref16) {\n                  var listener = _ref16.listener;\n                  return listener;\n                }).indexOf(listener);\n                if (index >= 0) {\n                  sub.listeners.splice(index, 1);\n                }\n              }\n              if (listener == null || sub.listeners.length === 0) {\n                sub.stop();\n                getInternal(this).subs.delete(sub.tag);\n              }\n              return _context24.abrupt(\"return\", this);\n            case 8:\n            case \"end\":\n              return _context24.stop();\n          }\n        }, _callee24, this);\n      }));\n      function off(_x37, _x38) {\n        return _off.apply(this, arguments);\n      }\n      return off;\n    }()\n  }, {\n    key: \"removeAllListeners\",\n    value: function () {\n      var _removeAllListeners = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(event) {\n        var sub, _getInternal4, subs, _iterator3, _step3, _step3$value, tag, stop;\n        return _regeneratorRuntime().wrap(function _callee25$(_context25) {\n          while (1) switch (_context25.prev = _context25.next) {\n            case 0:\n              if (!event) {\n                _context25.next = 10;\n                break;\n              }\n              _context25.next = 3;\n              return hasSub(this, event);\n            case 3:\n              sub = _context25.sent;\n              if (sub) {\n                _context25.next = 6;\n                break;\n              }\n              return _context25.abrupt(\"return\", this);\n            case 6:\n              sub.stop();\n              getInternal(this).subs.delete(sub.tag);\n              _context25.next = 13;\n              break;\n            case 10:\n              _getInternal4 = getInternal(this), subs = _getInternal4.subs;\n              _iterator3 = _createForOfIteratorHelper(subs.values());\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  _step3$value = _step3.value, tag = _step3$value.tag, stop = _step3$value.stop;\n                  stop();\n                  subs.delete(tag);\n                }\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n            case 13:\n              return _context25.abrupt(\"return\", this);\n            case 14:\n            case \"end\":\n              return _context25.stop();\n          }\n        }, _callee25, this);\n      }));\n      function removeAllListeners(_x39) {\n        return _removeAllListeners.apply(this, arguments);\n      }\n      return removeAllListeners;\n    }() // Alias for \"on\"\n  }, {\n    key: \"addListener\",\n    value: function () {\n      var _addListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26(event, listener) {\n        return _regeneratorRuntime().wrap(function _callee26$(_context26) {\n          while (1) switch (_context26.prev = _context26.next) {\n            case 0:\n              _context26.next = 2;\n              return this.on(event, listener);\n            case 2:\n              return _context26.abrupt(\"return\", _context26.sent);\n            case 3:\n            case \"end\":\n              return _context26.stop();\n          }\n        }, _callee26, this);\n      }));\n      function addListener(_x40, _x41) {\n        return _addListener.apply(this, arguments);\n      }\n      return addListener;\n    }() // Alias for \"off\"\n  }, {\n    key: \"removeListener\",\n    value: function () {\n      var _removeListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27(event, listener) {\n        return _regeneratorRuntime().wrap(function _callee27$(_context27) {\n          while (1) switch (_context27.prev = _context27.next) {\n            case 0:\n              _context27.next = 2;\n              return this.off(event, listener);\n            case 2:\n              return _context27.abrupt(\"return\", _context27.sent);\n            case 3:\n            case \"end\":\n              return _context27.stop();\n          }\n        }, _callee27, this);\n      }));\n      function removeListener(_x42, _x43) {\n        return _removeListener.apply(this, arguments);\n      }\n      return removeListener;\n    }()\n  }], [{\n    key: \"buildClass\",\n    value: function buildClass(abi) {\n      var CustomContract = /*#__PURE__*/function (_BaseContract) {\n        _inherits(CustomContract, _BaseContract);\n        var _super = _createSuper(CustomContract);\n        function CustomContract(address) {\n          var runner = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n          _classCallCheck(this, CustomContract);\n          return _super.call(this, address, abi, runner);\n        }\n        return _createClass(CustomContract);\n      }(BaseContract);\n      return CustomContract;\n    }\n  }, {\n    key: \"from\",\n    value: function from(target, abi, runner) {\n      if (runner == null) {\n        runner = null;\n      }\n      var contract = new this(target, abi, runner);\n      return contract;\n    }\n  }]);\n  return BaseContract;\n}();\nfunction _ContractBase() {\n  return BaseContract;\n}\nexport var Contract = /*#__PURE__*/function (_ContractBase2) {\n  _inherits(Contract, _ContractBase2);\n  var _super2 = _createSuper(Contract);\n  function Contract() {\n    _classCallCheck(this, Contract);\n    return _super2.apply(this, arguments);\n  }\n  return _createClass(Contract);\n}(_ContractBase());","map":{"version":3,"names":["Interface","Typed","resolveAddress","copyRequest","Log","defineProperties","isCallException","isHexString","resolveProperties","makeError","assert","assertArgument","ContractEventPayload","ContractUnknownEventPayload","ContractTransactionResponse","EventLog","BN_0","BigInt","canCall","value","call","canEstimate","estimateGas","canResolve","resolveName","canSend","sendTransaction","_filter","WeakMap","PreparedTopicFilter","contract","fragment","args","_classCallCheck","_classPrivateFieldInitSpec","writable","_defineProperty","inputs","length","Error","runner","getRunner","resolver","_classPrivateFieldSet","_asyncToGenerator","_regeneratorRuntime","mark","_callee","resolvedArgs","wrap","_callee$","_context","prev","next","Promise","all","map","param","index","arg","walkAsync","type","sent","abrupt","interface","encodeFilterTopics","stop","_createClass","key","getTopicFilter","_classPrivateFieldGet","feature","provider","getProvider","copyOverrides","_x","_x2","_copyOverrides","apply","arguments","_callee28","allowed","overrides","_callee28$","_context28","dereference","to","indexOf","data","from","resolveArgs","_x3","_x4","_x5","_resolveArgs","_callee29","_runner","_callee29$","_context29","buildWrappedFallback","populateTransaction","_ref2","_callee2","tx","iface","payable","_callee2$","_context2","getAddress","receive","fallback","_x6","staticCall","_ref3","_callee3","_callee3$","_context3","operation","t0","_x7","send","_ref4","_callee4","_callee4$","_context4","t1","_x8","_ref5","_callee5","_callee5$","_context5","_x9","method","_ref6","_callee6","_callee6$","_context6","_x10","_contract","buildWrappedMethod","getFragment","_len","Array","_key","getFunction","_ref7","_callee7","_len2","_key2","_args7","_callee7$","_context7","pop","Object","t2","encodeFunctionData","t3","assign","_ref8","_callee8","result","_args8","_callee8$","_context8","staticCallResult","_ref9","_callee9","_args9","_callee9$","_context9","_ref10","_callee10","_args10","_callee10$","_context10","_ref11","_callee11","_args11","_callee11$","_context11","decodeFunctionResult","_ref12","_callee12","_args12","_callee12$","_context12","constant","name","getFunctionName","defineProperty","configurable","enumerable","get","buildWrappedEvent","_len3","_key3","getEvent","_len4","_key4","getEventName","internal","Symbol","for","internalValues","setInternal","values","set","getInternal","isDeferred","getSubInfo","_x11","_x12","_getSubInfo","_callee30","event","topics","topicHashify","tag","_callee30$","_context30","isArray","topicHash","e","t","items","Set","toLowerCase","sort","join","hasSub","_x13","_x14","_hasSub","_callee31","_getInternal5","subs","_callee31$","_context31","getSub","_x15","_x16","_x17","_getSub","_callee33","_yield$getSubInfo2","_getInternal6","addr","sub","address","filter","listener","starting","start","_callee33$","_context33","log","foundFragment","error","_foundFragment","decodeEventLog","emit","push","on","_ref17","_callee32","started","_callee32$","_context32","off","listeners","lastEmit","resolve","_emit","_x18","_x19","_x20","_x21","_emit2","_callee34","payloadFunc","count","_callee34$","_context34","_ref18","once","passArgs","concat","_x22","_x23","_x24","_x25","_emit3","_callee35","resultPromise","_callee35$","_context35","passProperties","BaseContract","target","abi","_deployTx","_this","addrPromise","deployTx","Map","then","filters","Proxy","_prop","receiver","Reflect","prop","String","has","hasEvent","hasFunction","connect","_getAddress","_callee13","_callee13$","_context13","_getDeployedCode","_callee14","code","_callee14$","_context14","getCode","getDeployedCode","_waitForDeployment","_callee16","_this2","_callee16$","_context16","deploymentTransaction","wait","reject","checkCode","_ref13","_callee15","_code","_callee15$","_context15","waitForDeployment","format","func","_queryTransaction","_callee17","hash","_callee17$","_context17","queryTransaction","_x26","_queryFilter","_callee18","fromBlock","toBlock","_this3","_getInternal","_yield$getSubInfo","_callee18$","_context18","getLogs","queryFilter","_x27","_x28","_x29","_on","_callee19","_callee19$","_context19","_x30","_x31","_once","_callee20","_callee20$","_context20","_x32","_x33","_emit5","_callee21","_len5","_key5","_args21","_callee21$","_context21","_x34","_listenerCount","_callee22","_getInternal2","total","_iterator","_step","_callee22$","_context22","_createForOfIteratorHelper","s","n","done","err","f","listenerCount","_x35","_listeners","_callee23","_getInternal3","_iterator2","_step2","_listeners2","_callee23$","_context23","_ref14","_ref15","_x36","_off","_callee24","_callee24$","_context24","_ref16","splice","delete","_x37","_x38","_removeAllListeners","_callee25","_getInternal4","_iterator3","_step3","_step3$value","_callee25$","_context25","removeAllListeners","_x39","_addListener","_callee26","_callee26$","_context26","addListener","_x40","_x41","_removeListener","_callee27","_callee27$","_context27","removeListener","_x42","_x43","buildClass","CustomContract","_BaseContract","_inherits","_super","_createSuper","undefined","_ContractBase","Contract","_ContractBase2","_super2"],"sources":["C:\\Users\\Oguzhan\\Desktop\\BlockGuard\\mwallet\\node_modules\\ethers\\src.ts\\contract\\contract.ts"],"sourcesContent":["import { Interface, Typed } from \"../abi/index.js\";\nimport { resolveAddress } from \"../address/index.js\";\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nimport { copyRequest, Log, TransactionResponse } from \"../providers/provider.js\";\nimport {\n    defineProperties, isCallException, isHexString, resolveProperties,\n    makeError, assert, assertArgument\n} from \"../utils/index.js\";\n\nimport {\n    ContractEventPayload, ContractUnknownEventPayload,\n    ContractTransactionResponse,\n    EventLog\n} from \"./wrappers.js\";\n\nimport type { EventFragment, FunctionFragment, InterfaceAbi, ParamType, Result } from \"../abi/index.js\";\nimport type { Addressable } from \"../address/index.js\";\nimport type { EventEmitterable, Listener } from \"../utils/index.js\";\nimport type {\n    BlockTag, ContractRunner, Provider, TransactionRequest, TopicFilter\n} from \"../providers/index.js\";\n\nimport type {\n    BaseContractMethod,\n    ContractEventName,\n    ContractInterface,\n    ContractMethodArgs,\n    ContractMethod,\n    ContractEventArgs,\n    ContractEvent,\n    ContractTransaction,\n    DeferredTopicFilter,\n    WrappedFallback\n} from \"./types.js\";\n\nconst BN_0 = BigInt(0);\n\ninterface ContractRunnerCaller extends ContractRunner {\n    call: (tx: TransactionRequest) => Promise<string>;\n}\n\ninterface ContractRunnerEstimater extends ContractRunner {\n    estimateGas: (tx: TransactionRequest) => Promise<bigint>;\n}\n\ninterface ContractRunnerSender extends ContractRunner {\n    sendTransaction: (tx: TransactionRequest) => Promise<TransactionResponse>;\n}\n\ninterface ContractRunnerResolver extends ContractRunner {\n    resolveName: (name: string | Addressable) => Promise<null | string>;\n}\n\nfunction canCall(value: any): value is ContractRunnerCaller {\n    return (value && typeof(value.call) === \"function\");\n}\n\nfunction canEstimate(value: any): value is ContractRunnerEstimater {\n    return (value && typeof(value.estimateGas) === \"function\");\n}\n\nfunction canResolve(value: any): value is ContractRunnerResolver {\n    return (value && typeof(value.resolveName) === \"function\");\n}\n\nfunction canSend(value: any): value is ContractRunnerSender {\n    return (value && typeof(value.sendTransaction) === \"function\");\n}\n\nclass PreparedTopicFilter implements DeferredTopicFilter {\n    #filter: Promise<TopicFilter>;\n    readonly fragment!: EventFragment;\n\n    constructor(contract: BaseContract, fragment: EventFragment, args: Array<any>) {\n        defineProperties<PreparedTopicFilter>(this, { fragment });\n        if (fragment.inputs.length < args.length) {\n            throw new Error(\"too many arguments\");\n        }\n\n        // Recursively descend into args and resolve any addresses\n        const runner = getRunner(contract.runner, \"resolveName\");\n        const resolver = canResolve(runner) ? runner: null;\n        this.#filter = (async function() {\n            const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {\n                const arg = args[index];\n                if (arg == null) { return null; }\n\n                return param.walkAsync(args[index], (type, value) => {\n                    if (type === \"address\") {\n                        return resolveAddress(value, resolver);\n                    }\n                    return value;\n                });\n            }));\n\n            return contract.interface.encodeFilterTopics(fragment, resolvedArgs);\n        })();\n    }\n\n    getTopicFilter(): Promise<TopicFilter> {\n        return this.#filter;\n    }\n}\n\n\n// A = Arguments passed in as a tuple\n// R = The result type of the call (i.e. if only one return type,\n//     the qualified type, otherwise Result)\n// D = The type the default call will return (i.e. R for view/pure,\n//     TransactionResponse otherwise)\n//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {\n\nfunction getRunner<T extends ContractRunner>(value: any, feature: keyof ContractRunner): null | T {\n    if (value == null) { return null; }\n    if (typeof(value[feature]) === \"function\") { return value; }\n    if (value.provider && typeof(value.provider[feature]) === \"function\") {\n        return value.provider;\n    }\n    return null;\n}\n\nfunction getProvider(value: null | ContractRunner): null | Provider {\n    if (value == null) { return null; }\n    return value.provider || null;\n}\n\n/**\n *  @_ignore:\n */\nexport async function copyOverrides<O extends string = \"data\" | \"to\">(arg: any, allowed?: Array<string>): Promise<Omit<ContractTransaction, O>> {\n\n    // Create a shallow copy (we'll deep-ify anything needed during normalizing)\n    const overrides = copyRequest(Typed.dereference(arg, \"overrides\"));\n\n    assertArgument(overrides.to == null || (allowed || [ ]).indexOf(\"to\") >= 0,\n      \"cannot override to\", \"overrides.to\", overrides.to);\n    assertArgument(overrides.data == null || (allowed || [ ]).indexOf(\"data\") >= 0,\n      \"cannot override data\", \"overrides.data\", overrides.data);\n\n    // Resolve any from\n    if (overrides.from) {\n        overrides.from = await resolveAddress(overrides.from);\n    }\n\n    return <Omit<ContractTransaction, O>>overrides;\n}\n\n/**\n *  @_ignore:\n */\nexport async function resolveArgs(_runner: null | ContractRunner, inputs: ReadonlyArray<ParamType>, args: Array<any>): Promise<Array<any>> {\n    // Recursively descend into args and resolve any addresses\n    const runner = getRunner(_runner, \"resolveName\");\n    const resolver = canResolve(runner) ? runner: null;\n    return await Promise.all(inputs.map((param, index) => {\n        return param.walkAsync(args[index], (type, value) => {\n            value = Typed.dereference(value, type);\n            if (type === \"address\") { return resolveAddress(value, resolver); }\n            return value;\n        });\n    }));\n}\n\nfunction buildWrappedFallback(contract: BaseContract): WrappedFallback {\n\n    const populateTransaction = async function(overrides?: Omit<TransactionRequest, \"to\">): Promise<ContractTransaction> {\n        // If an overrides was passed in, copy it and normalize the values\n\n        const tx: ContractTransaction = <any>(await copyOverrides<\"data\">(overrides, [ \"data\" ]));\n        tx.to = await contract.getAddress();\n\n        const iface = contract.interface;\n\n        // Only allow payable contracts to set non-zero value\n        const payable = iface.receive || (iface.fallback && iface.fallback.payable);\n        assertArgument(payable || (tx.value || BN_0) === BN_0,\n          \"cannot send value to non-payable contract\", \"overrides.value\", tx.value);\n\n        // Only allow fallback contracts to set non-empty data\n        assertArgument(iface.fallback || (tx.data || \"0x\") === \"0x\",\n          \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n\n        return tx;\n    }\n\n    const staticCall = async function(overrides?: Omit<TransactionRequest, \"to\">): Promise<string> {\n        const runner = getRunner(contract.runner, \"call\");\n        assert(canCall(runner), \"contract runner does not support calling\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"call\" });\n\n        const tx = await populateTransaction(overrides);\n\n        try {\n            return await runner.call(tx);\n        } catch (error: any) {\n            if (isCallException(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n    }\n\n    const send = async function(overrides?: Omit<TransactionRequest, \"to\">): Promise<ContractTransactionResponse> {\n        const runner = contract.runner;\n        assert(canSend(runner), \"contract runner does not support sending transactions\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"sendTransaction\" });\n\n        const tx = await runner.sendTransaction(await populateTransaction(overrides));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new ContractTransactionResponse(contract.interface, <Provider>provider, tx);\n    }\n\n    const estimateGas = async function(overrides?: Omit<TransactionRequest, \"to\">): Promise<bigint> {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        assert(canEstimate(runner), \"contract runner does not support gas estimation\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"estimateGas\" });\n\n        return await runner.estimateGas(await populateTransaction(overrides));\n    }\n\n    const method = async (overrides?: Omit<TransactionRequest, \"to\">) => {\n        return await send(overrides);\n    };\n\n    defineProperties<any>(method, {\n        _contract: contract,\n\n        estimateGas,\n        populateTransaction,\n        send, staticCall\n    });\n\n    return <WrappedFallback>method;\n}\n\nfunction buildWrappedMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse>(contract: BaseContract, key: string): BaseContractMethod<A, R, D> {\n\n    const getFragment = function(...args: ContractMethodArgs<A>): FunctionFragment {\n        const fragment = contract.interface.getFunction(key, args);\n        assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\"\n        });\n        return fragment;\n    }\n\n    const populateTransaction = async function(...args: ContractMethodArgs<A>): Promise<ContractTransaction> {\n        const fragment = getFragment(...args);\n\n        // If an overrides was passed in, copy it and normalize the values\n        let overrides: Omit<ContractTransaction, \"data\" | \"to\"> = { };\n        if (fragment.inputs.length + 1 === args.length) {\n            overrides = await copyOverrides(args.pop());\n        }\n\n        if (fragment.inputs.length !== args.length) {\n            throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");\n        }\n\n        const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);\n\n        return Object.assign({ }, overrides, await resolveProperties({\n            to: contract.getAddress(),\n            data: contract.interface.encodeFunctionData(fragment, resolvedArgs)\n        }));\n    }\n\n    const staticCall = async function(...args: ContractMethodArgs<A>): Promise<R> {\n        const result = await staticCallResult(...args);\n        if (result.length === 1) { return result[0]; }\n        return <R><unknown>result;\n    }\n\n    const send = async function(...args: ContractMethodArgs<A>): Promise<ContractTransactionResponse> {\n        const runner = contract.runner;\n        assert(canSend(runner), \"contract runner does not support sending transactions\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"sendTransaction\" });\n\n        const tx = await runner.sendTransaction(await populateTransaction(...args));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new ContractTransactionResponse(contract.interface, <Provider>provider, tx);\n    }\n\n    const estimateGas = async function(...args: ContractMethodArgs<A>): Promise<bigint> {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        assert(canEstimate(runner), \"contract runner does not support gas estimation\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"estimateGas\" });\n\n        return await runner.estimateGas(await populateTransaction(...args));\n    }\n\n    const staticCallResult = async function(...args: ContractMethodArgs<A>): Promise<Result> {\n        const runner = getRunner(contract.runner, \"call\");\n        assert(canCall(runner), \"contract runner does not support calling\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"call\" });\n\n        const tx = await populateTransaction(...args);\n\n        let result = \"0x\";\n        try {\n            result = await runner.call(tx);\n        } catch (error: any) {\n            if (isCallException(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n\n        const fragment = getFragment(...args);\n        return contract.interface.decodeFunctionResult(fragment, result);\n    };\n\n    const method = async (...args: ContractMethodArgs<A>) => {\n        const fragment = getFragment(...args);\n        if (fragment.constant) { return await staticCall(...args); }\n        return await send(...args);\n    };\n\n    defineProperties<any>(method, {\n        name: contract.interface.getFunctionName(key),\n        _contract: contract, _key: key,\n\n        getFragment,\n\n        estimateGas,\n        populateTransaction,\n        send, staticCall, staticCallResult,\n    });\n\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n            const fragment = contract.interface.getFunction(key);\n            assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\"\n            });\n            return fragment;\n        }\n    });\n\n    return <BaseContractMethod<A, R, D>>method;\n}\n\nfunction buildWrappedEvent<A extends Array<any> = Array<any>>(contract: BaseContract, key: string): ContractEvent<A> {\n\n    const getFragment = function(...args: ContractEventArgs<A>): EventFragment {\n        const fragment = contract.interface.getEvent(key, args);\n\n        assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\"\n        });\n\n        return fragment;\n    }\n\n    const method = function(...args: ContractMethodArgs<A>): PreparedTopicFilter {\n        return new PreparedTopicFilter(contract, getFragment(...args), args);\n    };\n\n    defineProperties<any>(method, {\n        name: contract.interface.getEventName(key),\n        _contract: contract, _key: key,\n\n        getFragment\n    });\n\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n            const fragment = contract.interface.getEvent(key);\n\n            assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\"\n            });\n\n            return fragment;\n        }\n    });\n\n    return <ContractEvent<A>><unknown>method;\n}\n\ntype Sub = {\n    tag: string;\n    listeners: Array<{ listener: Listener, once: boolean }>,\n    start: () => void;\n    stop: () => void;\n};\n\n\n// The combination of TypeScrype, Private Fields and Proxies makes\n// the world go boom; so we hide variables with some trickery keeping\n// a symbol attached to each BaseContract which its sub-class (even\n// via a Proxy) can reach and use to look up its internal values.\n\nconst internal = Symbol.for(\"_ethersInternal_contract\");\ntype Internal = {\n    addrPromise: Promise<string>;\n    addr: null | string;\n\n    deployTx: null | ContractTransactionResponse;\n\n    subs: Map<string, Sub>;\n};\n\nconst internalValues: WeakMap<BaseContract, Internal> = new WeakMap();\n\nfunction setInternal(contract: BaseContract, values: Internal): void {\n    internalValues.set(contract[internal], values);\n}\n\nfunction getInternal(contract: BaseContract): Internal {\n    return internalValues.get(contract[internal]) as Internal;\n}\n\nfunction isDeferred(value: any): value is DeferredTopicFilter {\n    return (value && typeof(value) === \"object\" && (\"getTopicFilter\" in value) &&\n      (typeof(value.getTopicFilter) === \"function\") && value.fragment);\n}\n\nasync function getSubInfo(contract: BaseContract, event: ContractEventName): Promise<{ fragment: null | EventFragment, tag: string, topics: TopicFilter }> {\n    let topics: Array<null | string | Array<string>>;\n    let fragment: null | EventFragment = null;\n\n    // Convert named events to topicHash and get the fragment for\n    // events which need deconstructing.\n\n    if (Array.isArray(event)) {\n        const topicHashify = function(name: string): string {\n            if (isHexString(name, 32)) { return name; }\n            const fragment = contract.interface.getEvent(name);\n            assertArgument(fragment, \"unknown fragment\", \"name\", name);\n            return fragment.topicHash;\n        }\n\n        // Array of Topics and Names; e.g. `[ \"0x1234...89ab\", \"Transfer(address)\" ]`\n        topics = event.map((e) => {\n            if (e == null) { return null; }\n            if (Array.isArray(e)) { return e.map(topicHashify); }\n            return topicHashify(e);\n        });\n\n    } else if (event === \"*\") {\n        topics = [ null ];\n\n    } else if (typeof(event) === \"string\") {\n        if (isHexString(event, 32)) {\n            // Topic Hash\n            topics = [ event ];\n        } else {\n           // Name or Signature; e.g. `\"Transfer\", `\"Transfer(address)\"`\n            fragment = contract.interface.getEvent(event);\n            assertArgument(fragment, \"unknown fragment\", \"event\", event);\n            topics = [ fragment.topicHash ];\n        }\n\n    } else if (isDeferred(event)) {\n        // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`\n        topics = await event.getTopicFilter();\n\n    } else if (\"fragment\" in event) {\n        // ContractEvent; e.g. `contract.filter.Transfer`\n        fragment = event.fragment;\n        topics = [ fragment.topicHash ];\n\n    } else {\n        assertArgument(false, \"unknown event name\", \"event\", event);\n    }\n\n    // Normalize topics and sort TopicSets\n    topics = topics.map((t) => {\n        if (t == null) { return null; }\n        if (Array.isArray(t)) {\n            const items = Array.from(new Set(t.map((t) => t.toLowerCase())).values());\n            if (items.length === 1) { return items[0]; }\n            items.sort();\n            return items;\n        }\n        return t.toLowerCase();\n    });\n\n    const tag = topics.map((t) => {\n        if (t == null) { return \"null\"; }\n        if (Array.isArray(t)) { return t.join(\"|\"); }\n        return t;\n    }).join(\"&\");\n\n    return { fragment, tag, topics }\n}\n\nasync function hasSub(contract: BaseContract, event: ContractEventName): Promise<null | Sub> {\n    const { subs } = getInternal(contract);\n    return subs.get((await getSubInfo(contract, event)).tag) || null;\n}\n\nasync function getSub(contract: BaseContract, operation: string, event: ContractEventName): Promise<Sub> {\n    // Make sure our runner can actually subscribe to events\n    const provider = getProvider(contract.runner);\n    assert(provider, \"contract runner does not support subscribing\",\n        \"UNSUPPORTED_OPERATION\", { operation });\n\n    const { fragment, tag, topics } = await getSubInfo(contract, event);\n\n    const { addr, subs } = getInternal(contract);\n\n    let sub = subs.get(tag);\n    if (!sub) {\n        const address: string | Addressable = (addr ? addr: contract);\n        const filter = { address, topics };\n        const listener = (log: Log) => {\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = contract.interface.getEvent(log.topics[0]);\n                } catch (error) { }\n            }\n\n            // If fragment is null, we do not deconstruct the args to emit\n\n            if (foundFragment) {\n                const _foundFragment = foundFragment;\n                const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics): [ ];\n                emit(contract, event, args, (listener: null | Listener) => {\n                    return new ContractEventPayload(contract, listener, event, _foundFragment, log);\n                });\n            } else {\n                emit(contract, event, [ ], (listener: null | Listener) => {\n                    return new ContractUnknownEventPayload(contract, listener, event, log);\n                });\n            }\n        };\n\n        let starting: Array<Promise<any>> = [ ];\n        const start = () => {\n            if (starting.length) { return; }\n            starting.push(provider.on(filter, listener));\n        };\n\n        const stop = async () => {\n            if (starting.length == 0) { return; }\n\n            let started = starting;\n            starting = [ ];\n            await Promise.all(started);\n            provider.off(filter, listener);\n        };\n\n        sub = { tag, listeners: [ ], start, stop };\n        subs.set(tag, sub);\n    }\n    return sub;\n}\n\n// We use this to ensure one emit resolves before firing the next to\n// ensure correct ordering (note this cannot throw and just adds the\n// notice to the event queu using setTimeout).\nlet lastEmit: Promise<any> = Promise.resolve();\n\ntype PayloadFunc = (listener: null | Listener) => ContractUnknownEventPayload;\n\nasync function _emit(contract: BaseContract, event: ContractEventName, args: Array<any>, payloadFunc: null | PayloadFunc): Promise<boolean> {\n    await lastEmit;\n\n    const sub = await hasSub(contract, event);\n    if (!sub) { return false; }\n\n    const count = sub.listeners.length;\n    sub.listeners = sub.listeners.filter(({ listener, once }) => {\n        const passArgs = Array.from(args);\n        if (payloadFunc) {\n            passArgs.push(payloadFunc(once ? null: listener));\n        }\n        try {\n            listener.call(contract, ...passArgs);\n        } catch (error) { }\n        return !once;\n    });\n    return (count > 0);\n}\n\nasync function emit(contract: BaseContract, event: ContractEventName, args: Array<any>, payloadFunc: null | PayloadFunc): Promise<boolean> {\n    try {\n        await lastEmit;\n    } catch (error) { }\n\n    const resultPromise = _emit(contract, event, args, payloadFunc);\n    lastEmit = resultPromise;\n    return await resultPromise;\n}\n\nconst passProperties = [ \"then\" ];\nexport class BaseContract implements Addressable, EventEmitterable<ContractEventName> {\n    readonly target!: string | Addressable;\n    readonly interface!: Interface;\n    readonly runner!: null | ContractRunner;\n\n    readonly filters!: Record<string, ContractEvent>;\n\n    readonly [internal]: any;\n\n    readonly fallback!: null | WrappedFallback;\n\n    constructor(target: string | Addressable, abi: Interface | InterfaceAbi, runner?: null | ContractRunner, _deployTx?: null | TransactionResponse) {\n        if (runner == null) { runner = null; }\n        const iface = Interface.from(abi);\n        defineProperties<BaseContract>(this, { target, runner, interface: iface });\n\n        Object.defineProperty(this, internal, { value: { } });\n\n        let addrPromise;\n        let addr = null;\n\n        let deployTx: null | ContractTransactionResponse = null;\n        if (_deployTx) {\n            const provider = getProvider(runner);\n            // @TODO: the provider can be null; make a custom dummy provider that will throw a\n            // meaningful error\n            deployTx = new ContractTransactionResponse(this.interface, <Provider>provider, _deployTx);\n        }\n\n        let subs = new Map();\n\n        // Resolve the target as the address\n        if (typeof(target) === \"string\") {\n            if (isHexString(target)) {\n                addr = target;\n                addrPromise = Promise.resolve(target);\n\n            } else {\n                const resolver = getRunner(runner, \"resolveName\");\n                if (!canResolve(resolver)) {\n                    throw makeError(\"contract runner does not support name resolution\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"resolveName\"\n                    });\n                }\n\n                addrPromise = resolver.resolveName(target).then((addr) => {\n                    if (addr == null) { throw new Error(\"TODO\"); }\n                    getInternal(this).addr = addr;\n                    return addr;\n                });\n            }\n        } else {\n            addrPromise = target.getAddress().then((addr) => {\n                if (addr == null) { throw new Error(\"TODO\"); }\n                getInternal(this).addr = addr;\n                return addr;\n            });\n        }\n\n        // Set our private values\n        setInternal(this, { addrPromise, addr, deployTx, subs });\n\n        // Add the event filters\n        const filters = new Proxy({ }, {\n            get: (target, _prop, receiver) => {\n                // Pass important checks (like `then` for Promise) through\n                if (passProperties.indexOf(<string>_prop) >= 0) {\n                    return Reflect.get(target, _prop, receiver);\n                }\n\n                const prop = String(_prop);\n\n                const result = this.getEvent(prop);\n                if (result) { return result; }\n\n                throw new Error(`unknown contract event: ${ prop }`);\n            },\n            has: (target, prop) => {\n                // Pass important checks (like `then` for Promise) through\n                if (passProperties.indexOf(<string>prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n\n                return Reflect.has(target, prop) || this.interface.hasEvent(String(prop));\n            }\n        });\n        defineProperties<BaseContract>(this, { filters });\n\n        defineProperties<BaseContract>(this, {\n            fallback: ((iface.receive || iface.fallback) ? (buildWrappedFallback(this)): null)\n        });\n\n        // Return a Proxy that will respond to functions\n        return new Proxy(this, {\n            get: (target, _prop, receiver) => {\n                if (_prop in target || passProperties.indexOf(<string>_prop) >= 0) {\n                    return Reflect.get(target, _prop, receiver);\n                }\n\n                const prop = String(_prop);\n\n                const result = target.getFunction(prop);\n                if (result) { return result; }\n\n                throw new Error(`unknown contract method: ${ prop }`);\n            },\n            has: (target, prop) => {\n                if (prop in target || passProperties.indexOf(<string>prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n\n                return target.interface.hasFunction(String(prop));\n            }\n        });\n\n    }\n\n    connect(runner: null | ContractRunner): BaseContract {\n        return new BaseContract(this.target, this.interface, runner);\n    }\n\n    async getAddress(): Promise<string> { return await getInternal(this).addrPromise; }\n\n    async getDeployedCode(): Promise<null | string> {\n        const provider = getProvider(this.runner);\n        assert(provider, \"runner does not support .provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"getDeployedCode\" });\n\n        const code = await provider.getCode(await this.getAddress());\n        if (code === \"0x\") { return null; }\n        return code;\n    }\n\n    async waitForDeployment(): Promise<this> {\n        // We have the deployement transaction; just use that (throws if deployement fails)\n        const deployTx = this.deploymentTransaction();\n        if (deployTx) {\n            await deployTx.wait();\n            return this;\n        }\n\n        // Check for code\n        const code = await this.getDeployedCode();\n        if (code != null) { return this; }\n\n        // Make sure we can subscribe to a provider event\n        const provider = getProvider(this.runner);\n        assert(provider != null, \"contract runner does not support .provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"waitForDeployment\" });\n\n        return new Promise((resolve, reject) => {\n            const checkCode = async () => {\n                try {\n                    const code = await this.getDeployedCode();\n                    if (code != null) { return resolve(this); }\n                    provider.once(\"block\", checkCode);\n                } catch (error) {\n                    reject(error);\n                }\n            };\n            checkCode();\n        });\n    }\n\n    deploymentTransaction(): null | ContractTransactionResponse {\n        return getInternal(this).deployTx;\n    }\n\n    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T {\n        if (typeof(key) !== \"string\") { key = key.format(); }\n        const func = buildWrappedMethod(this, key);\n        return <T>func;\n    }\n\n    getEvent(key: string | EventFragment): ContractEvent {\n        if (typeof(key) !== \"string\") { key = key.format(); }\n        return buildWrappedEvent(this, key);\n    }\n\n    async queryTransaction(hash: string): Promise<Array<EventLog>> {\n        // Is this useful?\n        throw new Error(\"@TODO\");\n    }\n\n    async queryFilter(event: ContractEventName, fromBlock?: BlockTag, toBlock?: BlockTag): Promise<Array<EventLog | Log>> {\n        if (fromBlock == null) { fromBlock = 0; }\n        if (toBlock == null) { toBlock = \"latest\"; }\n        const { addr, addrPromise } = getInternal(this);\n        const address = (addr ? addr: (await addrPromise));\n        const { fragment, topics } = await getSubInfo(this, event);\n        const filter = { address, topics, fromBlock, toBlock };\n\n        const provider = getProvider(this.runner);\n        assert(provider, \"contract runner does not have a provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"queryFilter\" });\n\n        return (await provider.getLogs(filter)).map((log) => {\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = this.interface.getEvent(log.topics[0]);\n                } catch (error) { }\n            }\n\n            if (foundFragment) {\n                return new EventLog(log, this.interface, foundFragment);\n            } else {\n                return new Log(log, provider);\n            }\n        });\n    }\n\n    async on(event: ContractEventName, listener: Listener): Promise<this> {\n        const sub = await getSub(this, \"on\", event);\n        sub.listeners.push({ listener, once: false });\n        sub.start();\n        return this;\n    }\n\n    async once(event: ContractEventName, listener: Listener): Promise<this> {\n        const sub = await getSub(this, \"once\", event);\n        sub.listeners.push({ listener, once: true });\n        sub.start();\n        return this;\n    }\n\n    async emit(event: ContractEventName, ...args: Array<any>): Promise<boolean> {\n        return await emit(this, event, args, null);\n    }\n\n    async listenerCount(event?: ContractEventName): Promise<number> {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) { return 0; }\n            return sub.listeners.length;\n        }\n\n        const { subs } = getInternal(this);\n\n        let total = 0;\n        for (const { listeners } of subs.values()) {\n            total += listeners.length;\n        }\n        return total;\n    }\n\n    async listeners(event?: ContractEventName): Promise<Array<Listener>> {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) { return [ ]; }\n            return sub.listeners.map(({ listener }) => listener);\n        }\n\n        const { subs } = getInternal(this);\n\n        let result: Array<Listener> = [ ];\n        for (const { listeners } of subs.values()) {\n            result = result.concat(listeners.map(({ listener }) => listener));\n        }\n        return result;\n    }\n\n    async off(event: ContractEventName, listener?: Listener): Promise<this> {\n        const sub = await hasSub(this, event);\n        if (!sub) { return this; }\n\n        if (listener) {\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\n            if (index >= 0) { sub.listeners.splice(index, 1); }\n        }\n\n        if (listener == null || sub.listeners.length === 0) {\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        }\n\n        return this;\n    }\n\n    async removeAllListeners(event?: ContractEventName): Promise<this> {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) { return this; }\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        } else {\n            const { subs } = getInternal(this);\n            for (const { tag, stop } of subs.values()) {\n                stop();\n                subs.delete(tag);\n            }\n        }\n\n        return this;\n    }\n\n    // Alias for \"on\"\n    async addListener(event: ContractEventName, listener: Listener): Promise<this> {\n        return await this.on(event, listener);\n    }\n\n    // Alias for \"off\"\n    async removeListener(event: ContractEventName, listener: Listener): Promise<this> {\n        return await this.off(event, listener);\n    }\n\n    static buildClass<T = ContractInterface>(abi: InterfaceAbi): new (target: string, runner?: null | ContractRunner) => BaseContract & Omit<T, keyof BaseContract> {\n        class CustomContract extends BaseContract {\n            constructor(address: string, runner: null | ContractRunner = null) {\n                super(address, abi, runner);\n            }\n        }\n        return CustomContract as any;\n    };\n\n    static from<T = ContractInterface>(target: string, abi: InterfaceAbi, runner?: null | ContractRunner): BaseContract & Omit<T, keyof BaseContract> {\n        if (runner == null) { runner = null; }\n        const contract = new this(target, abi, runner );\n        return contract as any;\n    }\n}\n\nfunction _ContractBase(): new (target: string, abi: InterfaceAbi, runner?: null | ContractRunner) => BaseContract & Omit<ContractInterface, keyof BaseContract> {\n    return BaseContract as any;\n}\n\nexport class Contract extends _ContractBase() { }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}