{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/Oguzhan/Desktop/BlockGuard/mwallet/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { scrypt as _nobleSync, scryptAsync as _nobleAsync } from \"@noble/hashes/scrypt\";\nimport { getBytes, hexlify as H } from \"../utils/index.js\";\nvar lockedSync = false,\n  lockedAsync = false;\nvar _scryptAsync = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(passwd, salt, N, r, p, dkLen, onProgress) {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return _nobleAsync(passwd, salt, {\n            N: N,\n            r: r,\n            p: p,\n            dkLen: dkLen,\n            onProgress: onProgress\n          });\n        case 2:\n          return _context.abrupt(\"return\", _context.sent);\n        case 3:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function _scryptAsync(_x, _x2, _x3, _x4, _x5, _x6, _x7) {\n    return _ref.apply(this, arguments);\n  };\n}();\nvar _scryptSync = function _scryptSync(passwd, salt, N, r, p, dkLen) {\n  return _nobleSync(passwd, salt, {\n    N: N,\n    r: r,\n    p: p,\n    dkLen: dkLen\n  });\n};\nvar __scryptAsync = _scryptAsync;\nvar __scryptSync = _scryptSync;\n/**\n *  The [[link-wiki-scrypt]] uses a memory and cpu hard method of\n *  derivation to increase the resource cost to brute-force a password\n *  for a given key.\n *\n *  This means this algorithm is intentionally slow, and can be tuned to\n *  become slower. As computation and memory speed improve over time,\n *  increasing the difficulty maintains the cost of an attacker.\n *\n *  For example, if a target time of 5 seconds is used, a legitimate user\n *  which knows their password requires only 5 seconds to unlock their\n *  account. A 6 character password has 68 billion possibilities, which\n *  would require an attacker to invest over 10,000 years of CPU time. This\n *  is of course a crude example (as password generally aren't random),\n *  but demonstrates to value of imposing large costs to decryption.\n *\n *  For this reason, if building a UI which involved decrypting or\n *  encrypting datsa using scrypt, it is recommended to use a\n *  [[ProgressCallback]] (as event short periods can seem lik an eternity\n *  if the UI freezes). Including the phrase //\"decrypting\"// in the UI\n *  can also help, assuring the user their waiting is for a good reason.\n *\n *  @_docloc: api/crypto:Passwords\n *\n *  @example:\n *    // The password must be converted to bytes, and it is generally\n *    // best practices to ensure the string has been normalized. Many\n *    // formats explicitly indicate the normalization form to use.\n *    password = \"hello\"\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\n *\n *    salt = id(\"some-salt\")\n *\n *    // Compute the scrypt\n *    scrypt(passwordBytes, salt, 1024, 8, 1, 16)\n *    //_result:\n */\nexport function scrypt(_x8, _x9, _x10, _x11, _x12, _x13, _x14) {\n  return _scrypt.apply(this, arguments);\n}\nfunction _scrypt() {\n  _scrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_passwd, _salt, N, r, p, dkLen, progress) {\n    var passwd, salt;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          passwd = getBytes(_passwd, \"passwd\");\n          salt = getBytes(_salt, \"salt\");\n          _context2.t0 = H;\n          _context2.next = 5;\n          return __scryptAsync(passwd, salt, N, r, p, dkLen, progress);\n        case 5:\n          _context2.t1 = _context2.sent;\n          return _context2.abrupt(\"return\", (0, _context2.t0)(_context2.t1));\n        case 7:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _scrypt.apply(this, arguments);\n}\nscrypt._ = _scryptAsync;\nscrypt.lock = function () {\n  lockedAsync = true;\n};\nscrypt.register = function (func) {\n  if (lockedAsync) {\n    throw new Error(\"scrypt is locked\");\n  }\n  __scryptAsync = func;\n};\nObject.freeze(scrypt);\n/**\n *  Provides a synchronous variant of [[scrypt]].\n *\n *  This will completely lock up and freeze the UI in a browser and will\n *  prevent any event loop from progressing. For this reason, it is\n *  preferred to use the [async variant](scrypt).\n *\n *  @_docloc: api/crypto:Passwords\n *\n *  @example:\n *    // The password must be converted to bytes, and it is generally\n *    // best practices to ensure the string has been normalized. Many\n *    // formats explicitly indicate the normalization form to use.\n *    password = \"hello\"\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\n *\n *    salt = id(\"some-salt\")\n *\n *    // Compute the scrypt\n *    scryptSync(passwordBytes, salt, 1024, 8, 1, 16)\n *    //_result:\n */\nexport function scryptSync(_passwd, _salt, N, r, p, dkLen) {\n  var passwd = getBytes(_passwd, \"passwd\");\n  var salt = getBytes(_salt, \"salt\");\n  return H(__scryptSync(passwd, salt, N, r, p, dkLen));\n}\nscryptSync._ = _scryptSync;\nscryptSync.lock = function () {\n  lockedSync = true;\n};\nscryptSync.register = function (func) {\n  if (lockedSync) {\n    throw new Error(\"scryptSync is locked\");\n  }\n  __scryptSync = func;\n};\nObject.freeze(scryptSync);","map":{"version":3,"names":["scrypt","_nobleSync","scryptAsync","_nobleAsync","getBytes","hexlify","H","lockedSync","lockedAsync","_scryptAsync","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","passwd","salt","N","r","p","dkLen","onProgress","wrap","_callee$","_context","prev","next","abrupt","sent","stop","_x","_x2","_x3","_x4","_x5","_x6","_x7","apply","arguments","_scryptSync","__scryptAsync","__scryptSync","_x8","_x9","_x10","_x11","_x12","_x13","_x14","_scrypt","_callee2","_passwd","_salt","progress","_callee2$","_context2","t0","t1","_","lock","register","func","Error","Object","freeze","scryptSync"],"sources":["C:\\Users\\Oguzhan\\Desktop\\BlockGuard\\mwallet\\node_modules\\ethers\\src.ts\\crypto\\scrypt.ts"],"sourcesContent":["import { scrypt as _nobleSync, scryptAsync as _nobleAsync } from \"@noble/hashes/scrypt\";\n\nimport { getBytes, hexlify as H } from \"../utils/index.js\";\n\nimport type { BytesLike } from \"../utils/index.js\";\n\n/**\n *  A callback during long-running operations to update any\n *  UI or provide programatic access to the progress.\n *\n *  The %%percent%% is a value between ``0`` and ``1``.\n *\n *  @_docloc: api/crypto:Passwords\n */\nexport type ProgressCallback = (percent: number) => void;\n\n\nlet lockedSync = false, lockedAsync = false;\n\nconst _scryptAsync = async function(passwd: Uint8Array, salt: Uint8Array, N: number, r: number, p: number, dkLen: number, onProgress?: ProgressCallback) {\n    return await _nobleAsync(passwd, salt, { N, r, p, dkLen, onProgress });\n}\nconst _scryptSync = function(passwd: Uint8Array, salt: Uint8Array, N: number, r: number, p: number, dkLen: number) {\n    return _nobleSync(passwd, salt, { N, r, p, dkLen });\n}\n\nlet __scryptAsync: (passwd: Uint8Array, salt: Uint8Array, N: number, r: number, p: number, dkLen: number, onProgress?: ProgressCallback) => Promise<BytesLike> = _scryptAsync;\nlet __scryptSync: (passwd: Uint8Array, salt: Uint8Array, N: number, r: number, p: number, dkLen: number) => BytesLike = _scryptSync\n\n\n/**\n *  The [[link-wiki-scrypt]] uses a memory and cpu hard method of\n *  derivation to increase the resource cost to brute-force a password\n *  for a given key.\n *\n *  This means this algorithm is intentionally slow, and can be tuned to\n *  become slower. As computation and memory speed improve over time,\n *  increasing the difficulty maintains the cost of an attacker.\n *\n *  For example, if a target time of 5 seconds is used, a legitimate user\n *  which knows their password requires only 5 seconds to unlock their\n *  account. A 6 character password has 68 billion possibilities, which\n *  would require an attacker to invest over 10,000 years of CPU time. This\n *  is of course a crude example (as password generally aren't random),\n *  but demonstrates to value of imposing large costs to decryption.\n *\n *  For this reason, if building a UI which involved decrypting or\n *  encrypting datsa using scrypt, it is recommended to use a\n *  [[ProgressCallback]] (as event short periods can seem lik an eternity\n *  if the UI freezes). Including the phrase //\"decrypting\"// in the UI\n *  can also help, assuring the user their waiting is for a good reason.\n *\n *  @_docloc: api/crypto:Passwords\n *\n *  @example:\n *    // The password must be converted to bytes, and it is generally\n *    // best practices to ensure the string has been normalized. Many\n *    // formats explicitly indicate the normalization form to use.\n *    password = \"hello\"\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\n *\n *    salt = id(\"some-salt\")\n *\n *    // Compute the scrypt\n *    scrypt(passwordBytes, salt, 1024, 8, 1, 16)\n *    //_result:\n */\nexport async function scrypt(_passwd: BytesLike, _salt: BytesLike, N: number, r: number, p: number, dkLen: number, progress?: ProgressCallback): Promise<string> {\n    const passwd = getBytes(_passwd, \"passwd\");\n    const salt = getBytes(_salt, \"salt\");\n    return H(await __scryptAsync(passwd, salt, N, r, p, dkLen, progress));\n}\nscrypt._ = _scryptAsync;\nscrypt.lock = function(): void { lockedAsync = true; }\nscrypt.register = function(func: (passwd: Uint8Array, salt: Uint8Array, N: number, r: number, p: number, dkLen: number, progress?: ProgressCallback) => Promise<BytesLike>) {\n    if (lockedAsync) { throw new Error(\"scrypt is locked\"); }\n    __scryptAsync = func;\n}\nObject.freeze(scrypt);\n\n/**\n *  Provides a synchronous variant of [[scrypt]].\n *\n *  This will completely lock up and freeze the UI in a browser and will\n *  prevent any event loop from progressing. For this reason, it is\n *  preferred to use the [async variant](scrypt).\n *\n *  @_docloc: api/crypto:Passwords\n *\n *  @example:\n *    // The password must be converted to bytes, and it is generally\n *    // best practices to ensure the string has been normalized. Many\n *    // formats explicitly indicate the normalization form to use.\n *    password = \"hello\"\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\n *\n *    salt = id(\"some-salt\")\n *\n *    // Compute the scrypt\n *    scryptSync(passwordBytes, salt, 1024, 8, 1, 16)\n *    //_result:\n */\nexport function scryptSync(_passwd: BytesLike, _salt: BytesLike, N: number, r: number, p: number, dkLen: number): string {\n    const passwd = getBytes(_passwd, \"passwd\");\n    const salt = getBytes(_salt, \"salt\");\n    return H(__scryptSync(passwd, salt, N, r, p, dkLen));\n}\nscryptSync._ = _scryptSync;\nscryptSync.lock = function(): void { lockedSync = true; }\nscryptSync.register = function(func: (passwd: Uint8Array, salt: Uint8Array, N: number, r: number, p: number, dkLen: number) => BytesLike) {\n    if (lockedSync) { throw new Error(\"scryptSync is locked\"); }\n    __scryptSync = func;\n}\nObject.freeze(scryptSync);\n"],"mappings":";;AAAA,SAASA,MAAM,IAAIC,UAAU,EAAEC,WAAW,IAAIC,WAAW,QAAQ,sBAAsB;AAEvF,SAASC,QAAQ,EAAEC,OAAO,IAAIC,CAAC,QAAQ,mBAAmB;AAe1D,IAAIC,UAAU,GAAG,KAAK;EAAEC,WAAW,GAAG,KAAK;AAE3C,IAAMC,YAAY;EAAA,IAAAC,IAAA,GAAAC,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAAG,SAAAC,QAAeC,MAAkB,EAAEC,IAAgB,EAAEC,CAAS,EAAEC,CAAS,EAAEC,CAAS,EAAEC,KAAa,EAAEC,UAA6B;IAAA,OAAAT,mBAAA,GAAAU,IAAA,UAAAC,SAAAC,QAAA;MAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;QAAA;UAAAF,QAAA,CAAAE,IAAA;UAAA,OACtIvB,WAAW,CAACY,MAAM,EAAEC,IAAI,EAAE;YAAEC,CAAC,EAADA,CAAC;YAAEC,CAAC,EAADA,CAAC;YAAEC,CAAC,EAADA,CAAC;YAAEC,KAAK,EAALA,KAAK;YAAEC,UAAU,EAAVA;UAAU,CAAE,CAAC;QAAA;UAAA,OAAAG,QAAA,CAAAG,MAAA,WAAAH,QAAA,CAAAI,IAAA;QAAA;QAAA;UAAA,OAAAJ,QAAA,CAAAK,IAAA;MAAA;IAAA,GAAAf,OAAA;EAAA,CACzE;EAAA,gBAFKL,YAAYA,CAAAqB,EAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA;IAAA,OAAA1B,IAAA,CAAA2B,KAAA,OAAAC,SAAA;EAAA;AAAA,GAEjB;AACD,IAAMC,WAAW,GAAG,SAAdA,WAAWA,CAAYxB,MAAkB,EAAEC,IAAgB,EAAEC,CAAS,EAAEC,CAAS,EAAEC,CAAS,EAAEC,KAAa;EAC7G,OAAOnB,UAAU,CAACc,MAAM,EAAEC,IAAI,EAAE;IAAEC,CAAC,EAADA,CAAC;IAAEC,CAAC,EAADA,CAAC;IAAEC,CAAC,EAADA,CAAC;IAAEC,KAAK,EAALA;EAAK,CAAE,CAAC;AACvD,CAAC;AAED,IAAIoB,aAAa,GAAgJ/B,YAAY;AAC7K,IAAIgC,YAAY,GAAwGF,WAAW;AAGnI;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCA,gBAAsBvC,MAAMA,CAAA0C,GAAA,EAAAC,GAAA,EAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA;EAAA,OAAAC,OAAA,CAAAZ,KAAA,OAAAC,SAAA;AAAA;AAI3B,SAAAW,QAAA;EAAAA,OAAA,GAAAtC,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAJM,SAAAqC,SAAsBC,OAAkB,EAAEC,KAAgB,EAAEnC,CAAS,EAAEC,CAAS,EAAEC,CAAS,EAAEC,KAAa,EAAEiC,QAA2B;IAAA,IAAAtC,MAAA,EAAAC,IAAA;IAAA,OAAAJ,mBAAA,GAAAU,IAAA,UAAAgC,UAAAC,SAAA;MAAA,kBAAAA,SAAA,CAAA9B,IAAA,GAAA8B,SAAA,CAAA7B,IAAA;QAAA;UACpIX,MAAM,GAAGX,QAAQ,CAAC+C,OAAO,EAAE,QAAQ,CAAC;UACpCnC,IAAI,GAAGZ,QAAQ,CAACgD,KAAK,EAAE,MAAM,CAAC;UAAAG,SAAA,CAAAC,EAAA,GAC7BlD,CAAC;UAAAiD,SAAA,CAAA7B,IAAA;UAAA,OAAOc,aAAa,CAACzB,MAAM,EAAEC,IAAI,EAAEC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,KAAK,EAAEiC,QAAQ,CAAC;QAAA;UAAAE,SAAA,CAAAE,EAAA,GAAAF,SAAA,CAAA3B,IAAA;UAAA,OAAA2B,SAAA,CAAA5B,MAAA,eAAA4B,SAAA,CAAAC,EAAA,EAAAD,SAAA,CAAAE,EAAA;QAAA;QAAA;UAAA,OAAAF,SAAA,CAAA1B,IAAA;MAAA;IAAA,GAAAqB,QAAA;EAAA,CACvE;EAAA,OAAAD,OAAA,CAAAZ,KAAA,OAAAC,SAAA;AAAA;AACDtC,MAAM,CAAC0D,CAAC,GAAGjD,YAAY;AACvBT,MAAM,CAAC2D,IAAI,GAAG;EAAmBnD,WAAW,GAAG,IAAI;AAAE,CAAC;AACtDR,MAAM,CAAC4D,QAAQ,GAAG,UAASC,IAA+I;EACtK,IAAIrD,WAAW,EAAE;IAAE,MAAM,IAAIsD,KAAK,CAAC,kBAAkB,CAAC;;EACtDtB,aAAa,GAAGqB,IAAI;AACxB,CAAC;AACDE,MAAM,CAACC,MAAM,CAAChE,MAAM,CAAC;AAErB;;;;;;;;;;;;;;;;;;;;;;AAsBA,OAAM,SAAUiE,UAAUA,CAACd,OAAkB,EAAEC,KAAgB,EAAEnC,CAAS,EAAEC,CAAS,EAAEC,CAAS,EAAEC,KAAa;EAC3G,IAAML,MAAM,GAAGX,QAAQ,CAAC+C,OAAO,EAAE,QAAQ,CAAC;EAC1C,IAAMnC,IAAI,GAAGZ,QAAQ,CAACgD,KAAK,EAAE,MAAM,CAAC;EACpC,OAAO9C,CAAC,CAACmC,YAAY,CAAC1B,MAAM,EAAEC,IAAI,EAAEC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,KAAK,CAAC,CAAC;AACxD;AACA6C,UAAU,CAACP,CAAC,GAAGnB,WAAW;AAC1B0B,UAAU,CAACN,IAAI,GAAG;EAAmBpD,UAAU,GAAG,IAAI;AAAE,CAAC;AACzD0D,UAAU,CAACL,QAAQ,GAAG,UAASC,IAAyG;EACpI,IAAItD,UAAU,EAAE;IAAE,MAAM,IAAIuD,KAAK,CAAC,sBAAsB,CAAC;;EACzDrB,YAAY,GAAGoB,IAAI;AACvB,CAAC;AACDE,MAAM,CAACC,MAAM,CAACC,UAAU,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}